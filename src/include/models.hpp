/*
    hBayesDM is distributed under the terms of the GNU General Public 
    License but without any warranty. See the GNU General Public 
    License for more details.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_bandit2arm_delta_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_bandit2arm_delta");
    reader.add_event(106, 106, "end", "model_bandit2arm_delta");
    return reader;
}

class model_bandit2arm_delta : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > outcome;
    vector_d initV;
public:
    model_bandit2arm_delta(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_bandit2arm_delta(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_bandit2arm_delta_namespace::model_bandit2arm_delta";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],2);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            validate_non_negative_index("A_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("tau_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_bandit2arm_delta() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("A_pr")))
            throw std::runtime_error("variable A_pr missing");
        vals_r__ = context__.vals_r("A_pr");
        pos__ = 0U;
        validate_non_negative_index("A_pr", "N", N);
        context__.validate_dims("initialization", "A_pr", "vector_d", context__.to_vec(N));
        vector_d A_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            A_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(A_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable A_pr: ") + e.what());
        }

        if (!(context__.contains_r("tau_pr")))
            throw std::runtime_error("variable tau_pr missing");
        vals_r__ = context__.vals_r("tau_pr");
        pos__ = 0U;
        validate_non_negative_index("tau_pr", "N", N);
        context__.validate_dims("initialization", "tau_pr", "vector_d", context__.to_vec(N));
        vector_d tau_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  A_pr;
            (void) A_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                A_pr = in__.vector_constrain(N,lp__);
            else
                A_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_pr;
            (void) tau_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_pr = in__.vector_constrain(N,lp__);
            else
                tau_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("A", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, DUMMY_VAR__);
            stan::math::fill(A,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(A(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: A" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            check_greater_or_equal(function__,"tau",tau,0);
            check_less_or_equal(function__,"tau",tau,5);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(A_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(tau_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                T__ PE;
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, DUMMY_VAR__);
                stan::math::fill(PE,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), multiply(get_base1(tau,i,"tau",1),ev)));
                    stan::math::assign(PE, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(A,i,"A",1) * PE)));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("A_pr");
        names__.push_back("tau_pr");
        names__.push_back("A");
        names__.push_back("tau");
        names__.push_back("mu_A");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_bandit2arm_delta_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d A_pr = in__.vector_constrain(N);
        vector_d tau_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("A", "N", N);
            vector_d A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(A,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * 5));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            check_greater_or_equal(function__,"tau",tau,0);
            check_less_or_equal(function__,"tau",tau,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_A(0.0);
            (void) mu_A;  // dummy to suppress unused var warning

            stan::math::initialize(mu_A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_A,DUMMY_VAR__);
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_A, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_tau, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 5));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                double PE(0.0);
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PE,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),multiply(get_base1(tau,i,"tau",1),ev))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(multiply(get_base1(tau,i,"tau",1),ev)), base_rng__));
                    stan::math::assign(PE, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(A,i,"A",1) * PE)));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_A",mu_A,0);
            check_less_or_equal(function__,"mu_A",mu_A,1);
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);
            check_less_or_equal(function__,"mu_tau",mu_tau,5);

            // write generated quantities
        vars__.push_back(mu_A);
        vars__.push_back(mu_tau);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_bandit2arm_delta";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_bandit4arm_4par_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_bandit4arm_4par");
    reader.add_event(173, 173, "end", "model_bandit4arm_4par");
    return reader;
}

class model_bandit4arm_4par : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > rew;
    vector<vector<double> > los;
    vector<vector<int> > choice;
    vector_d initV;
public:
    model_bandit4arm_4par(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_bandit4arm_4par(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_bandit4arm_4par_namespace::model_bandit4arm_4par";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("rew", "N", N);
            validate_non_negative_index("rew", "T", T);
            context__.validate_dims("data initialization", "rew", "double", context__.to_vec(N,T));
            validate_non_negative_index("rew", "N", N);
            validate_non_negative_index("rew", "T", T);
            rew = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("rew");
            pos__ = 0;
            size_t rew_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < rew_limit_1__; ++i_1__) {
                size_t rew_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < rew_limit_0__; ++i_0__) {
                    rew[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("los", "N", N);
            validate_non_negative_index("los", "T", T);
            context__.validate_dims("data initialization", "los", "double", context__.to_vec(N,T));
            validate_non_negative_index("los", "N", N);
            validate_non_negative_index("los", "T", T);
            los = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("los");
            pos__ = 0;
            size_t los_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < los_limit_1__; ++i_1__) {
                size_t los_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < los_limit_0__; ++i_0__) {
                    los[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("Arew_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("Apun_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("R_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("P_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_bandit4arm_4par() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("Arew_pr")))
            throw std::runtime_error("variable Arew_pr missing");
        vals_r__ = context__.vals_r("Arew_pr");
        pos__ = 0U;
        validate_non_negative_index("Arew_pr", "N", N);
        context__.validate_dims("initialization", "Arew_pr", "vector_d", context__.to_vec(N));
        vector_d Arew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Arew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Arew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Arew_pr: ") + e.what());
        }

        if (!(context__.contains_r("Apun_pr")))
            throw std::runtime_error("variable Apun_pr missing");
        vals_r__ = context__.vals_r("Apun_pr");
        pos__ = 0U;
        validate_non_negative_index("Apun_pr", "N", N);
        context__.validate_dims("initialization", "Apun_pr", "vector_d", context__.to_vec(N));
        vector_d Apun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Apun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Apun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Apun_pr: ") + e.what());
        }

        if (!(context__.contains_r("R_pr")))
            throw std::runtime_error("variable R_pr missing");
        vals_r__ = context__.vals_r("R_pr");
        pos__ = 0U;
        validate_non_negative_index("R_pr", "N", N);
        context__.validate_dims("initialization", "R_pr", "vector_d", context__.to_vec(N));
        vector_d R_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            R_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(R_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable R_pr: ") + e.what());
        }

        if (!(context__.contains_r("P_pr")))
            throw std::runtime_error("variable P_pr missing");
        vals_r__ = context__.vals_r("P_pr");
        pos__ = 0U;
        validate_non_negative_index("P_pr", "N", N);
        context__.validate_dims("initialization", "P_pr", "vector_d", context__.to_vec(N));
        vector_d P_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            P_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(P_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable P_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew_pr;
            (void) Arew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Arew_pr = in__.vector_constrain(N,lp__);
            else
                Arew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun_pr;
            (void) Apun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Apun_pr = in__.vector_constrain(N,lp__);
            else
                Apun_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  R_pr;
            (void) R_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                R_pr = in__.vector_constrain(N,lp__);
            else
                R_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  P_pr;
            (void) P_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                P_pr = in__.vector_constrain(N,lp__);
            else
                P_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("Arew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, DUMMY_VAR__);
            stan::math::fill(Arew,DUMMY_VAR__);
            validate_non_negative_index("Apun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, DUMMY_VAR__);
            stan::math::fill(Apun,DUMMY_VAR__);
            validate_non_negative_index("R", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  R(static_cast<Eigen::VectorXd::Index>(N));
            (void) R;  // dummy to suppress unused var warning

            stan::math::initialize(R, DUMMY_VAR__);
            stan::math::fill(R,DUMMY_VAR__);
            validate_non_negative_index("P", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  P(static_cast<Eigen::VectorXd::Index>(N));
            (void) P;  // dummy to suppress unused var warning

            stan::math::initialize(P, DUMMY_VAR__);
            stan::math::fill(P,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                stan::math::assign(get_base1_lhs(R,i,"R",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(R_pr,i,"R_pr",1)))) * 30));
                stan::math::assign(get_base1_lhs(P,i,"P",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(P_pr,i,"P_pr",1)))) * 30));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Arew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Arew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Apun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Apun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(R(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: R" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(P(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: P" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            check_greater_or_equal(function__,"R",R,0);
            check_greater_or_equal(function__,"P",P,0);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(Arew_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(Apun_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(R_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(P_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("Qr", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  Qr(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qr;  // dummy to suppress unused var warning

                stan::math::initialize(Qr, DUMMY_VAR__);
                stan::math::fill(Qr,DUMMY_VAR__);
                validate_non_negative_index("Qp", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  Qp(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qp;  // dummy to suppress unused var warning

                stan::math::initialize(Qp, DUMMY_VAR__);
                stan::math::fill(Qp,DUMMY_VAR__);
                validate_non_negative_index("PEr_fic", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  PEr_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEr_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEr_fic, DUMMY_VAR__);
                stan::math::fill(PEr_fic,DUMMY_VAR__);
                validate_non_negative_index("PEp_fic", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  PEp_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEp_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEp_fic, DUMMY_VAR__);
                stan::math::fill(PEp_fic,DUMMY_VAR__);
                validate_non_negative_index("Qsum", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  Qsum(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qsum;  // dummy to suppress unused var warning

                stan::math::initialize(Qsum, DUMMY_VAR__);
                stan::math::fill(Qsum,DUMMY_VAR__);
                T__ Qr_chosen;
                (void) Qr_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qr_chosen, DUMMY_VAR__);
                stan::math::fill(Qr_chosen,DUMMY_VAR__);
                T__ Qp_chosen;
                (void) Qp_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qp_chosen, DUMMY_VAR__);
                stan::math::fill(Qp_chosen,DUMMY_VAR__);
                T__ PEr;
                (void) PEr;  // dummy to suppress unused var warning

                stan::math::initialize(PEr, DUMMY_VAR__);
                stan::math::fill(PEr,DUMMY_VAR__);
                T__ PEp;
                (void) PEp;  // dummy to suppress unused var warning

                stan::math::initialize(PEp, DUMMY_VAR__);
                stan::math::fill(PEp,DUMMY_VAR__);


                stan::math::assign(Qr, initV);
                stan::math::assign(Qp, initV);
                stan::math::assign(Qsum, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), Qsum));
                    stan::math::assign(PEr, ((get_base1(R,i,"R",1) * get_base1(get_base1(rew,i,"rew",1),t,"rew",2)) - get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1)));
                    stan::math::assign(PEp, ((get_base1(P,i,"P",1) * get_base1(get_base1(los,i,"los",1),t,"los",2)) - get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1)));
                    stan::math::assign(PEr_fic, minus(Qr));
                    stan::math::assign(PEp_fic, minus(Qp));
                    stan::math::assign(Qr_chosen, get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1));
                    stan::math::assign(Qp_chosen, get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1));
                    stan::math::assign(Qr, add(Qr,multiply(get_base1(Arew,i,"Arew",1),PEr_fic)));
                    stan::math::assign(Qp, add(Qp,multiply(get_base1(Apun,i,"Apun",1),PEp_fic)));
                    stan::math::assign(get_base1_lhs(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1), (Qr_chosen + (get_base1(Arew,i,"Arew",1) * PEr)));
                    stan::math::assign(get_base1_lhs(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1), (Qp_chosen + (get_base1(Apun,i,"Apun",1) * PEp)));
                    stan::math::assign(Qsum, add(Qr,Qp));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("Arew_pr");
        names__.push_back("Apun_pr");
        names__.push_back("R_pr");
        names__.push_back("P_pr");
        names__.push_back("Arew");
        names__.push_back("Apun");
        names__.push_back("R");
        names__.push_back("P");
        names__.push_back("mu_Arew");
        names__.push_back("mu_Apun");
        names__.push_back("mu_R");
        names__.push_back("mu_P");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_bandit4arm_4par_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d Arew_pr = in__.vector_constrain(N);
        vector_d Apun_pr = in__.vector_constrain(N);
        vector_d R_pr = in__.vector_constrain(N);
        vector_d P_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(R_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(P_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("Arew", "N", N);
            vector_d Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Arew,DUMMY_VAR__);
            validate_non_negative_index("Apun", "N", N);
            vector_d Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Apun,DUMMY_VAR__);
            validate_non_negative_index("R", "N", N);
            vector_d R(static_cast<Eigen::VectorXd::Index>(N));
            (void) R;  // dummy to suppress unused var warning

            stan::math::initialize(R, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(R,DUMMY_VAR__);
            validate_non_negative_index("P", "N", N);
            vector_d P(static_cast<Eigen::VectorXd::Index>(N));
            (void) P;  // dummy to suppress unused var warning

            stan::math::initialize(P, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(P,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                stan::math::assign(get_base1_lhs(R,i,"R",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(R_pr,i,"R_pr",1)))) * 30));
                stan::math::assign(get_base1_lhs(P,i,"P",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(P_pr,i,"P_pr",1)))) * 30));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            check_greater_or_equal(function__,"R",R,0);
            check_greater_or_equal(function__,"P",P,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(R[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(P[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_Arew(0.0);
            (void) mu_Arew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Arew,DUMMY_VAR__);
            double mu_Apun(0.0);
            (void) mu_Apun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Apun,DUMMY_VAR__);
            double mu_R(0.0);
            (void) mu_R;  // dummy to suppress unused var warning

            stan::math::initialize(mu_R, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_R,DUMMY_VAR__);
            double mu_P(0.0);
            (void) mu_P;  // dummy to suppress unused var warning

            stan::math::initialize(mu_P, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_P,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_Arew, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_Apun, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_R, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 30));
            stan::math::assign(mu_P, (Phi_approx(get_base1(mu_p,4,"mu_p",1)) * 30));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("Qr", "4", 4);
                vector_d Qr(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qr;  // dummy to suppress unused var warning

                stan::math::initialize(Qr, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qr,DUMMY_VAR__);
                validate_non_negative_index("Qp", "4", 4);
                vector_d Qp(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qp;  // dummy to suppress unused var warning

                stan::math::initialize(Qp, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qp,DUMMY_VAR__);
                validate_non_negative_index("PEr_fic", "4", 4);
                vector_d PEr_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEr_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEr_fic, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEr_fic,DUMMY_VAR__);
                validate_non_negative_index("PEp_fic", "4", 4);
                vector_d PEp_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEp_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEp_fic, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEp_fic,DUMMY_VAR__);
                validate_non_negative_index("Qsum", "4", 4);
                vector_d Qsum(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qsum;  // dummy to suppress unused var warning

                stan::math::initialize(Qsum, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qsum,DUMMY_VAR__);
                double Qr_chosen(0.0);
                (void) Qr_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qr_chosen, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qr_chosen,DUMMY_VAR__);
                double Qp_chosen(0.0);
                (void) Qp_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qp_chosen, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qp_chosen,DUMMY_VAR__);
                double PEr(0.0);
                (void) PEr;  // dummy to suppress unused var warning

                stan::math::initialize(PEr, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEr,DUMMY_VAR__);
                double PEp(0.0);
                (void) PEp;  // dummy to suppress unused var warning

                stan::math::initialize(PEp, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEp,DUMMY_VAR__);


                stan::math::assign(Qr, initV);
                stan::math::assign(Qp, initV);
                stan::math::assign(Qsum, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0.0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),Qsum)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(Qsum), base_rng__));
                    stan::math::assign(PEr, ((get_base1(R,i,"R",1) * get_base1(get_base1(rew,i,"rew",1),t,"rew",2)) - get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1)));
                    stan::math::assign(PEp, ((get_base1(P,i,"P",1) * get_base1(get_base1(los,i,"los",1),t,"los",2)) - get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1)));
                    stan::math::assign(PEr_fic, minus(Qr));
                    stan::math::assign(PEp_fic, minus(Qp));
                    stan::math::assign(Qr_chosen, get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1));
                    stan::math::assign(Qp_chosen, get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1));
                    stan::math::assign(Qr, add(Qr,multiply(get_base1(Arew,i,"Arew",1),PEr_fic)));
                    stan::math::assign(Qp, add(Qp,multiply(get_base1(Apun,i,"Apun",1),PEp_fic)));
                    stan::math::assign(get_base1_lhs(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1), (Qr_chosen + (get_base1(Arew,i,"Arew",1) * PEr)));
                    stan::math::assign(get_base1_lhs(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1), (Qp_chosen + (get_base1(Apun,i,"Apun",1) * PEp)));
                    stan::math::assign(Qsum, add(Qr,Qp));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_Arew",mu_Arew,0);
            check_less_or_equal(function__,"mu_Arew",mu_Arew,1);
            check_greater_or_equal(function__,"mu_Apun",mu_Apun,0);
            check_less_or_equal(function__,"mu_Apun",mu_Apun,1);
            check_greater_or_equal(function__,"mu_R",mu_R,0);
            check_greater_or_equal(function__,"mu_P",mu_P,0);

            // write generated quantities
        vars__.push_back(mu_Arew);
        vars__.push_back(mu_Apun);
        vars__.push_back(mu_R);
        vars__.push_back(mu_P);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_bandit4arm_4par";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_R";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_P";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_R";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_P";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_bandit4arm_lapse_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_bandit4arm_lapse");
    reader.add_event(179, 179, "end", "model_bandit4arm_lapse");
    return reader;
}

class model_bandit4arm_lapse : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > rew;
    vector<vector<double> > los;
    vector<vector<int> > choice;
    vector_d initV;
public:
    model_bandit4arm_lapse(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_bandit4arm_lapse(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_bandit4arm_lapse_namespace::model_bandit4arm_lapse";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("rew", "N", N);
            validate_non_negative_index("rew", "T", T);
            context__.validate_dims("data initialization", "rew", "double", context__.to_vec(N,T));
            validate_non_negative_index("rew", "N", N);
            validate_non_negative_index("rew", "T", T);
            rew = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("rew");
            pos__ = 0;
            size_t rew_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < rew_limit_1__; ++i_1__) {
                size_t rew_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < rew_limit_0__; ++i_0__) {
                    rew[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("los", "N", N);
            validate_non_negative_index("los", "T", T);
            context__.validate_dims("data initialization", "los", "double", context__.to_vec(N,T));
            validate_non_negative_index("los", "N", N);
            validate_non_negative_index("los", "T", T);
            los = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("los");
            pos__ = 0;
            size_t los_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < los_limit_1__; ++i_1__) {
                size_t los_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < los_limit_0__; ++i_0__) {
                    los[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "5", 5);
            num_params_r__ += 5;
            validate_non_negative_index("sigma", "5", 5);
            num_params_r__ += 5;
            validate_non_negative_index("Arew_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("Apun_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("R_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("P_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_bandit4arm_lapse() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "5", 5);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(5));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "5", 5);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(5));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("Arew_pr")))
            throw std::runtime_error("variable Arew_pr missing");
        vals_r__ = context__.vals_r("Arew_pr");
        pos__ = 0U;
        validate_non_negative_index("Arew_pr", "N", N);
        context__.validate_dims("initialization", "Arew_pr", "vector_d", context__.to_vec(N));
        vector_d Arew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Arew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Arew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Arew_pr: ") + e.what());
        }

        if (!(context__.contains_r("Apun_pr")))
            throw std::runtime_error("variable Apun_pr missing");
        vals_r__ = context__.vals_r("Apun_pr");
        pos__ = 0U;
        validate_non_negative_index("Apun_pr", "N", N);
        context__.validate_dims("initialization", "Apun_pr", "vector_d", context__.to_vec(N));
        vector_d Apun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Apun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Apun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Apun_pr: ") + e.what());
        }

        if (!(context__.contains_r("R_pr")))
            throw std::runtime_error("variable R_pr missing");
        vals_r__ = context__.vals_r("R_pr");
        pos__ = 0U;
        validate_non_negative_index("R_pr", "N", N);
        context__.validate_dims("initialization", "R_pr", "vector_d", context__.to_vec(N));
        vector_d R_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            R_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(R_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable R_pr: ") + e.what());
        }

        if (!(context__.contains_r("P_pr")))
            throw std::runtime_error("variable P_pr missing");
        vals_r__ = context__.vals_r("P_pr");
        pos__ = 0U;
        validate_non_negative_index("P_pr", "N", N);
        context__.validate_dims("initialization", "P_pr", "vector_d", context__.to_vec(N));
        vector_d P_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            P_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(P_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable P_pr: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(5,lp__);
            else
                mu_p = in__.vector_constrain(5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,5,lp__);
            else
                sigma = in__.vector_lb_constrain(0,5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew_pr;
            (void) Arew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Arew_pr = in__.vector_constrain(N,lp__);
            else
                Arew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun_pr;
            (void) Apun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Apun_pr = in__.vector_constrain(N,lp__);
            else
                Apun_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  R_pr;
            (void) R_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                R_pr = in__.vector_constrain(N,lp__);
            else
                R_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  P_pr;
            (void) P_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                P_pr = in__.vector_constrain(N,lp__);
            else
                P_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("Arew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, DUMMY_VAR__);
            stan::math::fill(Arew,DUMMY_VAR__);
            validate_non_negative_index("Apun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, DUMMY_VAR__);
            stan::math::fill(Apun,DUMMY_VAR__);
            validate_non_negative_index("R", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  R(static_cast<Eigen::VectorXd::Index>(N));
            (void) R;  // dummy to suppress unused var warning

            stan::math::initialize(R, DUMMY_VAR__);
            stan::math::fill(R,DUMMY_VAR__);
            validate_non_negative_index("P", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  P(static_cast<Eigen::VectorXd::Index>(N));
            (void) P;  // dummy to suppress unused var warning

            stan::math::initialize(P, DUMMY_VAR__);
            stan::math::fill(P,DUMMY_VAR__);
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                stan::math::assign(get_base1_lhs(R,i,"R",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(R_pr,i,"R_pr",1)))) * 30));
                stan::math::assign(get_base1_lhs(P,i,"P",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(P_pr,i,"P_pr",1)))) * 30));
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,5,"mu_p",1) + (get_base1(sigma,5,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Arew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Arew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Apun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Apun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(R(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: R" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(P(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: P" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            check_greater_or_equal(function__,"R",R,0);
            check_greater_or_equal(function__,"P",P,0);
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(Arew_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(Apun_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(R_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(P_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("Qr", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  Qr(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qr;  // dummy to suppress unused var warning

                stan::math::initialize(Qr, DUMMY_VAR__);
                stan::math::fill(Qr,DUMMY_VAR__);
                validate_non_negative_index("Qp", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  Qp(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qp;  // dummy to suppress unused var warning

                stan::math::initialize(Qp, DUMMY_VAR__);
                stan::math::fill(Qp,DUMMY_VAR__);
                validate_non_negative_index("PEr_fic", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  PEr_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEr_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEr_fic, DUMMY_VAR__);
                stan::math::fill(PEr_fic,DUMMY_VAR__);
                validate_non_negative_index("PEp_fic", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  PEp_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEp_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEp_fic, DUMMY_VAR__);
                stan::math::fill(PEp_fic,DUMMY_VAR__);
                validate_non_negative_index("Qsum", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  Qsum(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qsum;  // dummy to suppress unused var warning

                stan::math::initialize(Qsum, DUMMY_VAR__);
                stan::math::fill(Qsum,DUMMY_VAR__);
                T__ Qr_chosen;
                (void) Qr_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qr_chosen, DUMMY_VAR__);
                stan::math::fill(Qr_chosen,DUMMY_VAR__);
                T__ Qp_chosen;
                (void) Qp_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qp_chosen, DUMMY_VAR__);
                stan::math::fill(Qp_chosen,DUMMY_VAR__);
                T__ PEr;
                (void) PEr;  // dummy to suppress unused var warning

                stan::math::initialize(PEr, DUMMY_VAR__);
                stan::math::fill(PEr,DUMMY_VAR__);
                T__ PEp;
                (void) PEp;  // dummy to suppress unused var warning

                stan::math::initialize(PEp, DUMMY_VAR__);
                stan::math::fill(PEp,DUMMY_VAR__);


                stan::math::assign(Qr, initV);
                stan::math::assign(Qp, initV);
                stan::math::assign(Qsum, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    lp_accum__.add(categorical_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), add(multiply(softmax(Qsum),(1 - get_base1(xi,i,"xi",1))),(get_base1(xi,i,"xi",1) / 4))));
                    stan::math::assign(PEr, ((get_base1(R,i,"R",1) * get_base1(get_base1(rew,i,"rew",1),t,"rew",2)) - get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1)));
                    stan::math::assign(PEp, ((get_base1(P,i,"P",1) * get_base1(get_base1(los,i,"los",1),t,"los",2)) - get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1)));
                    stan::math::assign(PEr_fic, minus(Qr));
                    stan::math::assign(PEp_fic, minus(Qp));
                    stan::math::assign(Qr_chosen, get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1));
                    stan::math::assign(Qp_chosen, get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1));
                    stan::math::assign(Qr, add(Qr,multiply(get_base1(Arew,i,"Arew",1),PEr_fic)));
                    stan::math::assign(Qp, add(Qp,multiply(get_base1(Apun,i,"Apun",1),PEp_fic)));
                    stan::math::assign(get_base1_lhs(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1), (Qr_chosen + (get_base1(Arew,i,"Arew",1) * PEr)));
                    stan::math::assign(get_base1_lhs(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1), (Qp_chosen + (get_base1(Apun,i,"Apun",1) * PEp)));
                    stan::math::assign(Qsum, add(Qr,Qp));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("Arew_pr");
        names__.push_back("Apun_pr");
        names__.push_back("R_pr");
        names__.push_back("P_pr");
        names__.push_back("xi_pr");
        names__.push_back("Arew");
        names__.push_back("Apun");
        names__.push_back("R");
        names__.push_back("P");
        names__.push_back("xi");
        names__.push_back("mu_Arew");
        names__.push_back("mu_Apun");
        names__.push_back("mu_R");
        names__.push_back("mu_P");
        names__.push_back("mu_xi");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_bandit4arm_lapse_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(5);
        vector_d sigma = in__.vector_lb_constrain(0,5);
        vector_d Arew_pr = in__.vector_constrain(N);
        vector_d Apun_pr = in__.vector_constrain(N);
        vector_d R_pr = in__.vector_constrain(N);
        vector_d P_pr = in__.vector_constrain(N);
        vector_d xi_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(R_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(P_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("Arew", "N", N);
            vector_d Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Arew,DUMMY_VAR__);
            validate_non_negative_index("Apun", "N", N);
            vector_d Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Apun,DUMMY_VAR__);
            validate_non_negative_index("R", "N", N);
            vector_d R(static_cast<Eigen::VectorXd::Index>(N));
            (void) R;  // dummy to suppress unused var warning

            stan::math::initialize(R, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(R,DUMMY_VAR__);
            validate_non_negative_index("P", "N", N);
            vector_d P(static_cast<Eigen::VectorXd::Index>(N));
            (void) P;  // dummy to suppress unused var warning

            stan::math::initialize(P, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(P,DUMMY_VAR__);
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                stan::math::assign(get_base1_lhs(R,i,"R",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(R_pr,i,"R_pr",1)))) * 30));
                stan::math::assign(get_base1_lhs(P,i,"P",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(P_pr,i,"P_pr",1)))) * 30));
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,5,"mu_p",1) + (get_base1(sigma,5,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            check_greater_or_equal(function__,"R",R,0);
            check_greater_or_equal(function__,"P",P,0);
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(R[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(P[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_Arew(0.0);
            (void) mu_Arew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Arew,DUMMY_VAR__);
            double mu_Apun(0.0);
            (void) mu_Apun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Apun,DUMMY_VAR__);
            double mu_R(0.0);
            (void) mu_R;  // dummy to suppress unused var warning

            stan::math::initialize(mu_R, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_R,DUMMY_VAR__);
            double mu_P(0.0);
            (void) mu_P;  // dummy to suppress unused var warning

            stan::math::initialize(mu_P, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_P,DUMMY_VAR__);
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_Arew, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_Apun, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_R, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 30));
            stan::math::assign(mu_P, (Phi_approx(get_base1(mu_p,4,"mu_p",1)) * 30));
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,5,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("Qr", "4", 4);
                vector_d Qr(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qr;  // dummy to suppress unused var warning

                stan::math::initialize(Qr, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qr,DUMMY_VAR__);
                validate_non_negative_index("Qp", "4", 4);
                vector_d Qp(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qp;  // dummy to suppress unused var warning

                stan::math::initialize(Qp, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qp,DUMMY_VAR__);
                validate_non_negative_index("PEr_fic", "4", 4);
                vector_d PEr_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEr_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEr_fic, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEr_fic,DUMMY_VAR__);
                validate_non_negative_index("PEp_fic", "4", 4);
                vector_d PEp_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEp_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEp_fic, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEp_fic,DUMMY_VAR__);
                validate_non_negative_index("Qsum", "4", 4);
                vector_d Qsum(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qsum;  // dummy to suppress unused var warning

                stan::math::initialize(Qsum, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qsum,DUMMY_VAR__);
                double Qr_chosen(0.0);
                (void) Qr_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qr_chosen, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qr_chosen,DUMMY_VAR__);
                double Qp_chosen(0.0);
                (void) Qp_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qp_chosen, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qp_chosen,DUMMY_VAR__);
                double PEr(0.0);
                (void) PEr;  // dummy to suppress unused var warning

                stan::math::initialize(PEr, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEr,DUMMY_VAR__);
                double PEp(0.0);
                (void) PEp;  // dummy to suppress unused var warning

                stan::math::initialize(PEp, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEp,DUMMY_VAR__);


                stan::math::assign(Qr, initV);
                stan::math::assign(Qp, initV);
                stan::math::assign(Qsum, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0.0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),add(multiply(softmax(Qsum),(1 - get_base1(xi,i,"xi",1))),(get_base1(xi,i,"xi",1) / 4)))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(add(multiply(softmax(Qsum),(1 - get_base1(xi,i,"xi",1))),(get_base1(xi,i,"xi",1) / 4)), base_rng__));
                    stan::math::assign(PEr, ((get_base1(R,i,"R",1) * get_base1(get_base1(rew,i,"rew",1),t,"rew",2)) - get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1)));
                    stan::math::assign(PEp, ((get_base1(P,i,"P",1) * get_base1(get_base1(los,i,"los",1),t,"los",2)) - get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1)));
                    stan::math::assign(PEr_fic, minus(Qr));
                    stan::math::assign(PEp_fic, minus(Qp));
                    stan::math::assign(Qr_chosen, get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1));
                    stan::math::assign(Qp_chosen, get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1));
                    stan::math::assign(Qr, add(Qr,multiply(get_base1(Arew,i,"Arew",1),PEr_fic)));
                    stan::math::assign(Qp, add(Qp,multiply(get_base1(Apun,i,"Apun",1),PEp_fic)));
                    stan::math::assign(get_base1_lhs(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1), (Qr_chosen + (get_base1(Arew,i,"Arew",1) * PEr)));
                    stan::math::assign(get_base1_lhs(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1), (Qp_chosen + (get_base1(Apun,i,"Apun",1) * PEp)));
                    stan::math::assign(Qsum, add(Qr,Qp));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_Arew",mu_Arew,0);
            check_less_or_equal(function__,"mu_Arew",mu_Arew,1);
            check_greater_or_equal(function__,"mu_Apun",mu_Apun,0);
            check_less_or_equal(function__,"mu_Apun",mu_Apun,1);
            check_greater_or_equal(function__,"mu_R",mu_R,0);
            check_greater_or_equal(function__,"mu_P",mu_P,0);
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);

            // write generated quantities
        vars__.push_back(mu_Arew);
        vars__.push_back(mu_Apun);
        vars__.push_back(mu_R);
        vars__.push_back(mu_P);
        vars__.push_back(mu_xi);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_bandit4arm_lapse";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_R";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_P";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_R";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_P";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_bart_par4_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_bart_par4");
    reader.add_event(126, 126, "end", "model_bart_par4");
    return reader;
}

class model_bart_par4 : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    int P;
    vector<vector<int> > pumps;
    vector<vector<int> > explosion;
    vector<vector<vector<int> > > d;
public:
    model_bart_par4(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_bart_par4(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_bart_par4_namespace::model_bart_par4";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "P", "int", context__.to_vec());
            P = int(0);
            vals_i__ = context__.vals_i("P");
            pos__ = 0;
            P = vals_i__[pos__++];
            validate_non_negative_index("pumps", "N", N);
            validate_non_negative_index("pumps", "T", T);
            context__.validate_dims("data initialization", "pumps", "int", context__.to_vec(N,T));
            validate_non_negative_index("pumps", "N", N);
            validate_non_negative_index("pumps", "T", T);
            pumps = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pumps");
            pos__ = 0;
            size_t pumps_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pumps_limit_1__; ++i_1__) {
                size_t pumps_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pumps_limit_0__; ++i_0__) {
                    pumps[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("explosion", "N", N);
            validate_non_negative_index("explosion", "T", T);
            context__.validate_dims("data initialization", "explosion", "int", context__.to_vec(N,T));
            validate_non_negative_index("explosion", "N", N);
            validate_non_negative_index("explosion", "T", T);
            explosion = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("explosion");
            pos__ = 0;
            size_t explosion_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < explosion_limit_1__; ++i_1__) {
                size_t explosion_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < explosion_limit_0__; ++i_0__) {
                    explosion[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],0);
            }
            check_greater_or_equal(function__,"P",P,2);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pumps[k0__][k1__]",pumps[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"explosion[k0__][k1__]",explosion[k0__][k1__],0);
                    check_less_or_equal(function__,"explosion[k0__][k1__]",explosion[k0__][k1__],1);
                }
            }
            // initialize data variables
            validate_non_negative_index("d", "N", N);
            validate_non_negative_index("d", "T", T);
            validate_non_negative_index("d", "P", P);
            d = std::vector<std::vector<std::vector<int> > >(N,std::vector<std::vector<int> >(T,std::vector<int>(P,int(0))));
            stan::math::fill(d, std::numeric_limits<int>::min());

            for (int j = 1; j <= N; ++j) {

                for (int k = 1; k <= get_base1(Tsubj,j,"Tsubj",1); ++k) {

                    for (int l = 1; l <= P; ++l) {

                        if (as_bool(logical_lte(l,get_base1(get_base1(pumps,j,"pumps",1),k,"pumps",2)))) {
                            stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(d,j,"d",1),k,"d",2),l,"d",3), 1);
                        } else {
                            stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(d,j,"d",1),k,"d",2),l,"d",3), 0);
                        }
                    }
                }
            }

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("phi_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("eta_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("gam_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("tau_p", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_bart_par4() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("phi_p")))
            throw std::runtime_error("variable phi_p missing");
        vals_r__ = context__.vals_r("phi_p");
        pos__ = 0U;
        validate_non_negative_index("phi_p", "N", N);
        context__.validate_dims("initialization", "phi_p", "vector_d", context__.to_vec(N));
        vector_d phi_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            phi_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(phi_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable phi_p: ") + e.what());
        }

        if (!(context__.contains_r("eta_p")))
            throw std::runtime_error("variable eta_p missing");
        vals_r__ = context__.vals_r("eta_p");
        pos__ = 0U;
        validate_non_negative_index("eta_p", "N", N);
        context__.validate_dims("initialization", "eta_p", "vector_d", context__.to_vec(N));
        vector_d eta_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            eta_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(eta_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eta_p: ") + e.what());
        }

        if (!(context__.contains_r("gam_p")))
            throw std::runtime_error("variable gam_p missing");
        vals_r__ = context__.vals_r("gam_p");
        pos__ = 0U;
        validate_non_negative_index("gam_p", "N", N);
        context__.validate_dims("initialization", "gam_p", "vector_d", context__.to_vec(N));
        vector_d gam_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            gam_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(gam_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable gam_p: ") + e.what());
        }

        if (!(context__.contains_r("tau_p")))
            throw std::runtime_error("variable tau_p missing");
        vals_r__ = context__.vals_r("tau_p");
        pos__ = 0U;
        validate_non_negative_index("tau_p", "N", N);
        context__.validate_dims("initialization", "tau_p", "vector_d", context__.to_vec(N));
        vector_d tau_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_p: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  phi_p;
            (void) phi_p;  // dummy to suppress unused var warning
            if (jacobian__)
                phi_p = in__.vector_constrain(N,lp__);
            else
                phi_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_p;
            (void) eta_p;  // dummy to suppress unused var warning
            if (jacobian__)
                eta_p = in__.vector_constrain(N,lp__);
            else
                eta_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  gam_p;
            (void) gam_p;  // dummy to suppress unused var warning
            if (jacobian__)
                gam_p = in__.vector_constrain(N,lp__);
            else
                gam_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_p;
            (void) tau_p;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_p = in__.vector_constrain(N,lp__);
            else
                tau_p = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("phi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  phi(static_cast<Eigen::VectorXd::Index>(N));
            (void) phi;  // dummy to suppress unused var warning

            stan::math::initialize(phi, DUMMY_VAR__);
            stan::math::fill(phi,DUMMY_VAR__);
            validate_non_negative_index("eta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, DUMMY_VAR__);
            stan::math::fill(eta,DUMMY_VAR__);
            validate_non_negative_index("gam", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  gam(static_cast<Eigen::VectorXd::Index>(N));
            (void) gam;  // dummy to suppress unused var warning

            stan::math::initialize(gam, DUMMY_VAR__);
            stan::math::fill(gam,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            stan::math::assign(phi, Phi_approx(add(get_base1(mu_p,1,"mu_p",1),multiply(get_base1(sigma,1,"sigma",1),phi_p))));
            stan::math::assign(eta, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),eta_p))));
            stan::math::assign(gam, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),gam_p))));
            stan::math::assign(tau, exp(add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),tau_p))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(phi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: phi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(eta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: eta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(gam(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: gam" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"phi",phi,0);
            check_less_or_equal(function__,"phi",phi,1);
            check_greater_or_equal(function__,"eta",eta,0);
            check_greater_or_equal(function__,"gam",gam,0);
            check_greater_or_equal(function__,"tau",tau,0);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(phi_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(eta_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(gam_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(tau_p, 0, 1));
            for (int j = 1; j <= N; ++j) {
                {
                int n_succ(0);
                (void) n_succ;  // dummy to suppress unused var warning

                stan::math::fill(n_succ, std::numeric_limits<int>::min());
                stan::math::assign(n_succ,0);
                int n_pump(0);
                (void) n_pump;  // dummy to suppress unused var warning

                stan::math::fill(n_pump, std::numeric_limits<int>::min());
                stan::math::assign(n_pump,0);


                for (int k = 1; k <= get_base1(Tsubj,j,"Tsubj",1); ++k) {
                    {
                    T__ p_burst;
                    (void) p_burst;  // dummy to suppress unused var warning

                    stan::math::initialize(p_burst, DUMMY_VAR__);
                    stan::math::fill(p_burst,DUMMY_VAR__);
                    T__ omega;
                    (void) omega;  // dummy to suppress unused var warning

                    stan::math::initialize(omega, DUMMY_VAR__);
                    stan::math::fill(omega,DUMMY_VAR__);


                    stan::math::assign(p_burst, (1 - ((get_base1(phi,j,"phi",1) + (get_base1(eta,j,"eta",1) * n_succ)) / (1 + (get_base1(eta,j,"eta",1) * n_pump)))));
                    stan::math::assign(omega, (-(get_base1(gam,j,"gam",1)) / log1m(p_burst)));
                    for (int l = 1; l <= ((get_base1(get_base1(pumps,j,"pumps",1),k,"pumps",2) + 1) - get_base1(get_base1(explosion,j,"explosion",1),k,"explosion",2)); ++l) {
                        lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(get_base1(d,j,"d",1),k,"d",2),l,"d",3), (get_base1(tau,j,"tau",1) * (omega - l))));
                    }
                    stan::math::assign(n_succ, (n_succ + (get_base1(get_base1(pumps,j,"pumps",1),k,"pumps",2) - get_base1(get_base1(explosion,j,"explosion",1),k,"explosion",2))));
                    stan::math::assign(n_pump, (n_pump + get_base1(get_base1(pumps,j,"pumps",1),k,"pumps",2)));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("phi_p");
        names__.push_back("eta_p");
        names__.push_back("gam_p");
        names__.push_back("tau_p");
        names__.push_back("phi");
        names__.push_back("eta");
        names__.push_back("gam");
        names__.push_back("tau");
        names__.push_back("mu_phi");
        names__.push_back("mu_eta");
        names__.push_back("mu_gam");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dims__.push_back(P);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_bart_par4_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d phi_p = in__.vector_constrain(N);
        vector_d eta_p = in__.vector_constrain(N);
        vector_d gam_p = in__.vector_constrain(N);
        vector_d tau_p = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(phi_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(gam_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_p[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("phi", "N", N);
            vector_d phi(static_cast<Eigen::VectorXd::Index>(N));
            (void) phi;  // dummy to suppress unused var warning

            stan::math::initialize(phi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(phi,DUMMY_VAR__);
            validate_non_negative_index("eta", "N", N);
            vector_d eta(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eta,DUMMY_VAR__);
            validate_non_negative_index("gam", "N", N);
            vector_d gam(static_cast<Eigen::VectorXd::Index>(N));
            (void) gam;  // dummy to suppress unused var warning

            stan::math::initialize(gam, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(gam,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            stan::math::assign(phi, Phi_approx(add(get_base1(mu_p,1,"mu_p",1),multiply(get_base1(sigma,1,"sigma",1),phi_p))));
            stan::math::assign(eta, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),eta_p))));
            stan::math::assign(gam, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),gam_p))));
            stan::math::assign(tau, exp(add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),tau_p))));

            // validate transformed parameters
            check_greater_or_equal(function__,"phi",phi,0);
            check_less_or_equal(function__,"phi",phi,1);
            check_greater_or_equal(function__,"eta",eta,0);
            check_greater_or_equal(function__,"gam",gam,0);
            check_greater_or_equal(function__,"tau",tau,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(phi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(gam[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_phi(0.0);
            (void) mu_phi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_phi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_phi,DUMMY_VAR__);
            stan::math::assign(mu_phi,Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            double mu_eta(0.0);
            (void) mu_eta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_eta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_eta,DUMMY_VAR__);
            stan::math::assign(mu_eta,exp(get_base1(mu_p,2,"mu_p",1)));
            double mu_gam(0.0);
            (void) mu_gam;  // dummy to suppress unused var warning

            stan::math::initialize(mu_gam, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_gam,DUMMY_VAR__);
            stan::math::assign(mu_gam,exp(get_base1(mu_p,3,"mu_p",1)));
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            stan::math::assign(mu_tau,exp(get_base1(mu_p,4,"mu_p",1)));
            double log_lik(0.0);
            (void) log_lik;  // dummy to suppress unused var warning

            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            stan::math::assign(log_lik,0);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            validate_non_negative_index("y_pred", "P", P);
            vector<vector<vector<double> > > y_pred(N, (vector<vector<double> >(T, (vector<double>(P, 0.0)))));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int j = 1; j <= N; ++j) {
                for (int k = 1; k <= T; ++k) {
                    for (int l = 1; l <= P; ++l) {
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(y_pred,j,"y_pred",1),k,"y_pred",2),l,"y_pred",3), -(1));
                    }
                }
            }

            for (int j = 1; j <= N; ++j) {
                {
                int n_succ(0);
                (void) n_succ;  // dummy to suppress unused var warning

                stan::math::fill(n_succ, std::numeric_limits<int>::min());
                stan::math::assign(n_succ,0);
                int n_pump(0);
                (void) n_pump;  // dummy to suppress unused var warning

                stan::math::fill(n_pump, std::numeric_limits<int>::min());
                stan::math::assign(n_pump,0);


                for (int k = 1; k <= get_base1(Tsubj,j,"Tsubj",1); ++k) {
                    {
                    double p_burst(0.0);
                    (void) p_burst;  // dummy to suppress unused var warning

                    stan::math::initialize(p_burst, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(p_burst,DUMMY_VAR__);
                    double omega(0.0);
                    (void) omega;  // dummy to suppress unused var warning

                    stan::math::initialize(omega, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(omega,DUMMY_VAR__);


                    stan::math::assign(p_burst, (1 - ((get_base1(phi,j,"phi",1) + (get_base1(eta,j,"eta",1) * n_succ)) / (1 + (get_base1(eta,j,"eta",1) * n_pump)))));
                    stan::math::assign(omega, (-(get_base1(gam,j,"gam",1)) / log1m(p_burst)));
                    for (int l = 1; l <= ((get_base1(get_base1(pumps,j,"pumps",1),k,"pumps",2) + 1) - get_base1(get_base1(explosion,j,"explosion",1),k,"explosion",2)); ++l) {

                        stan::math::assign(log_lik, (log_lik + bernoulli_logit_log(get_base1(get_base1(get_base1(d,j,"d",1),k,"d",2),l,"d",3),(get_base1(tau,j,"tau",1) * (omega - l)))));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(y_pred,j,"y_pred",1),k,"y_pred",2),l,"y_pred",3), bernoulli_logit_rng((get_base1(tau,j,"tau",1) * (omega - l)), base_rng__));
                    }
                    stan::math::assign(n_succ, (n_succ + (get_base1(get_base1(pumps,j,"pumps",1),k,"pumps",2) - get_base1(get_base1(explosion,j,"explosion",1),k,"explosion",2))));
                    stan::math::assign(n_pump, (n_pump + get_base1(get_base1(pumps,j,"pumps",1),k,"pumps",2)));
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_phi",mu_phi,0);
            check_greater_or_equal(function__,"mu_eta",mu_eta,0);
            check_greater_or_equal(function__,"mu_gam",mu_gam,0);
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);

            // write generated quantities
        vars__.push_back(mu_phi);
        vars__.push_back(mu_eta);
        vars__.push_back(mu_gam);
        vars__.push_back(mu_tau);
        vars__.push_back(log_lik);
            for (int k_2__ = 0; k_2__ < P; ++k_2__) {
                for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(y_pred[k_0__][k_1__][k_2__]);
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_bart_par4";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gam_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gam" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_phi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_gam";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_2__ = 1; k_2__ <= P; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gam_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gam" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_phi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_gam";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_2__ = 1; k_2__ <= P; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_choiceRT_ddm_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_choiceRT_ddm");
    reader.add_event(95, 95, "end", "model_choiceRT_ddm");
    return reader;
}

class model_choiceRT_ddm : public prob_grad {
private:
    int N;
    int Nu_max;
    int Nl_max;
    vector<int> Nu;
    vector<int> Nl;
    vector<vector<double> > RTu;
    vector<vector<double> > RTl;
    vector<double> minRT;
    double RTbound;
public:
    model_choiceRT_ddm(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_choiceRT_ddm(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_choiceRT_ddm_namespace::model_choiceRT_ddm";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "Nu_max", "int", context__.to_vec());
            Nu_max = int(0);
            vals_i__ = context__.vals_i("Nu_max");
            pos__ = 0;
            Nu_max = vals_i__[pos__++];
            context__.validate_dims("data initialization", "Nl_max", "int", context__.to_vec());
            Nl_max = int(0);
            vals_i__ = context__.vals_i("Nl_max");
            pos__ = 0;
            Nl_max = vals_i__[pos__++];
            validate_non_negative_index("Nu", "N", N);
            context__.validate_dims("data initialization", "Nu", "int", context__.to_vec(N));
            validate_non_negative_index("Nu", "N", N);
            Nu = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Nu");
            pos__ = 0;
            size_t Nu_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Nu_limit_0__; ++i_0__) {
                Nu[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("Nl", "N", N);
            context__.validate_dims("data initialization", "Nl", "int", context__.to_vec(N));
            validate_non_negative_index("Nl", "N", N);
            Nl = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Nl");
            pos__ = 0;
            size_t Nl_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Nl_limit_0__; ++i_0__) {
                Nl[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("RTu", "N", N);
            validate_non_negative_index("RTu", "Nu_max", Nu_max);
            context__.validate_dims("data initialization", "RTu", "double", context__.to_vec(N,Nu_max));
            validate_non_negative_index("RTu", "N", N);
            validate_non_negative_index("RTu", "Nu_max", Nu_max);
            RTu = std::vector<std::vector<double> >(N,std::vector<double>(Nu_max,double(0)));
            vals_r__ = context__.vals_r("RTu");
            pos__ = 0;
            size_t RTu_limit_1__ = Nu_max;
            for (size_t i_1__ = 0; i_1__ < RTu_limit_1__; ++i_1__) {
                size_t RTu_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < RTu_limit_0__; ++i_0__) {
                    RTu[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("RTl", "N", N);
            validate_non_negative_index("RTl", "Nl_max", Nl_max);
            context__.validate_dims("data initialization", "RTl", "double", context__.to_vec(N,Nl_max));
            validate_non_negative_index("RTl", "N", N);
            validate_non_negative_index("RTl", "Nl_max", Nl_max);
            RTl = std::vector<std::vector<double> >(N,std::vector<double>(Nl_max,double(0)));
            vals_r__ = context__.vals_r("RTl");
            pos__ = 0;
            size_t RTl_limit_1__ = Nl_max;
            for (size_t i_1__ = 0; i_1__ < RTl_limit_1__; ++i_1__) {
                size_t RTl_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < RTl_limit_0__; ++i_0__) {
                    RTl[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("minRT", "N", N);
            context__.validate_dims("data initialization", "minRT", "double", context__.to_vec(N));
            validate_non_negative_index("minRT", "N", N);
            minRT = std::vector<double>(N,double(0));
            vals_r__ = context__.vals_r("minRT");
            pos__ = 0;
            size_t minRT_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < minRT_limit_0__; ++i_0__) {
                minRT[i_0__] = vals_r__[pos__++];
            }
            context__.validate_dims("data initialization", "RTbound", "double", context__.to_vec());
            RTbound = double(0);
            vals_r__ = context__.vals_r("RTbound");
            pos__ = 0;
            RTbound = vals_r__[pos__++];

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"Nu_max",Nu_max,0);
            check_greater_or_equal(function__,"Nl_max",Nl_max,0);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Nu[k0__]",Nu[k0__],0);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Nl[k0__]",Nl[k0__],0);
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("delta_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("tau_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_choiceRT_ddm() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        if (!(context__.contains_r("delta_pr")))
            throw std::runtime_error("variable delta_pr missing");
        vals_r__ = context__.vals_r("delta_pr");
        pos__ = 0U;
        validate_non_negative_index("delta_pr", "N", N);
        context__.validate_dims("initialization", "delta_pr", "vector_d", context__.to_vec(N));
        vector_d delta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            delta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(delta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable delta_pr: ") + e.what());
        }

        if (!(context__.contains_r("tau_pr")))
            throw std::runtime_error("variable tau_pr missing");
        vals_r__ = context__.vals_r("tau_pr");
        pos__ = 0U;
        validate_non_negative_index("tau_pr", "N", N);
        context__.validate_dims("initialization", "tau_pr", "vector_d", context__.to_vec(N));
        vector_d tau_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  delta_pr;
            (void) delta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                delta_pr = in__.vector_constrain(N,lp__);
            else
                delta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_pr;
            (void) tau_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_pr = in__.vector_constrain(N,lp__);
            else
                tau_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);
            validate_non_negative_index("delta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  delta(static_cast<Eigen::VectorXd::Index>(N));
            (void) delta;  // dummy to suppress unused var warning

            stan::math::initialize(delta, DUMMY_VAR__);
            stan::math::fill(delta,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(beta,i,"beta",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))));
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), ((Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * (get_base1(minRT,i,"minRT",1) - RTbound)) + RTbound));
            }
            stan::math::assign(alpha, exp(add(get_base1(mu_p,1,"mu_p",1),multiply(get_base1(sigma,1,"sigma",1),alpha_pr))));
            stan::math::assign(delta, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),delta_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(delta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: delta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,1);
            check_greater_or_equal(function__,"delta",delta,0);
            check_greater_or_equal(function__,"tau",tau,RTbound);
            check_less_or_equal(function__,"tau",tau,max(minRT));

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(delta_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(tau_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {

                lp_accum__.add(wiener_log<propto__>(stan::model::rvalue(RTu, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_max(get_base1(Nu,i,"Nu",1)), stan::model::nil_index_list())), "RTu"), get_base1(alpha,i,"alpha",1), get_base1(tau,i,"tau",1), get_base1(beta,i,"beta",1), get_base1(delta,i,"delta",1)));
                lp_accum__.add(wiener_log<propto__>(stan::model::rvalue(RTl, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_max(get_base1(Nl,i,"Nl",1)), stan::model::nil_index_list())), "RTl"), get_base1(alpha,i,"alpha",1), get_base1(tau,i,"tau",1), (1 - get_base1(beta,i,"beta",1)), -(get_base1(delta,i,"delta",1))));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("alpha_pr");
        names__.push_back("beta_pr");
        names__.push_back("delta_pr");
        names__.push_back("tau_pr");
        names__.push_back("alpha");
        names__.push_back("beta");
        names__.push_back("delta");
        names__.push_back("tau");
        names__.push_back("mu_alpha");
        names__.push_back("mu_beta");
        names__.push_back("mu_delta");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_choiceRT_ddm_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
        vector_d delta_pr = in__.vector_constrain(N);
        vector_d tau_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(delta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);
            validate_non_negative_index("delta", "N", N);
            vector_d delta(static_cast<Eigen::VectorXd::Index>(N));
            (void) delta;  // dummy to suppress unused var warning

            stan::math::initialize(delta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(delta,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(beta,i,"beta",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))));
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), ((Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * (get_base1(minRT,i,"minRT",1) - RTbound)) + RTbound));
            }
            stan::math::assign(alpha, exp(add(get_base1(mu_p,1,"mu_p",1),multiply(get_base1(sigma,1,"sigma",1),alpha_pr))));
            stan::math::assign(delta, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),delta_pr))));

            // validate transformed parameters
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,1);
            check_greater_or_equal(function__,"delta",delta,0);
            check_greater_or_equal(function__,"tau",tau,RTbound);
            check_less_or_equal(function__,"tau",tau,max(minRT));

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(delta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            double mu_delta(0.0);
            (void) mu_delta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_delta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_delta,DUMMY_VAR__);
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);


            stan::math::assign(mu_alpha, exp(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_beta, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_delta, exp(get_base1(mu_p,3,"mu_p",1)));
            stan::math::assign(mu_tau, ((Phi_approx(get_base1(mu_p,4,"mu_p",1)) * (mean(minRT) - RTbound)) + RTbound));

            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), wiener_log(stan::model::rvalue(RTu, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_max(get_base1(Nu,i,"Nu",1)), stan::model::nil_index_list())), "RTu"),get_base1(alpha,i,"alpha",1),get_base1(tau,i,"tau",1),get_base1(beta,i,"beta",1),get_base1(delta,i,"delta",1)));
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + wiener_log(stan::model::rvalue(RTl, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_max(get_base1(Nl,i,"Nl",1)), stan::model::nil_index_list())), "RTl"),get_base1(alpha,i,"alpha",1),get_base1(tau,i,"tau",1),(1 - get_base1(beta,i,"beta",1)),-(get_base1(delta,i,"delta",1)))));
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,1);
            check_greater_or_equal(function__,"mu_delta",mu_delta,0);
            check_greater_or_equal(function__,"mu_tau",mu_tau,RTbound);
            check_less_or_equal(function__,"mu_tau",mu_tau,max(minRT));

            // write generated quantities
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_beta);
        vars__.push_back(mu_delta);
        vars__.push_back(mu_tau);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_choiceRT_ddm";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "delta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "delta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_delta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "delta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "delta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_delta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_choiceRT_ddm_single_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_choiceRT_ddm_single");
    reader.add_event(55, 55, "end", "model_choiceRT_ddm_single");
    return reader;
}

class model_choiceRT_ddm_single : public prob_grad {
private:
    int Nu;
    int Nl;
    vector<double> RTu;
    vector<double> RTl;
    double minRT;
    double RTbound;
public:
    model_choiceRT_ddm_single(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_choiceRT_ddm_single(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_choiceRT_ddm_single_namespace::model_choiceRT_ddm_single";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "Nu", "int", context__.to_vec());
            Nu = int(0);
            vals_i__ = context__.vals_i("Nu");
            pos__ = 0;
            Nu = vals_i__[pos__++];
            context__.validate_dims("data initialization", "Nl", "int", context__.to_vec());
            Nl = int(0);
            vals_i__ = context__.vals_i("Nl");
            pos__ = 0;
            Nl = vals_i__[pos__++];
            validate_non_negative_index("RTu", "Nu", Nu);
            context__.validate_dims("data initialization", "RTu", "double", context__.to_vec(Nu));
            validate_non_negative_index("RTu", "Nu", Nu);
            RTu = std::vector<double>(Nu,double(0));
            vals_r__ = context__.vals_r("RTu");
            pos__ = 0;
            size_t RTu_limit_0__ = Nu;
            for (size_t i_0__ = 0; i_0__ < RTu_limit_0__; ++i_0__) {
                RTu[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("RTl", "Nl", Nl);
            context__.validate_dims("data initialization", "RTl", "double", context__.to_vec(Nl));
            validate_non_negative_index("RTl", "Nl", Nl);
            RTl = std::vector<double>(Nl,double(0));
            vals_r__ = context__.vals_r("RTl");
            pos__ = 0;
            size_t RTl_limit_0__ = Nl;
            for (size_t i_0__ = 0; i_0__ < RTl_limit_0__; ++i_0__) {
                RTl[i_0__] = vals_r__[pos__++];
            }
            context__.validate_dims("data initialization", "minRT", "double", context__.to_vec());
            minRT = double(0);
            vals_r__ = context__.vals_r("minRT");
            pos__ = 0;
            minRT = vals_r__[pos__++];
            context__.validate_dims("data initialization", "RTbound", "double", context__.to_vec());
            RTbound = double(0);
            vals_r__ = context__.vals_r("RTbound");
            pos__ = 0;
            RTbound = vals_r__[pos__++];

            // validate, data variables
            check_greater_or_equal(function__,"Nu",Nu,0);
            check_greater_or_equal(function__,"Nl",Nl,0);
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_choiceRT_ddm_single() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("alpha")))
            throw std::runtime_error("variable alpha missing");
        vals_r__ = context__.vals_r("alpha");
        pos__ = 0U;
        context__.validate_dims("initialization", "alpha", "double", context__.to_vec());
        double alpha(0);
        alpha = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,alpha);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha: ") + e.what());
        }

        if (!(context__.contains_r("beta")))
            throw std::runtime_error("variable beta missing");
        vals_r__ = context__.vals_r("beta");
        pos__ = 0U;
        context__.validate_dims("initialization", "beta", "double", context__.to_vec());
        double beta(0);
        beta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,beta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta: ") + e.what());
        }

        if (!(context__.contains_r("delta")))
            throw std::runtime_error("variable delta missing");
        vals_r__ = context__.vals_r("delta");
        pos__ = 0U;
        context__.validate_dims("initialization", "delta", "double", context__.to_vec());
        double delta(0);
        delta = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,delta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable delta: ") + e.what());
        }

        if (!(context__.contains_r("tau")))
            throw std::runtime_error("variable tau missing");
        vals_r__ = context__.vals_r("tau");
        pos__ = 0U;
        context__.validate_dims("initialization", "tau", "double", context__.to_vec());
        double tau(0);
        tau = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(RTbound,minRT,tau);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ alpha;
            (void) alpha;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha = in__.scalar_lb_constrain(0,lp__);
            else
                alpha = in__.scalar_lb_constrain(0);

            T__ beta;
            (void) beta;  // dummy to suppress unused var warning
            if (jacobian__)
                beta = in__.scalar_lub_constrain(0,1,lp__);
            else
                beta = in__.scalar_lub_constrain(0,1);

            T__ delta;
            (void) delta;  // dummy to suppress unused var warning
            if (jacobian__)
                delta = in__.scalar_lb_constrain(0,lp__);
            else
                delta = in__.scalar_lb_constrain(0);

            T__ tau;
            (void) tau;  // dummy to suppress unused var warning
            if (jacobian__)
                tau = in__.scalar_lub_constrain(RTbound,minRT,lp__);
            else
                tau = in__.scalar_lub_constrain(RTbound,minRT);


            // transformed parameters



            // validate transformed parameters

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            // model body

            lp_accum__.add(uniform_log<propto__>(alpha, 0, 5));
            lp_accum__.add(uniform_log<propto__>(beta, 0, 1));
            lp_accum__.add(normal_log<propto__>(delta, 0, 2));
            lp_accum__.add(uniform_log<propto__>(tau, 0.10000000000000001, minRT));
            lp_accum__.add(wiener_log<propto__>(RTu, alpha, tau, beta, delta));
            lp_accum__.add(wiener_log<propto__>(RTl, alpha, tau, (1 - beta), -(delta)));

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("alpha");
        names__.push_back("beta");
        names__.push_back("delta");
        names__.push_back("tau");
        names__.push_back("log_lik");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_choiceRT_ddm_single_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double alpha = in__.scalar_lb_constrain(0);
        double beta = in__.scalar_lub_constrain(0,1);
        double delta = in__.scalar_lb_constrain(0);
        double tau = in__.scalar_lub_constrain(RTbound,minRT);
        vars__.push_back(alpha);
        vars__.push_back(beta);
        vars__.push_back(delta);
        vars__.push_back(tau);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {



            // validate transformed parameters

            // write transformed parameters

            if (!include_gqs__) return;
            // declare and define generated quantities
            double log_lik(0.0);
            (void) log_lik;  // dummy to suppress unused var warning

            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);



            stan::math::assign(log_lik, wiener_log(RTu,alpha,tau,beta,delta));
            stan::math::assign(log_lik, (log_lik + wiener_log(RTl,alpha,tau,(1 - beta),-(delta))));

            // validate generated quantities

            // write generated quantities
        vars__.push_back(log_lik);

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_choiceRT_ddm_single";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "delta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "delta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_choiceRT_lba_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_choiceRT_lba");
    reader.add_event(271, 271, "end", "model_choiceRT_lba");
    return reader;
}

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
lba_pdf(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v_pdf,
            const T4__& s, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        fun_scalar_t__ b_A_tv_ts;
        (void) b_A_tv_ts;  // dummy to suppress unused var warning

        stan::math::initialize(b_A_tv_ts, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_A_tv_ts,DUMMY_VAR__);
        fun_scalar_t__ b_tv_ts;
        (void) b_tv_ts;  // dummy to suppress unused var warning

        stan::math::initialize(b_tv_ts, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_tv_ts,DUMMY_VAR__);
        fun_scalar_t__ term_1b;
        (void) term_1b;  // dummy to suppress unused var warning

        stan::math::initialize(term_1b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_1b,DUMMY_VAR__);
        fun_scalar_t__ term_2b;
        (void) term_2b;  // dummy to suppress unused var warning

        stan::math::initialize(term_2b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_2b,DUMMY_VAR__);
        fun_scalar_t__ term_3b;
        (void) term_3b;  // dummy to suppress unused var warning

        stan::math::initialize(term_3b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_3b,DUMMY_VAR__);
        fun_scalar_t__ term_4b;
        (void) term_4b;  // dummy to suppress unused var warning

        stan::math::initialize(term_4b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_4b,DUMMY_VAR__);
        fun_scalar_t__ pdf;
        (void) pdf;  // dummy to suppress unused var warning

        stan::math::initialize(pdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(pdf,DUMMY_VAR__);


        stan::math::assign(b_A_tv_ts, (((b - A) - (t * v_pdf)) / (t * s)));
        stan::math::assign(b_tv_ts, ((b - (t * v_pdf)) / (t * s)));
        stan::math::assign(term_1b, (v_pdf * Phi(b_A_tv_ts)));
        stan::math::assign(term_2b, (s * exp(normal_log(fabs(b_A_tv_ts),0,1))));
        stan::math::assign(term_3b, (v_pdf * Phi(b_tv_ts)));
        stan::math::assign(term_4b, (s * exp(normal_log(fabs(b_tv_ts),0,1))));
        stan::math::assign(pdf, ((1 / A) * (((-(term_1b) + term_2b) + term_3b) - term_4b)));
        return stan::math::promote_scalar<fun_return_scalar_t__>(pdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lba_pdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v_pdf,
            const T4__& s, std::ostream* pstream__) const {
        return lba_pdf(t, b, A, v_pdf, s, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
lba_cdf(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v_cdf,
            const T4__& s, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        fun_scalar_t__ b_A_tv;
        (void) b_A_tv;  // dummy to suppress unused var warning

        stan::math::initialize(b_A_tv, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_A_tv,DUMMY_VAR__);
        fun_scalar_t__ b_tv;
        (void) b_tv;  // dummy to suppress unused var warning

        stan::math::initialize(b_tv, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_tv,DUMMY_VAR__);
        fun_scalar_t__ ts;
        (void) ts;  // dummy to suppress unused var warning

        stan::math::initialize(ts, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(ts,DUMMY_VAR__);
        fun_scalar_t__ term_1a;
        (void) term_1a;  // dummy to suppress unused var warning

        stan::math::initialize(term_1a, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_1a,DUMMY_VAR__);
        fun_scalar_t__ term_2a;
        (void) term_2a;  // dummy to suppress unused var warning

        stan::math::initialize(term_2a, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_2a,DUMMY_VAR__);
        fun_scalar_t__ term_3a;
        (void) term_3a;  // dummy to suppress unused var warning

        stan::math::initialize(term_3a, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_3a,DUMMY_VAR__);
        fun_scalar_t__ term_4a;
        (void) term_4a;  // dummy to suppress unused var warning

        stan::math::initialize(term_4a, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_4a,DUMMY_VAR__);
        fun_scalar_t__ cdf;
        (void) cdf;  // dummy to suppress unused var warning

        stan::math::initialize(cdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(cdf,DUMMY_VAR__);


        stan::math::assign(b_A_tv, ((b - A) - (t * v_cdf)));
        stan::math::assign(b_tv, (b - (t * v_cdf)));
        stan::math::assign(ts, (t * s));
        stan::math::assign(term_1a, ((b_A_tv / A) * Phi((b_A_tv / ts))));
        stan::math::assign(term_2a, ((b_tv / A) * Phi((b_tv / ts))));
        stan::math::assign(term_3a, ((ts / A) * exp(normal_log(fabs((b_A_tv / ts)),0,1))));
        stan::math::assign(term_4a, ((ts / A) * exp(normal_log(fabs((b_tv / ts)),0,1))));
        stan::math::assign(cdf, ((((1 + term_1a) - term_2a) + term_3a) - term_4a));
        return stan::math::promote_scalar<fun_return_scalar_t__>(cdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lba_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v_cdf,
            const T4__& s, std::ostream* pstream__) const {
        return lba_cdf(t, b, A, v_cdf, s, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
lba_lpdf(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& RT,
             const T1__& d,
             const T2__& A,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
             const T4__& s,
             const T5__& tau, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        fun_scalar_t__ t;
        (void) t;  // dummy to suppress unused var warning

        stan::math::initialize(t, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(t,DUMMY_VAR__);
        fun_scalar_t__ b;
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b,DUMMY_VAR__);
        fun_scalar_t__ cdf;
        (void) cdf;  // dummy to suppress unused var warning

        stan::math::initialize(cdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(cdf,DUMMY_VAR__);
        fun_scalar_t__ pdf;
        (void) pdf;  // dummy to suppress unused var warning

        stan::math::initialize(pdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(pdf,DUMMY_VAR__);
        validate_non_negative_index("prob", "cols(RT)", cols(RT));
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  prob(static_cast<Eigen::VectorXd::Index>(cols(RT)));
        (void) prob;  // dummy to suppress unused var warning

        stan::math::initialize(prob, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(prob,DUMMY_VAR__);
        fun_scalar_t__ out;
        (void) out;  // dummy to suppress unused var warning

        stan::math::initialize(out, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(out,DUMMY_VAR__);
        fun_scalar_t__ prob_neg;
        (void) prob_neg;  // dummy to suppress unused var warning

        stan::math::initialize(prob_neg, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(prob_neg,DUMMY_VAR__);


        stan::math::assign(b, (A + d));
        for (int i = 1; i <= cols(RT); ++i) {

            stan::math::assign(t, (get_base1(RT,1,i,"RT",1) - tau));
            if (as_bool(logical_gt(t,0))) {

                stan::math::assign(cdf, 1);
                for (int j = 1; j <= num_elements(v); ++j) {

                    if (as_bool(logical_eq(get_base1(RT,2,i,"RT",1),j))) {

                        stan::math::assign(pdf, lba_pdf(t,b,A,get_base1(v,j,"v",1),s, pstream__));
                    } else {

                        stan::math::assign(cdf, (lba_cdf(t,b,A,get_base1(v,j,"v",1),s, pstream__) * cdf));
                    }
                }
                stan::math::assign(prob_neg, 1);
                for (int j = 1; j <= num_elements(v); ++j) {

                    stan::math::assign(prob_neg, (Phi((-(get_base1(v,j,"v",1)) / s)) * prob_neg));
                }
                stan::math::assign(get_base1_lhs(prob,i,"prob",1), (pdf * (1 - cdf)));
                stan::math::assign(get_base1_lhs(prob,i,"prob",1), (get_base1(prob,i,"prob",1) / (1 - prob_neg)));
                if (as_bool(logical_lt(get_base1(prob,i,"prob",1),1e-10))) {

                    stan::math::assign(get_base1_lhs(prob,i,"prob",1), 1e-10);
                }
            } else {

                stan::math::assign(get_base1_lhs(prob,i,"prob",1), 1e-10);
            }
        }
        stan::math::assign(out, sum(log(prob)));
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
lba_lpdf(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& RT,
             const T1__& d,
             const T2__& A,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
             const T4__& s,
             const T5__& tau, std::ostream* pstream__) {
    return lba_lpdf<false>(RT,d,A,v,s,tau, pstream__);
}


struct lba_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& RT,
             const T1__& d,
             const T2__& A,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
             const T4__& s,
             const T5__& tau, std::ostream* pstream__) const {
        return lba_lpdf(RT, d, A, v, s, tau, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1>
lba_rng(const T0__& d,
            const T1__& A,
            const Eigen::Matrix<T2__, Eigen::Dynamic,1>& v,
            const T3__& s,
            const T4__& tau, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        int get_pos_drift(0);
        (void) get_pos_drift;  // dummy to suppress unused var warning

        stan::math::fill(get_pos_drift, std::numeric_limits<int>::min());
        int no_pos_drift(0);
        (void) no_pos_drift;  // dummy to suppress unused var warning

        stan::math::fill(no_pos_drift, std::numeric_limits<int>::min());
        int get_first_pos(0);
        (void) get_first_pos;  // dummy to suppress unused var warning

        stan::math::fill(get_first_pos, std::numeric_limits<int>::min());
        validate_non_negative_index("drift", "num_elements(v)", num_elements(v));
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  drift(static_cast<Eigen::VectorXd::Index>(num_elements(v)));
        (void) drift;  // dummy to suppress unused var warning

        stan::math::initialize(drift, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(drift,DUMMY_VAR__);
        int max_iter(0);
        (void) max_iter;  // dummy to suppress unused var warning

        stan::math::fill(max_iter, std::numeric_limits<int>::min());
        int iter(0);
        (void) iter;  // dummy to suppress unused var warning

        stan::math::fill(iter, std::numeric_limits<int>::min());
        validate_non_negative_index("start", "num_elements(v)", num_elements(v));
        vector<fun_scalar_t__> start(num_elements(v));
        stan::math::initialize(start, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(start,DUMMY_VAR__);
        validate_non_negative_index("ttf", "num_elements(v)", num_elements(v));
        vector<fun_scalar_t__> ttf(num_elements(v));
        stan::math::initialize(ttf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(ttf,DUMMY_VAR__);
        validate_non_negative_index("resp", "num_elements(v)", num_elements(v));
        vector<int> resp(num_elements(v), 0);
        stan::math::fill(resp, std::numeric_limits<int>::min());
        fun_scalar_t__ rt;
        (void) rt;  // dummy to suppress unused var warning

        stan::math::initialize(rt, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(rt,DUMMY_VAR__);
        validate_non_negative_index("pred", "2", 2);
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  pred(static_cast<Eigen::VectorXd::Index>(2));
        (void) pred;  // dummy to suppress unused var warning

        stan::math::initialize(pred, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(pred,DUMMY_VAR__);
        fun_scalar_t__ b;
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b,DUMMY_VAR__);


        stan::math::assign(get_pos_drift, 1);
        stan::math::assign(no_pos_drift, 0);
        stan::math::assign(max_iter, 1000);
        stan::math::assign(iter, 0);
        while (as_bool(get_pos_drift)) {

            for (int j = 1; j <= num_elements(v); ++j) {

                stan::math::assign(get_base1_lhs(drift,j,"drift",1), normal_rng(get_base1(v,j,"v",1),s, base_rng__));
                if (as_bool(logical_gt(get_base1(drift,j,"drift",1),0))) {

                    stan::math::assign(get_pos_drift, 0);
                }
            }
            stan::math::assign(iter, (iter + 1));
            if (as_bool(logical_gt(iter,max_iter))) {

                stan::math::assign(get_pos_drift, 0);
                stan::math::assign(no_pos_drift, 1);
            }
        }
        if (as_bool(no_pos_drift)) {

            stan::math::assign(get_base1_lhs(pred,1,"pred",1), -(1));
            stan::math::assign(get_base1_lhs(pred,2,"pred",1), -(1));
        } else {

            stan::math::assign(b, (A + d));
            for (int i = 1; i <= num_elements(v); ++i) {

                stan::math::assign(get_base1_lhs(start,i,"start",1), uniform_rng(0,A, base_rng__));
                stan::math::assign(get_base1_lhs(ttf,i,"ttf",1), ((b - get_base1(start,i,"start",1)) / get_base1(drift,i,"drift",1)));
            }
            stan::math::assign(resp, sort_indices_asc(ttf));
            stan::math::assign(ttf, sort_asc(ttf));
            stan::math::assign(get_first_pos, 1);
            stan::math::assign(iter, 1);
            while (as_bool(get_first_pos)) {

                if (as_bool(logical_gt(get_base1(ttf,iter,"ttf",1),0))) {

                    stan::math::assign(get_base1_lhs(pred,1,"pred",1), get_base1(ttf,iter,"ttf",1));
                    stan::math::assign(get_base1_lhs(pred,2,"pred",1), get_base1(resp,iter,"resp",1));
                    stan::math::assign(get_first_pos, 0);
                }
                stan::math::assign(iter, (iter + 1));
            }
        }
        return stan::math::promote_scalar<fun_return_scalar_t__>(pred);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lba_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1>
    operator()(const T0__& d,
            const T1__& A,
            const Eigen::Matrix<T2__, Eigen::Dynamic,1>& v,
            const T3__& s,
            const T4__& tau, RNG& base_rng__, std::ostream* pstream__) const {
        return lba_rng(d, A, v, s, tau, base_rng__, pstream__);
    }
};

class model_choiceRT_lba : public prob_grad {
private:
    int N;
    int Max_tr;
    int N_choices;
    int N_cond;
    vector<vector<int> > N_tr_cond;
    vector<vector<matrix_d> > RT;
public:
    model_choiceRT_lba(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_choiceRT_lba(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_choiceRT_lba_namespace::model_choiceRT_lba";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "Max_tr", "int", context__.to_vec());
            Max_tr = int(0);
            vals_i__ = context__.vals_i("Max_tr");
            pos__ = 0;
            Max_tr = vals_i__[pos__++];
            context__.validate_dims("data initialization", "N_choices", "int", context__.to_vec());
            N_choices = int(0);
            vals_i__ = context__.vals_i("N_choices");
            pos__ = 0;
            N_choices = vals_i__[pos__++];
            context__.validate_dims("data initialization", "N_cond", "int", context__.to_vec());
            N_cond = int(0);
            vals_i__ = context__.vals_i("N_cond");
            pos__ = 0;
            N_cond = vals_i__[pos__++];
            validate_non_negative_index("N_tr_cond", "N", N);
            validate_non_negative_index("N_tr_cond", "N_cond", N_cond);
            context__.validate_dims("data initialization", "N_tr_cond", "int", context__.to_vec(N,N_cond));
            validate_non_negative_index("N_tr_cond", "N", N);
            validate_non_negative_index("N_tr_cond", "N_cond", N_cond);
            N_tr_cond = std::vector<std::vector<int> >(N,std::vector<int>(N_cond,int(0)));
            vals_i__ = context__.vals_i("N_tr_cond");
            pos__ = 0;
            size_t N_tr_cond_limit_1__ = N_cond;
            for (size_t i_1__ = 0; i_1__ < N_tr_cond_limit_1__; ++i_1__) {
                size_t N_tr_cond_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < N_tr_cond_limit_0__; ++i_0__) {
                    N_tr_cond[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("RT", "N", N);
            validate_non_negative_index("RT", "N_cond", N_cond);
            validate_non_negative_index("RT", "2", 2);
            validate_non_negative_index("RT", "Max_tr", Max_tr);
            context__.validate_dims("data initialization", "RT", "matrix_d", context__.to_vec(N,N_cond,2,Max_tr));
            validate_non_negative_index("RT", "N", N);
            validate_non_negative_index("RT", "N_cond", N_cond);
            validate_non_negative_index("RT", "2", 2);
            validate_non_negative_index("RT", "Max_tr", Max_tr);
            RT = std::vector<std::vector<matrix_d> >(N,std::vector<matrix_d>(N_cond,matrix_d(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(Max_tr))));
            vals_r__ = context__.vals_r("RT");
            pos__ = 0;
            size_t RT_m_mat_lim__ = 2;
            size_t RT_n_mat_lim__ = Max_tr;
            for (size_t n_mat__ = 0; n_mat__ < RT_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < RT_m_mat_lim__; ++m_mat__) {
                    size_t RT_limit_1__ = N_cond;
                    for (size_t i_1__ = 0; i_1__ < RT_limit_1__; ++i_1__) {
                        size_t RT_limit_0__ = N;
                        for (size_t i_0__ = 0; i_0__ < RT_limit_0__; ++i_0__) {
                            RT[i_0__][i_1__](m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
                }
            }

            // validate, data variables
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            validate_non_negative_index("mu_v", "N_choices", N_choices);
            validate_non_negative_index("mu_v", "N_cond", N_cond);
            num_params_r__ += N_choices * N_cond;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            validate_non_negative_index("sigma_v", "N_choices", N_choices);
            validate_non_negative_index("sigma_v", "N_cond", N_cond);
            num_params_r__ += N_choices * N_cond;
            validate_non_negative_index("d", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("A", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("tau", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("v", "N_choices", N_choices);
            validate_non_negative_index("v", "N", N);
            validate_non_negative_index("v", "N_cond", N_cond);
            num_params_r__ += N_choices * N * N_cond;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_choiceRT_lba() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_d")))
            throw std::runtime_error("variable mu_d missing");
        vals_r__ = context__.vals_r("mu_d");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_d", "double", context__.to_vec());
        double mu_d(0);
        mu_d = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,mu_d);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_d: ") + e.what());
        }

        if (!(context__.contains_r("mu_A")))
            throw std::runtime_error("variable mu_A missing");
        vals_r__ = context__.vals_r("mu_A");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_A", "double", context__.to_vec());
        double mu_A(0);
        mu_A = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,mu_A);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_A: ") + e.what());
        }

        if (!(context__.contains_r("mu_tau")))
            throw std::runtime_error("variable mu_tau missing");
        vals_r__ = context__.vals_r("mu_tau");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_tau", "double", context__.to_vec());
        double mu_tau(0);
        mu_tau = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,mu_tau);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_tau: ") + e.what());
        }

        if (!(context__.contains_r("mu_v")))
            throw std::runtime_error("variable mu_v missing");
        vals_r__ = context__.vals_r("mu_v");
        pos__ = 0U;
        validate_non_negative_index("mu_v", "N_cond", N_cond);
        validate_non_negative_index("mu_v", "N_choices", N_choices);
        context__.validate_dims("initialization", "mu_v", "vector_d", context__.to_vec(N_cond,N_choices));
        std::vector<vector_d> mu_v(N_cond,vector_d(static_cast<Eigen::VectorXd::Index>(N_choices)));
        for (int j1__ = 0U; j1__ < N_choices; ++j1__)
            for (int i0__ = 0U; i0__ < N_cond; ++i0__)
                mu_v[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_cond; ++i0__)
            try {
            writer__.vector_lb_unconstrain(0,mu_v[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_v: ") + e.what());
        }

        if (!(context__.contains_r("sigma_d")))
            throw std::runtime_error("variable sigma_d missing");
        vals_r__ = context__.vals_r("sigma_d");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_d", "double", context__.to_vec());
        double sigma_d(0);
        sigma_d = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_d);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_d: ") + e.what());
        }

        if (!(context__.contains_r("sigma_A")))
            throw std::runtime_error("variable sigma_A missing");
        vals_r__ = context__.vals_r("sigma_A");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_A", "double", context__.to_vec());
        double sigma_A(0);
        sigma_A = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_A);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_A: ") + e.what());
        }

        if (!(context__.contains_r("sigma_tau")))
            throw std::runtime_error("variable sigma_tau missing");
        vals_r__ = context__.vals_r("sigma_tau");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_tau", "double", context__.to_vec());
        double sigma_tau(0);
        sigma_tau = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_tau);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_tau: ") + e.what());
        }

        if (!(context__.contains_r("sigma_v")))
            throw std::runtime_error("variable sigma_v missing");
        vals_r__ = context__.vals_r("sigma_v");
        pos__ = 0U;
        validate_non_negative_index("sigma_v", "N_cond", N_cond);
        validate_non_negative_index("sigma_v", "N_choices", N_choices);
        context__.validate_dims("initialization", "sigma_v", "vector_d", context__.to_vec(N_cond,N_choices));
        std::vector<vector_d> sigma_v(N_cond,vector_d(static_cast<Eigen::VectorXd::Index>(N_choices)));
        for (int j1__ = 0U; j1__ < N_choices; ++j1__)
            for (int i0__ = 0U; i0__ < N_cond; ++i0__)
                sigma_v[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_cond; ++i0__)
            try {
            writer__.vector_lb_unconstrain(0,sigma_v[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_v: ") + e.what());
        }

        if (!(context__.contains_r("d")))
            throw std::runtime_error("variable d missing");
        vals_r__ = context__.vals_r("d");
        pos__ = 0U;
        validate_non_negative_index("d", "N", N);
        context__.validate_dims("initialization", "d", "double", context__.to_vec(N));
        std::vector<double> d(N,double(0));
        for (int i0__ = 0U; i0__ < N; ++i0__)
            d[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N; ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,d[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable d: ") + e.what());
        }

        if (!(context__.contains_r("A")))
            throw std::runtime_error("variable A missing");
        vals_r__ = context__.vals_r("A");
        pos__ = 0U;
        validate_non_negative_index("A", "N", N);
        context__.validate_dims("initialization", "A", "double", context__.to_vec(N));
        std::vector<double> A(N,double(0));
        for (int i0__ = 0U; i0__ < N; ++i0__)
            A[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N; ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,A[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable A: ") + e.what());
        }

        if (!(context__.contains_r("tau")))
            throw std::runtime_error("variable tau missing");
        vals_r__ = context__.vals_r("tau");
        pos__ = 0U;
        validate_non_negative_index("tau", "N", N);
        context__.validate_dims("initialization", "tau", "double", context__.to_vec(N));
        std::vector<double> tau(N,double(0));
        for (int i0__ = 0U; i0__ < N; ++i0__)
            tau[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N; ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,tau[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau: ") + e.what());
        }

        if (!(context__.contains_r("v")))
            throw std::runtime_error("variable v missing");
        vals_r__ = context__.vals_r("v");
        pos__ = 0U;
        validate_non_negative_index("v", "N", N);
        validate_non_negative_index("v", "N_cond", N_cond);
        validate_non_negative_index("v", "N_choices", N_choices);
        context__.validate_dims("initialization", "v", "vector_d", context__.to_vec(N,N_cond,N_choices));
        std::vector<std::vector<vector_d> > v(N,std::vector<vector_d>(N_cond,vector_d(static_cast<Eigen::VectorXd::Index>(N_choices))));
        for (int j1__ = 0U; j1__ < N_choices; ++j1__)
            for (int i1__ = 0U; i1__ < N_cond; ++i1__)
                for (int i0__ = 0U; i0__ < N; ++i0__)
                    v[i0__][i1__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N; ++i0__)
            for (int i1__ = 0U; i1__ < N_cond; ++i1__)
                try {
            writer__.vector_lb_unconstrain(0,v[i0__][i1__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable v: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ mu_d;
            (void) mu_d;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_d = in__.scalar_lb_constrain(0,lp__);
            else
                mu_d = in__.scalar_lb_constrain(0);

            T__ mu_A;
            (void) mu_A;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_A = in__.scalar_lb_constrain(0,lp__);
            else
                mu_A = in__.scalar_lb_constrain(0);

            T__ mu_tau;
            (void) mu_tau;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_tau = in__.scalar_lb_constrain(0,lp__);
            else
                mu_tau = in__.scalar_lb_constrain(0);

            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > mu_v;
            size_t dim_mu_v_0__ = N_cond;
            mu_v.reserve(dim_mu_v_0__);
            for (size_t k_0__ = 0; k_0__ < dim_mu_v_0__; ++k_0__) {
                if (jacobian__)
                    mu_v.push_back(in__.vector_lb_constrain(0,N_choices,lp__));
                else
                    mu_v.push_back(in__.vector_lb_constrain(0,N_choices));
            }

            T__ sigma_d;
            (void) sigma_d;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma_d = in__.scalar_lb_constrain(0,lp__);
            else
                sigma_d = in__.scalar_lb_constrain(0);

            T__ sigma_A;
            (void) sigma_A;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma_A = in__.scalar_lb_constrain(0,lp__);
            else
                sigma_A = in__.scalar_lb_constrain(0);

            T__ sigma_tau;
            (void) sigma_tau;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma_tau = in__.scalar_lb_constrain(0,lp__);
            else
                sigma_tau = in__.scalar_lb_constrain(0);

            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > sigma_v;
            size_t dim_sigma_v_0__ = N_cond;
            sigma_v.reserve(dim_sigma_v_0__);
            for (size_t k_0__ = 0; k_0__ < dim_sigma_v_0__; ++k_0__) {
                if (jacobian__)
                    sigma_v.push_back(in__.vector_lb_constrain(0,N_choices,lp__));
                else
                    sigma_v.push_back(in__.vector_lb_constrain(0,N_choices));
            }

            vector<T__> d;
            size_t dim_d_0__ = N;
            d.reserve(dim_d_0__);
            for (size_t k_0__ = 0; k_0__ < dim_d_0__; ++k_0__) {
                if (jacobian__)
                    d.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    d.push_back(in__.scalar_lb_constrain(0));
            }

            vector<T__> A;
            size_t dim_A_0__ = N;
            A.reserve(dim_A_0__);
            for (size_t k_0__ = 0; k_0__ < dim_A_0__; ++k_0__) {
                if (jacobian__)
                    A.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    A.push_back(in__.scalar_lb_constrain(0));
            }

            vector<T__> tau;
            size_t dim_tau_0__ = N;
            tau.reserve(dim_tau_0__);
            for (size_t k_0__ = 0; k_0__ < dim_tau_0__; ++k_0__) {
                if (jacobian__)
                    tau.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    tau.push_back(in__.scalar_lb_constrain(0));
            }

            vector<vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > > v;
            size_t dim_v_0__ = N;
            v.resize(dim_v_0__);
            for (size_t k_0__ = 0; k_0__ < dim_v_0__; ++k_0__) {
                size_t dim_v_1__ = N_cond;
                v[k_0__].reserve(dim_v_1__);
                for (size_t k_1__ = 0; k_1__ < dim_v_1__; ++k_1__) {
                    if (jacobian__)
                        v[k_0__].push_back(in__.vector_lb_constrain(0,N_choices,lp__));
                    else
                        v[k_0__].push_back(in__.vector_lb_constrain(0,N_choices));
                }
            }


            // transformed parameters
            T__ s;
            (void) s;  // dummy to suppress unused var warning

            stan::math::initialize(s, DUMMY_VAR__);
            stan::math::fill(s,DUMMY_VAR__);


            stan::math::assign(s, 1);

            // validate transformed parameters
            if (stan::math::is_uninitialized(s)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: s";
                throw std::runtime_error(msg__.str());
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            // model body

            lp_accum__.add(normal_log<propto__>(mu_d, 0.5, 1));
            if (mu_d < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0.5, 1));
            lp_accum__.add(normal_log<propto__>(mu_A, 0.5, 1));
            if (mu_A < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0.5, 1));
            lp_accum__.add(normal_log<propto__>(mu_tau, 0.5, 0.5));
            if (mu_tau < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0.5, 0.5));
            lp_accum__.add(gamma_log<propto__>(sigma_d, 1, 1));
            lp_accum__.add(gamma_log<propto__>(sigma_A, 1, 1));
            lp_accum__.add(gamma_log<propto__>(sigma_tau, 1, 1));
            for (int j = 1; j <= N_cond; ++j) {

                for (int n = 1; n <= N_choices; ++n) {

                    lp_accum__.add(normal_log<propto__>(get_base1(get_base1(mu_v,j,"mu_v",1),n,"mu_v",2), 2, 1));
                    if (get_base1(get_base1(mu_v,j,"mu_v",1),n,"mu_v",2) < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                    else lp_accum__.add(-normal_ccdf_log(0, 2, 1));
                    lp_accum__.add(gamma_log<propto__>(get_base1(get_base1(sigma_v,j,"sigma_v",1),n,"sigma_v",2), 1, 1));
                }
            }
            for (int i = 1; i <= N; ++i) {
                {
                int n_trials(0);
                (void) n_trials;  // dummy to suppress unused var warning

                stan::math::fill(n_trials, std::numeric_limits<int>::min());


                lp_accum__.add(normal_log<propto__>(get_base1(d,i,"d",1), mu_d, sigma_d));
                if (get_base1(d,i,"d",1) < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-normal_ccdf_log(0, mu_d, sigma_d));
                lp_accum__.add(normal_log<propto__>(get_base1(A,i,"A",1), mu_A, sigma_A));
                if (get_base1(A,i,"A",1) < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-normal_ccdf_log(0, mu_A, sigma_A));
                lp_accum__.add(normal_log<propto__>(get_base1(tau,i,"tau",1), mu_tau, sigma_tau));
                if (get_base1(tau,i,"tau",1) < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-normal_ccdf_log(0, mu_tau, sigma_tau));
                for (int j = 1; j <= N_cond; ++j) {

                    stan::math::assign(n_trials, get_base1(get_base1(N_tr_cond,i,"N_tr_cond",1),j,"N_tr_cond",2));
                    for (int n = 1; n <= N_choices; ++n) {

                        lp_accum__.add(normal_log<propto__>(get_base1(get_base1(get_base1(v,i,"v",1),j,"v",2),n,"v",3), get_base1(get_base1(mu_v,j,"mu_v",1),n,"mu_v",2), get_base1(get_base1(sigma_v,j,"sigma_v",1),n,"sigma_v",2)));
                        if (get_base1(get_base1(get_base1(v,i,"v",1),j,"v",2),n,"v",3) < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                        else lp_accum__.add(-normal_ccdf_log(0, get_base1(get_base1(mu_v,j,"mu_v",1),n,"mu_v",2), get_base1(get_base1(sigma_v,j,"sigma_v",1),n,"sigma_v",2)));
                    }
                    lp_accum__.add(lba_lpdf<propto__>(stan::model::rvalue(RT, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(1, n_trials), stan::model::nil_index_list())))), "RT"), get_base1(d,i,"d",1), get_base1(A,i,"A",1), stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "v"), s, get_base1(tau,i,"tau",1), pstream__));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_d");
        names__.push_back("mu_A");
        names__.push_back("mu_tau");
        names__.push_back("mu_v");
        names__.push_back("sigma_d");
        names__.push_back("sigma_A");
        names__.push_back("sigma_tau");
        names__.push_back("sigma_v");
        names__.push_back("d");
        names__.push_back("A");
        names__.push_back("tau");
        names__.push_back("v");
        names__.push_back("s");
        names__.push_back("n_trials");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_cond);
        dims__.push_back(N_choices);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_cond);
        dims__.push_back(N_choices);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(N_cond);
        dims__.push_back(N_choices);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(N_cond);
        dims__.push_back(2);
        dims__.push_back(Max_tr);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_choiceRT_lba_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double mu_d = in__.scalar_lb_constrain(0);
        double mu_A = in__.scalar_lb_constrain(0);
        double mu_tau = in__.scalar_lb_constrain(0);
        vector<vector_d> mu_v;
        size_t dim_mu_v_0__ = N_cond;
        for (size_t k_0__ = 0; k_0__ < dim_mu_v_0__; ++k_0__) {
            mu_v.push_back(in__.vector_lb_constrain(0,N_choices));
        }
        double sigma_d = in__.scalar_lb_constrain(0);
        double sigma_A = in__.scalar_lb_constrain(0);
        double sigma_tau = in__.scalar_lb_constrain(0);
        vector<vector_d> sigma_v;
        size_t dim_sigma_v_0__ = N_cond;
        for (size_t k_0__ = 0; k_0__ < dim_sigma_v_0__; ++k_0__) {
            sigma_v.push_back(in__.vector_lb_constrain(0,N_choices));
        }
        vector<double> d;
        size_t dim_d_0__ = N;
        for (size_t k_0__ = 0; k_0__ < dim_d_0__; ++k_0__) {
            d.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> A;
        size_t dim_A_0__ = N;
        for (size_t k_0__ = 0; k_0__ < dim_A_0__; ++k_0__) {
            A.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> tau;
        size_t dim_tau_0__ = N;
        for (size_t k_0__ = 0; k_0__ < dim_tau_0__; ++k_0__) {
            tau.push_back(in__.scalar_lb_constrain(0));
        }
        vector<vector<vector_d> > v;
        size_t dim_v_0__ = N;
        v.resize(dim_v_0__);
        for (size_t k_0__ = 0; k_0__ < dim_v_0__; ++k_0__) {
            size_t dim_v_1__ = N_cond;
            for (size_t k_1__ = 0; k_1__ < dim_v_1__; ++k_1__) {
                v[k_0__].push_back(in__.vector_lb_constrain(0,N_choices));
            }
        }
        vars__.push_back(mu_d);
        vars__.push_back(mu_A);
        vars__.push_back(mu_tau);
            for (int k_1__ = 0; k_1__ < N_choices; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N_cond; ++k_0__) {
                vars__.push_back(mu_v[k_0__][k_1__]);
                }
            }
        vars__.push_back(sigma_d);
        vars__.push_back(sigma_A);
        vars__.push_back(sigma_tau);
            for (int k_1__ = 0; k_1__ < N_choices; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N_cond; ++k_0__) {
                vars__.push_back(sigma_v[k_0__][k_1__]);
                }
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(d[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }
            for (int k_2__ = 0; k_2__ < N_choices; ++k_2__) {
                for (int k_1__ = 0; k_1__ < N_cond; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(v[k_0__][k_1__][k_2__]);
                    }
                }
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            double s(0.0);
            (void) s;  // dummy to suppress unused var warning

            stan::math::initialize(s, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(s,DUMMY_VAR__);


            stan::math::assign(s, 1);

            // validate transformed parameters

            // write transformed parameters
        vars__.push_back(s);

            if (!include_gqs__) return;
            // declare and define generated quantities
            int n_trials(0);
            (void) n_trials;  // dummy to suppress unused var warning

            stan::math::fill(n_trials, std::numeric_limits<int>::min());
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "2", 2);
            validate_non_negative_index("y_pred", "Max_tr", Max_tr);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "N_cond", N_cond);
            vector<vector<matrix_d> > y_pred(N, (vector<matrix_d>(N_cond, (matrix_d(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(Max_tr))))));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int j = 1; j <= N_cond; ++j) {

                    for (int t = 1; t <= Max_tr; ++t) {

                        stan::model::assign(y_pred, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list())))), 
                                    rep_vector(-(1),2), 
                                    "assigning variable y_pred");
                    }
                }
            }

            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int j = 1; j <= N_cond; ++j) {

                    stan::math::assign(n_trials, get_base1(get_base1(N_tr_cond,i,"N_tr_cond",1),j,"N_tr_cond",2));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + lba_lpdf(stan::model::rvalue(RT, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(1, n_trials), stan::model::nil_index_list())))), "RT"),get_base1(d,i,"d",1),get_base1(A,i,"A",1),stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "v"),s,get_base1(tau,i,"tau",1), pstream__)));
                    for (int t = 1; t <= n_trials; ++t) {

                        stan::model::assign(y_pred, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list())))), 
                                    lba_rng(get_base1(d,i,"d",1),get_base1(A,i,"A",1),stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "v"),s,get_base1(tau,i,"tau",1), base_rng__, pstream__), 
                                    "assigning variable y_pred");
                    }
                }
            }

            // validate generated quantities

            // write generated quantities
        vars__.push_back(n_trials);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_3__ = 0; k_3__ < Max_tr; ++k_3__) {
                for (int k_2__ = 0; k_2__ < 2; ++k_2__) {
                    for (int k_1__ = 0; k_1__ < N_cond; ++k_1__) {
                        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                        vars__.push_back(y_pred[k_0__][k_1__](k_2__, k_3__));
                        }
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_choiceRT_lba";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_d";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= N_choices; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_v" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_d";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= N_choices; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "sigma_v" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "d" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= N_choices; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= N_cond; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "v" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "s";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "n_trials";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_3__ = 1; k_3__ <= Max_tr; ++k_3__) {
            for (int k_2__ = 1; k_2__ <= 2; ++k_2__) {
                for (int k_1__ = 1; k_1__ <= N_cond; ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__ << '.' << k_3__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_d";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= N_choices; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_v" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_d";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= N_choices; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "sigma_v" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "d" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= N_choices; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= N_cond; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "v" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "s";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "n_trials";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_3__ = 1; k_3__ <= Max_tr; ++k_3__) {
            for (int k_2__ = 1; k_2__ <= 2; ++k_2__) {
                for (int k_1__ = 1; k_1__ <= N_cond; ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__ << '.' << k_3__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_choiceRT_lba_single_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_choiceRT_lba_single");
    reader.add_event(232, 232, "end", "model_choiceRT_lba_single");
    return reader;
}

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
lba_pdf(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v,
            const T4__& s, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        fun_scalar_t__ b_A_tv_ts;
        (void) b_A_tv_ts;  // dummy to suppress unused var warning

        stan::math::initialize(b_A_tv_ts, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_A_tv_ts,DUMMY_VAR__);
        fun_scalar_t__ b_tv_ts;
        (void) b_tv_ts;  // dummy to suppress unused var warning

        stan::math::initialize(b_tv_ts, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_tv_ts,DUMMY_VAR__);
        fun_scalar_t__ term_1;
        (void) term_1;  // dummy to suppress unused var warning

        stan::math::initialize(term_1, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_1,DUMMY_VAR__);
        fun_scalar_t__ term_2;
        (void) term_2;  // dummy to suppress unused var warning

        stan::math::initialize(term_2, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_2,DUMMY_VAR__);
        fun_scalar_t__ term_3;
        (void) term_3;  // dummy to suppress unused var warning

        stan::math::initialize(term_3, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_3,DUMMY_VAR__);
        fun_scalar_t__ term_4;
        (void) term_4;  // dummy to suppress unused var warning

        stan::math::initialize(term_4, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_4,DUMMY_VAR__);
        fun_scalar_t__ pdf;
        (void) pdf;  // dummy to suppress unused var warning

        stan::math::initialize(pdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(pdf,DUMMY_VAR__);


        stan::math::assign(b_A_tv_ts, (((b - A) - (t * v)) / (t * s)));
        stan::math::assign(b_tv_ts, ((b - (t * v)) / (t * s)));
        stan::math::assign(term_1, (v * Phi(b_A_tv_ts)));
        stan::math::assign(term_2, (s * exp(normal_log(b_A_tv_ts,0,1))));
        stan::math::assign(term_3, (v * Phi(b_tv_ts)));
        stan::math::assign(term_4, (s * exp(normal_log(b_tv_ts,0,1))));
        stan::math::assign(pdf, ((1 / A) * (((-(term_1) + term_2) + term_3) - term_4)));
        return stan::math::promote_scalar<fun_return_scalar_t__>(pdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lba_pdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v,
            const T4__& s, std::ostream* pstream__) const {
        return lba_pdf(t, b, A, v, s, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
lba_cdf(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v,
            const T4__& s, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        fun_scalar_t__ b_A_tv;
        (void) b_A_tv;  // dummy to suppress unused var warning

        stan::math::initialize(b_A_tv, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_A_tv,DUMMY_VAR__);
        fun_scalar_t__ b_tv;
        (void) b_tv;  // dummy to suppress unused var warning

        stan::math::initialize(b_tv, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_tv,DUMMY_VAR__);
        fun_scalar_t__ ts;
        (void) ts;  // dummy to suppress unused var warning

        stan::math::initialize(ts, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(ts,DUMMY_VAR__);
        fun_scalar_t__ term_1;
        (void) term_1;  // dummy to suppress unused var warning

        stan::math::initialize(term_1, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_1,DUMMY_VAR__);
        fun_scalar_t__ term_2;
        (void) term_2;  // dummy to suppress unused var warning

        stan::math::initialize(term_2, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_2,DUMMY_VAR__);
        fun_scalar_t__ term_3;
        (void) term_3;  // dummy to suppress unused var warning

        stan::math::initialize(term_3, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_3,DUMMY_VAR__);
        fun_scalar_t__ term_4;
        (void) term_4;  // dummy to suppress unused var warning

        stan::math::initialize(term_4, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_4,DUMMY_VAR__);
        fun_scalar_t__ cdf;
        (void) cdf;  // dummy to suppress unused var warning

        stan::math::initialize(cdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(cdf,DUMMY_VAR__);


        stan::math::assign(b_A_tv, ((b - A) - (t * v)));
        stan::math::assign(b_tv, (b - (t * v)));
        stan::math::assign(ts, (t * s));
        stan::math::assign(term_1, ((b_A_tv / A) * Phi((b_A_tv / ts))));
        stan::math::assign(term_2, ((b_tv / A) * Phi((b_tv / ts))));
        stan::math::assign(term_3, ((ts / A) * exp(normal_log((b_A_tv / ts),0,1))));
        stan::math::assign(term_4, ((ts / A) * exp(normal_log((b_tv / ts),0,1))));
        stan::math::assign(cdf, ((((1 + term_1) - term_2) + term_3) - term_4));
        return stan::math::promote_scalar<fun_return_scalar_t__>(cdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lba_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v,
            const T4__& s, std::ostream* pstream__) const {
        return lba_cdf(t, b, A, v, s, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
lba_lpdf(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& RT,
             const T1__& d,
             const T2__& A,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
             const T4__& s,
             const T5__& tau, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        fun_scalar_t__ t;
        (void) t;  // dummy to suppress unused var warning

        stan::math::initialize(t, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(t,DUMMY_VAR__);
        fun_scalar_t__ b;
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b,DUMMY_VAR__);
        fun_scalar_t__ cdf;
        (void) cdf;  // dummy to suppress unused var warning

        stan::math::initialize(cdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(cdf,DUMMY_VAR__);
        fun_scalar_t__ pdf;
        (void) pdf;  // dummy to suppress unused var warning

        stan::math::initialize(pdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(pdf,DUMMY_VAR__);
        validate_non_negative_index("prob", "rows(RT)", rows(RT));
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  prob(static_cast<Eigen::VectorXd::Index>(rows(RT)));
        (void) prob;  // dummy to suppress unused var warning

        stan::math::initialize(prob, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(prob,DUMMY_VAR__);
        fun_scalar_t__ out;
        (void) out;  // dummy to suppress unused var warning

        stan::math::initialize(out, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(out,DUMMY_VAR__);
        fun_scalar_t__ prob_neg;
        (void) prob_neg;  // dummy to suppress unused var warning

        stan::math::initialize(prob_neg, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(prob_neg,DUMMY_VAR__);


        stan::math::assign(b, (A + d));
        for (int i = 1; i <= rows(RT); ++i) {

            stan::math::assign(t, (get_base1(RT,1,i,"RT",1) - tau));
            if (as_bool(logical_gt(t,0))) {

                stan::math::assign(cdf, 1);
                for (int j = 1; j <= num_elements(v); ++j) {

                    if (as_bool(logical_eq(get_base1(RT,2,i,"RT",1),j))) {

                        stan::math::assign(pdf, lba_pdf(t,b,A,get_base1(v,j,"v",1),s, pstream__));
                    } else {

                        stan::math::assign(cdf, ((1 - lba_cdf(t,b,A,get_base1(v,j,"v",1),s, pstream__)) * cdf));
                    }
                }
                stan::math::assign(prob_neg, 1);
                for (int j = 1; j <= num_elements(v); ++j) {

                    stan::math::assign(prob_neg, (Phi((-(get_base1(v,j,"v",1)) / s)) * prob_neg));
                }
                stan::math::assign(get_base1_lhs(prob,i,"prob",1), (pdf * cdf));
                stan::math::assign(get_base1_lhs(prob,i,"prob",1), (get_base1(prob,i,"prob",1) / (1 - prob_neg)));
                if (as_bool(logical_lt(get_base1(prob,i,"prob",1),1e-10))) {

                    stan::math::assign(get_base1_lhs(prob,i,"prob",1), 1e-10);
                }
            } else {

                stan::math::assign(get_base1_lhs(prob,i,"prob",1), 1e-10);
            }
        }
        stan::math::assign(out, sum(log(prob)));
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
lba_lpdf(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& RT,
             const T1__& d,
             const T2__& A,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
             const T4__& s,
             const T5__& tau, std::ostream* pstream__) {
    return lba_lpdf<false>(RT,d,A,v,s,tau, pstream__);
}


struct lba_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& RT,
             const T1__& d,
             const T2__& A,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
             const T4__& s,
             const T5__& tau, std::ostream* pstream__) const {
        return lba_lpdf(RT, d, A, v, s, tau, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1>
lba_rng(const T0__& d,
            const T1__& A,
            const Eigen::Matrix<T2__, Eigen::Dynamic,1>& v,
            const T3__& s,
            const T4__& tau, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        int get_pos_drift(0);
        (void) get_pos_drift;  // dummy to suppress unused var warning

        stan::math::fill(get_pos_drift, std::numeric_limits<int>::min());
        int no_pos_drift(0);
        (void) no_pos_drift;  // dummy to suppress unused var warning

        stan::math::fill(no_pos_drift, std::numeric_limits<int>::min());
        int get_first_pos(0);
        (void) get_first_pos;  // dummy to suppress unused var warning

        stan::math::fill(get_first_pos, std::numeric_limits<int>::min());
        validate_non_negative_index("drift", "num_elements(v)", num_elements(v));
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  drift(static_cast<Eigen::VectorXd::Index>(num_elements(v)));
        (void) drift;  // dummy to suppress unused var warning

        stan::math::initialize(drift, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(drift,DUMMY_VAR__);
        int max_iter(0);
        (void) max_iter;  // dummy to suppress unused var warning

        stan::math::fill(max_iter, std::numeric_limits<int>::min());
        int iter(0);
        (void) iter;  // dummy to suppress unused var warning

        stan::math::fill(iter, std::numeric_limits<int>::min());
        validate_non_negative_index("start", "num_elements(v)", num_elements(v));
        vector<fun_scalar_t__> start(num_elements(v));
        stan::math::initialize(start, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(start,DUMMY_VAR__);
        validate_non_negative_index("ttf", "num_elements(v)", num_elements(v));
        vector<fun_scalar_t__> ttf(num_elements(v));
        stan::math::initialize(ttf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(ttf,DUMMY_VAR__);
        validate_non_negative_index("resp", "num_elements(v)", num_elements(v));
        vector<int> resp(num_elements(v), 0);
        stan::math::fill(resp, std::numeric_limits<int>::min());
        fun_scalar_t__ rt;
        (void) rt;  // dummy to suppress unused var warning

        stan::math::initialize(rt, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(rt,DUMMY_VAR__);
        validate_non_negative_index("pred", "2", 2);
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  pred(static_cast<Eigen::VectorXd::Index>(2));
        (void) pred;  // dummy to suppress unused var warning

        stan::math::initialize(pred, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(pred,DUMMY_VAR__);
        fun_scalar_t__ b;
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b,DUMMY_VAR__);


        stan::math::assign(get_pos_drift, 1);
        stan::math::assign(no_pos_drift, 0);
        stan::math::assign(max_iter, 1000);
        stan::math::assign(iter, 0);
        while (as_bool(get_pos_drift)) {

            for (int j = 1; j <= num_elements(v); ++j) {

                stan::math::assign(get_base1_lhs(drift,j,"drift",1), normal_rng(get_base1(v,j,"v",1),s, base_rng__));
                if (as_bool(logical_gt(get_base1(drift,j,"drift",1),0))) {

                    stan::math::assign(get_pos_drift, 0);
                }
            }
            stan::math::assign(iter, (iter + 1));
            if (as_bool(logical_gt(iter,max_iter))) {

                stan::math::assign(get_pos_drift, 0);
                stan::math::assign(no_pos_drift, 1);
            }
        }
        if (as_bool(no_pos_drift)) {

            stan::math::assign(get_base1_lhs(pred,1,"pred",1), -(1));
            stan::math::assign(get_base1_lhs(pred,2,"pred",1), -(1));
        } else {

            stan::math::assign(b, (A + d));
            for (int i = 1; i <= num_elements(v); ++i) {

                stan::math::assign(get_base1_lhs(start,i,"start",1), uniform_rng(0,A, base_rng__));
                stan::math::assign(get_base1_lhs(ttf,i,"ttf",1), ((b - get_base1(start,i,"start",1)) / get_base1(drift,i,"drift",1)));
            }
            stan::math::assign(resp, sort_indices_asc(ttf));
            stan::math::assign(ttf, sort_asc(ttf));
            stan::math::assign(get_first_pos, 1);
            stan::math::assign(iter, 1);
            while (as_bool(get_first_pos)) {

                if (as_bool(logical_gt(get_base1(ttf,iter,"ttf",1),0))) {

                    stan::math::assign(get_base1_lhs(pred,1,"pred",1), (get_base1(ttf,iter,"ttf",1) + tau));
                    stan::math::assign(get_base1_lhs(pred,2,"pred",1), get_base1(resp,iter,"resp",1));
                    stan::math::assign(get_first_pos, 0);
                }
                stan::math::assign(iter, (iter + 1));
            }
        }
        return stan::math::promote_scalar<fun_return_scalar_t__>(pred);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lba_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1>
    operator()(const T0__& d,
            const T1__& A,
            const Eigen::Matrix<T2__, Eigen::Dynamic,1>& v,
            const T3__& s,
            const T4__& tau, RNG& base_rng__, std::ostream* pstream__) const {
        return lba_rng(d, A, v, s, tau, base_rng__, pstream__);
    }
};

class model_choiceRT_lba_single : public prob_grad {
private:
    int Max_tr;
    int N_choices;
    int N_cond;
    vector<int> N_tr_cond;
    vector<matrix_d> RT;
public:
    model_choiceRT_lba_single(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_choiceRT_lba_single(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_choiceRT_lba_single_namespace::model_choiceRT_lba_single";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "Max_tr", "int", context__.to_vec());
            Max_tr = int(0);
            vals_i__ = context__.vals_i("Max_tr");
            pos__ = 0;
            Max_tr = vals_i__[pos__++];
            context__.validate_dims("data initialization", "N_choices", "int", context__.to_vec());
            N_choices = int(0);
            vals_i__ = context__.vals_i("N_choices");
            pos__ = 0;
            N_choices = vals_i__[pos__++];
            context__.validate_dims("data initialization", "N_cond", "int", context__.to_vec());
            N_cond = int(0);
            vals_i__ = context__.vals_i("N_cond");
            pos__ = 0;
            N_cond = vals_i__[pos__++];
            validate_non_negative_index("N_tr_cond", "N_cond", N_cond);
            context__.validate_dims("data initialization", "N_tr_cond", "int", context__.to_vec(N_cond));
            validate_non_negative_index("N_tr_cond", "N_cond", N_cond);
            N_tr_cond = std::vector<int>(N_cond,int(0));
            vals_i__ = context__.vals_i("N_tr_cond");
            pos__ = 0;
            size_t N_tr_cond_limit_0__ = N_cond;
            for (size_t i_0__ = 0; i_0__ < N_tr_cond_limit_0__; ++i_0__) {
                N_tr_cond[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("RT", "N_cond", N_cond);
            validate_non_negative_index("RT", "2", 2);
            validate_non_negative_index("RT", "Max_tr", Max_tr);
            context__.validate_dims("data initialization", "RT", "matrix_d", context__.to_vec(N_cond,2,Max_tr));
            validate_non_negative_index("RT", "N_cond", N_cond);
            validate_non_negative_index("RT", "2", 2);
            validate_non_negative_index("RT", "Max_tr", Max_tr);
            RT = std::vector<matrix_d>(N_cond,matrix_d(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(Max_tr)));
            vals_r__ = context__.vals_r("RT");
            pos__ = 0;
            size_t RT_m_mat_lim__ = 2;
            size_t RT_n_mat_lim__ = Max_tr;
            for (size_t n_mat__ = 0; n_mat__ < RT_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < RT_m_mat_lim__; ++m_mat__) {
                    size_t RT_limit_0__ = N_cond;
                    for (size_t i_0__ = 0; i_0__ < RT_limit_0__; ++i_0__) {
                        RT[i_0__](m_mat__,n_mat__) = vals_r__[pos__++];
            }
                }
            }

            // validate, data variables
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            validate_non_negative_index("v", "N_choices", N_choices);
            validate_non_negative_index("v", "N_cond", N_cond);
            num_params_r__ += N_choices * N_cond;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_choiceRT_lba_single() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("d")))
            throw std::runtime_error("variable d missing");
        vals_r__ = context__.vals_r("d");
        pos__ = 0U;
        context__.validate_dims("initialization", "d", "double", context__.to_vec());
        double d(0);
        d = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,d);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable d: ") + e.what());
        }

        if (!(context__.contains_r("A")))
            throw std::runtime_error("variable A missing");
        vals_r__ = context__.vals_r("A");
        pos__ = 0U;
        context__.validate_dims("initialization", "A", "double", context__.to_vec());
        double A(0);
        A = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,A);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable A: ") + e.what());
        }

        if (!(context__.contains_r("tau")))
            throw std::runtime_error("variable tau missing");
        vals_r__ = context__.vals_r("tau");
        pos__ = 0U;
        context__.validate_dims("initialization", "tau", "double", context__.to_vec());
        double tau(0);
        tau = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,tau);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau: ") + e.what());
        }

        if (!(context__.contains_r("v")))
            throw std::runtime_error("variable v missing");
        vals_r__ = context__.vals_r("v");
        pos__ = 0U;
        validate_non_negative_index("v", "N_cond", N_cond);
        validate_non_negative_index("v", "N_choices", N_choices);
        context__.validate_dims("initialization", "v", "vector_d", context__.to_vec(N_cond,N_choices));
        std::vector<vector_d> v(N_cond,vector_d(static_cast<Eigen::VectorXd::Index>(N_choices)));
        for (int j1__ = 0U; j1__ < N_choices; ++j1__)
            for (int i0__ = 0U; i0__ < N_cond; ++i0__)
                v[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_cond; ++i0__)
            try {
            writer__.vector_lb_unconstrain(0,v[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable v: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ d;
            (void) d;  // dummy to suppress unused var warning
            if (jacobian__)
                d = in__.scalar_lb_constrain(0,lp__);
            else
                d = in__.scalar_lb_constrain(0);

            T__ A;
            (void) A;  // dummy to suppress unused var warning
            if (jacobian__)
                A = in__.scalar_lb_constrain(0,lp__);
            else
                A = in__.scalar_lb_constrain(0);

            T__ tau;
            (void) tau;  // dummy to suppress unused var warning
            if (jacobian__)
                tau = in__.scalar_lb_constrain(0,lp__);
            else
                tau = in__.scalar_lb_constrain(0);

            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > v;
            size_t dim_v_0__ = N_cond;
            v.reserve(dim_v_0__);
            for (size_t k_0__ = 0; k_0__ < dim_v_0__; ++k_0__) {
                if (jacobian__)
                    v.push_back(in__.vector_lb_constrain(0,N_choices,lp__));
                else
                    v.push_back(in__.vector_lb_constrain(0,N_choices));
            }


            // transformed parameters
            T__ s;
            (void) s;  // dummy to suppress unused var warning

            stan::math::initialize(s, DUMMY_VAR__);
            stan::math::fill(s,DUMMY_VAR__);


            stan::math::assign(s, 1);

            // validate transformed parameters
            if (stan::math::is_uninitialized(s)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: s";
                throw std::runtime_error(msg__.str());
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            // model body
            {
            int n_trials(0);
            (void) n_trials;  // dummy to suppress unused var warning

            stan::math::fill(n_trials, std::numeric_limits<int>::min());


            lp_accum__.add(normal_log<propto__>(d, 0.5, 1));
            if (d < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0.5, 1));
            lp_accum__.add(normal_log<propto__>(A, 0.5, 1));
            if (A < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0.5, 1));
            lp_accum__.add(normal_log<propto__>(tau, 0.5, 0.5));
            if (tau < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0.5, 0.5));
            for (int j = 1; j <= N_cond; ++j) {

                stan::math::assign(n_trials, get_base1(N_tr_cond,j,"N_tr_cond",1));
                for (int n = 1; n <= N_choices; ++n) {

                    lp_accum__.add(normal_log<propto__>(get_base1(get_base1(v,j,"v",1),n,"v",2), 2, 1));
                    if (get_base1(get_base1(v,j,"v",1),n,"v",2) < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                    else lp_accum__.add(-normal_ccdf_log(0, 2, 1));
                }
                lp_accum__.add(lba_lpdf<propto__>(stan::model::rvalue(RT, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(1, n_trials), stan::model::nil_index_list()))), "RT"), d, A, stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "v"), s, tau, pstream__));
            }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("d");
        names__.push_back("A");
        names__.push_back("tau");
        names__.push_back("v");
        names__.push_back("s");
        names__.push_back("n_trials");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_cond);
        dims__.push_back(N_choices);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_cond);
        dims__.push_back(2);
        dims__.push_back(Max_tr);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_choiceRT_lba_single_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double d = in__.scalar_lb_constrain(0);
        double A = in__.scalar_lb_constrain(0);
        double tau = in__.scalar_lb_constrain(0);
        vector<vector_d> v;
        size_t dim_v_0__ = N_cond;
        for (size_t k_0__ = 0; k_0__ < dim_v_0__; ++k_0__) {
            v.push_back(in__.vector_lb_constrain(0,N_choices));
        }
        vars__.push_back(d);
        vars__.push_back(A);
        vars__.push_back(tau);
            for (int k_1__ = 0; k_1__ < N_choices; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N_cond; ++k_0__) {
                vars__.push_back(v[k_0__][k_1__]);
                }
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            double s(0.0);
            (void) s;  // dummy to suppress unused var warning

            stan::math::initialize(s, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(s,DUMMY_VAR__);


            stan::math::assign(s, 1);

            // validate transformed parameters

            // write transformed parameters
        vars__.push_back(s);

            if (!include_gqs__) return;
            // declare and define generated quantities
            int n_trials(0);
            (void) n_trials;  // dummy to suppress unused var warning

            stan::math::fill(n_trials, std::numeric_limits<int>::min());
            double log_lik(0.0);
            (void) log_lik;  // dummy to suppress unused var warning

            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "2", 2);
            validate_non_negative_index("y_pred", "Max_tr", Max_tr);
            validate_non_negative_index("y_pred", "N_cond", N_cond);
            vector<matrix_d> y_pred(N_cond, (matrix_d(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(Max_tr))));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int j = 1; j <= N_cond; ++j) {

                for (int t = 1; t <= Max_tr; ++t) {

                    stan::model::assign(y_pred, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()))), 
                                rep_vector(-(1),2), 
                                "assigning variable y_pred");
                }
            }
            stan::math::assign(log_lik, 0);

            for (int j = 1; j <= N_cond; ++j) {

                stan::math::assign(n_trials, get_base1(N_tr_cond,j,"N_tr_cond",1));
                stan::math::assign(log_lik, (log_lik + lba_lpdf(stan::model::rvalue(RT, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(1, n_trials), stan::model::nil_index_list()))), "RT"),d,A,stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "v"),s,tau, pstream__)));
                for (int t = 1; t <= n_trials; ++t) {

                    stan::model::assign(y_pred, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()))), 
                                lba_rng(d,A,stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "v"),s,tau, base_rng__, pstream__), 
                                "assigning variable y_pred");
                }
            }

            // validate generated quantities

            // write generated quantities
        vars__.push_back(n_trials);
        vars__.push_back(log_lik);
            for (int k_2__ = 0; k_2__ < Max_tr; ++k_2__) {
                for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N_cond; ++k_0__) {
                    vars__.push_back(y_pred[k_0__](k_1__, k_2__));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_choiceRT_lba_single";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "d";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= N_choices; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "v" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "s";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "n_trials";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_2__ = 1; k_2__ <= Max_tr; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "d";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= N_choices; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "v" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "s";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "n_trials";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_2__ = 1; k_2__ <= Max_tr; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_cra_exp_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_cra_exp");
    reader.add_event(118, 118, "end", "model_cra_exp");
    return reader;
}

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
subjective_value(const T0__& alpha,
                     const T1__& beta,
                     const T2__& p,
                     const T3__& a,
                     const T4__& v, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        return stan::math::promote_scalar<fun_return_scalar_t__>((pow(p,(1 + (beta * a))) * pow(v,alpha)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct subjective_value_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& alpha,
                     const T1__& beta,
                     const T2__& p,
                     const T3__& a,
                     const T4__& v, std::ostream* pstream__) const {
        return subjective_value(alpha, beta, p, a, v, pstream__);
    }
};

class model_cra_exp : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > prob;
    vector<vector<double> > ambig;
    vector<vector<double> > reward_var;
    vector<vector<double> > reward_fix;
public:
    model_cra_exp(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_cra_exp(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_cra_exp_namespace::model_cra_exp";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("prob", "N", N);
            validate_non_negative_index("prob", "T", T);
            context__.validate_dims("data initialization", "prob", "double", context__.to_vec(N,T));
            validate_non_negative_index("prob", "N", N);
            validate_non_negative_index("prob", "T", T);
            prob = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("prob");
            pos__ = 0;
            size_t prob_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < prob_limit_1__; ++i_1__) {
                size_t prob_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < prob_limit_0__; ++i_0__) {
                    prob[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("ambig", "N", N);
            validate_non_negative_index("ambig", "T", T);
            context__.validate_dims("data initialization", "ambig", "double", context__.to_vec(N,T));
            validate_non_negative_index("ambig", "N", N);
            validate_non_negative_index("ambig", "T", T);
            ambig = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("ambig");
            pos__ = 0;
            size_t ambig_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < ambig_limit_1__; ++i_1__) {
                size_t ambig_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < ambig_limit_0__; ++i_0__) {
                    ambig[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("reward_var", "N", N);
            validate_non_negative_index("reward_var", "T", T);
            context__.validate_dims("data initialization", "reward_var", "double", context__.to_vec(N,T));
            validate_non_negative_index("reward_var", "N", N);
            validate_non_negative_index("reward_var", "T", T);
            reward_var = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("reward_var");
            pos__ = 0;
            size_t reward_var_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < reward_var_limit_1__; ++i_1__) {
                size_t reward_var_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < reward_var_limit_0__; ++i_0__) {
                    reward_var[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("reward_fix", "N", N);
            validate_non_negative_index("reward_fix", "T", T);
            context__.validate_dims("data initialization", "reward_fix", "double", context__.to_vec(N,T));
            validate_non_negative_index("reward_fix", "N", N);
            validate_non_negative_index("reward_fix", "T", T);
            reward_fix = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("reward_fix");
            pos__ = 0;
            size_t reward_fix_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < reward_fix_limit_1__; ++i_1__) {
                size_t reward_fix_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < reward_fix_limit_0__; ++i_0__) {
                    reward_fix[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],0);
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"prob[k0__][k1__]",prob[k0__][k1__],0);
                    check_less_or_equal(function__,"prob[k0__][k1__]",prob[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"ambig[k0__][k1__]",ambig[k0__][k1__],0);
                    check_less_or_equal(function__,"ambig[k0__][k1__]",ambig[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"reward_var[k0__][k1__]",reward_var[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"reward_fix[k0__][k1__]",reward_fix[k0__][k1__],0);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("gamma_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_cra_exp() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        if (!(context__.contains_r("gamma_pr")))
            throw std::runtime_error("variable gamma_pr missing");
        vals_r__ = context__.vals_r("gamma_pr");
        pos__ = 0U;
        validate_non_negative_index("gamma_pr", "N", N);
        context__.validate_dims("initialization", "gamma_pr", "vector_d", context__.to_vec(N));
        vector_d gamma_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            gamma_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(gamma_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable gamma_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  gamma_pr;
            (void) gamma_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                gamma_pr = in__.vector_constrain(N,lp__);
            else
                gamma_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);
            validate_non_negative_index("gamma", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  gamma(static_cast<Eigen::VectorXd::Index>(N));
            (void) gamma;  // dummy to suppress unused var warning

            stan::math::initialize(gamma, DUMMY_VAR__);
            stan::math::fill(gamma,DUMMY_VAR__);


            stan::math::assign(alpha, multiply(Phi_approx(add(get_base1(mu_p,1,"mu_p",1),multiply(get_base1(sigma,1,"sigma",1),alpha_pr))),2));
            stan::math::assign(beta, add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),beta_pr)));
            stan::math::assign(gamma, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),gamma_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(gamma(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: gamma" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            check_greater_or_equal(function__,"gamma",gamma,0);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 5));
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(gamma_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    T__ u_fix;
                    (void) u_fix;  // dummy to suppress unused var warning

                    stan::math::initialize(u_fix, DUMMY_VAR__);
                    stan::math::fill(u_fix,DUMMY_VAR__);
                    T__ u_var;
                    (void) u_var;  // dummy to suppress unused var warning

                    stan::math::initialize(u_var, DUMMY_VAR__);
                    stan::math::fill(u_var,DUMMY_VAR__);
                    T__ p_var;
                    (void) p_var;  // dummy to suppress unused var warning

                    stan::math::initialize(p_var, DUMMY_VAR__);
                    stan::math::fill(p_var,DUMMY_VAR__);


                    stan::math::assign(u_fix, subjective_value(get_base1(alpha,i,"alpha",1),get_base1(beta,i,"beta",1),0.5,0,get_base1(get_base1(reward_fix,i,"reward_fix",1),t,"reward_fix",2), pstream__));
                    stan::math::assign(u_var, subjective_value(get_base1(alpha,i,"alpha",1),get_base1(beta,i,"beta",1),get_base1(get_base1(prob,i,"prob",1),t,"prob",2),get_base1(get_base1(ambig,i,"ambig",1),t,"ambig",2),get_base1(get_base1(reward_var,i,"reward_var",1),t,"reward_var",2), pstream__));
                    stan::math::assign(p_var, inv_logit((get_base1(gamma,i,"gamma",1) * (u_var - u_fix))));
                    lp_accum__.add(bernoulli_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),p_var));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("alpha_pr");
        names__.push_back("beta_pr");
        names__.push_back("gamma_pr");
        names__.push_back("alpha");
        names__.push_back("beta");
        names__.push_back("gamma");
        names__.push_back("mu_alpha");
        names__.push_back("mu_beta");
        names__.push_back("mu_gamma");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_cra_exp_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
        vector_d gamma_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(gamma_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);
            validate_non_negative_index("gamma", "N", N);
            vector_d gamma(static_cast<Eigen::VectorXd::Index>(N));
            (void) gamma;  // dummy to suppress unused var warning

            stan::math::initialize(gamma, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(gamma,DUMMY_VAR__);


            stan::math::assign(alpha, multiply(Phi_approx(add(get_base1(mu_p,1,"mu_p",1),multiply(get_base1(sigma,1,"sigma",1),alpha_pr))),2));
            stan::math::assign(beta, add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),beta_pr)));
            stan::math::assign(gamma, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),gamma_pr))));

            // validate transformed parameters
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            check_greater_or_equal(function__,"gamma",gamma,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(gamma[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            double mu_gamma(0.0);
            (void) mu_gamma;  // dummy to suppress unused var warning

            stan::math::initialize(mu_gamma, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_gamma,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_alpha, (Phi_approx(get_base1(mu_p,1,"mu_p",1)) * 2));
            stan::math::assign(mu_beta, get_base1(mu_p,2,"mu_p",1));
            stan::math::assign(mu_gamma, exp(get_base1(mu_p,3,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    double u_fix(0.0);
                    (void) u_fix;  // dummy to suppress unused var warning

                    stan::math::initialize(u_fix, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(u_fix,DUMMY_VAR__);
                    double u_var(0.0);
                    (void) u_var;  // dummy to suppress unused var warning

                    stan::math::initialize(u_var, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(u_var,DUMMY_VAR__);
                    double p_var(0.0);
                    (void) p_var;  // dummy to suppress unused var warning

                    stan::math::initialize(p_var, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(p_var,DUMMY_VAR__);


                    stan::math::assign(u_fix, subjective_value(get_base1(alpha,i,"alpha",1),get_base1(beta,i,"beta",1),0.5,0,get_base1(get_base1(reward_fix,i,"reward_fix",1),t,"reward_fix",2), pstream__));
                    stan::math::assign(u_var, subjective_value(get_base1(alpha,i,"alpha",1),get_base1(beta,i,"beta",1),get_base1(get_base1(prob,i,"prob",1),t,"prob",2),get_base1(get_base1(ambig,i,"ambig",1),t,"ambig",2),get_base1(get_base1(reward_var,i,"reward_var",1),t,"reward_var",2), pstream__));
                    stan::math::assign(p_var, inv_logit((get_base1(gamma,i,"gamma",1) * (u_var - u_fix))));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),p_var)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(p_var, base_rng__));
                    }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_less_or_equal(function__,"mu_alpha",mu_alpha,2);
            check_greater_or_equal(function__,"mu_gamma",mu_gamma,0);

            // write generated quantities
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_beta);
        vars__.push_back(mu_gamma);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_cra_exp";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gamma_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gamma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_gamma";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gamma_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gamma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_gamma";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_cra_linear_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_cra_linear");
    reader.add_event(118, 118, "end", "model_cra_linear");
    return reader;
}

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
subjective_value(const T0__& alpha,
                     const T1__& beta,
                     const T2__& p,
                     const T3__& a,
                     const T4__& v, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        return stan::math::promote_scalar<fun_return_scalar_t__>(((p - ((beta * a) / 2)) * pow(v,alpha)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct subjective_value_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& alpha,
                     const T1__& beta,
                     const T2__& p,
                     const T3__& a,
                     const T4__& v, std::ostream* pstream__) const {
        return subjective_value(alpha, beta, p, a, v, pstream__);
    }
};

class model_cra_linear : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > prob;
    vector<vector<double> > ambig;
    vector<vector<double> > reward_var;
    vector<vector<double> > reward_fix;
public:
    model_cra_linear(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_cra_linear(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_cra_linear_namespace::model_cra_linear";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("prob", "N", N);
            validate_non_negative_index("prob", "T", T);
            context__.validate_dims("data initialization", "prob", "double", context__.to_vec(N,T));
            validate_non_negative_index("prob", "N", N);
            validate_non_negative_index("prob", "T", T);
            prob = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("prob");
            pos__ = 0;
            size_t prob_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < prob_limit_1__; ++i_1__) {
                size_t prob_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < prob_limit_0__; ++i_0__) {
                    prob[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("ambig", "N", N);
            validate_non_negative_index("ambig", "T", T);
            context__.validate_dims("data initialization", "ambig", "double", context__.to_vec(N,T));
            validate_non_negative_index("ambig", "N", N);
            validate_non_negative_index("ambig", "T", T);
            ambig = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("ambig");
            pos__ = 0;
            size_t ambig_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < ambig_limit_1__; ++i_1__) {
                size_t ambig_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < ambig_limit_0__; ++i_0__) {
                    ambig[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("reward_var", "N", N);
            validate_non_negative_index("reward_var", "T", T);
            context__.validate_dims("data initialization", "reward_var", "double", context__.to_vec(N,T));
            validate_non_negative_index("reward_var", "N", N);
            validate_non_negative_index("reward_var", "T", T);
            reward_var = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("reward_var");
            pos__ = 0;
            size_t reward_var_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < reward_var_limit_1__; ++i_1__) {
                size_t reward_var_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < reward_var_limit_0__; ++i_0__) {
                    reward_var[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("reward_fix", "N", N);
            validate_non_negative_index("reward_fix", "T", T);
            context__.validate_dims("data initialization", "reward_fix", "double", context__.to_vec(N,T));
            validate_non_negative_index("reward_fix", "N", N);
            validate_non_negative_index("reward_fix", "T", T);
            reward_fix = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("reward_fix");
            pos__ = 0;
            size_t reward_fix_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < reward_fix_limit_1__; ++i_1__) {
                size_t reward_fix_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < reward_fix_limit_0__; ++i_0__) {
                    reward_fix[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],0);
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"prob[k0__][k1__]",prob[k0__][k1__],0);
                    check_less_or_equal(function__,"prob[k0__][k1__]",prob[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"ambig[k0__][k1__]",ambig[k0__][k1__],0);
                    check_less_or_equal(function__,"ambig[k0__][k1__]",ambig[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"reward_var[k0__][k1__]",reward_var[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"reward_fix[k0__][k1__]",reward_fix[k0__][k1__],0);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("gamma_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_cra_linear() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        if (!(context__.contains_r("gamma_pr")))
            throw std::runtime_error("variable gamma_pr missing");
        vals_r__ = context__.vals_r("gamma_pr");
        pos__ = 0U;
        validate_non_negative_index("gamma_pr", "N", N);
        context__.validate_dims("initialization", "gamma_pr", "vector_d", context__.to_vec(N));
        vector_d gamma_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            gamma_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(gamma_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable gamma_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  gamma_pr;
            (void) gamma_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                gamma_pr = in__.vector_constrain(N,lp__);
            else
                gamma_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);
            validate_non_negative_index("gamma", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  gamma(static_cast<Eigen::VectorXd::Index>(N));
            (void) gamma;  // dummy to suppress unused var warning

            stan::math::initialize(gamma, DUMMY_VAR__);
            stan::math::fill(gamma,DUMMY_VAR__);


            stan::math::assign(alpha, multiply(Phi_approx(add(get_base1(mu_p,1,"mu_p",1),multiply(get_base1(sigma,1,"sigma",1),alpha_pr))),2));
            stan::math::assign(beta, add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),beta_pr)));
            stan::math::assign(gamma, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),gamma_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(gamma(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: gamma" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            check_greater_or_equal(function__,"gamma",gamma,0);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 5));
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(gamma_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    T__ u_fix;
                    (void) u_fix;  // dummy to suppress unused var warning

                    stan::math::initialize(u_fix, DUMMY_VAR__);
                    stan::math::fill(u_fix,DUMMY_VAR__);
                    T__ u_var;
                    (void) u_var;  // dummy to suppress unused var warning

                    stan::math::initialize(u_var, DUMMY_VAR__);
                    stan::math::fill(u_var,DUMMY_VAR__);
                    T__ p_var;
                    (void) p_var;  // dummy to suppress unused var warning

                    stan::math::initialize(p_var, DUMMY_VAR__);
                    stan::math::fill(p_var,DUMMY_VAR__);


                    stan::math::assign(u_fix, subjective_value(get_base1(alpha,i,"alpha",1),get_base1(beta,i,"beta",1),0.5,0,get_base1(get_base1(reward_fix,i,"reward_fix",1),t,"reward_fix",2), pstream__));
                    stan::math::assign(u_var, subjective_value(get_base1(alpha,i,"alpha",1),get_base1(beta,i,"beta",1),get_base1(get_base1(prob,i,"prob",1),t,"prob",2),get_base1(get_base1(ambig,i,"ambig",1),t,"ambig",2),get_base1(get_base1(reward_var,i,"reward_var",1),t,"reward_var",2), pstream__));
                    stan::math::assign(p_var, inv_logit((get_base1(gamma,i,"gamma",1) * (u_var - u_fix))));
                    lp_accum__.add(bernoulli_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),p_var));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("alpha_pr");
        names__.push_back("beta_pr");
        names__.push_back("gamma_pr");
        names__.push_back("alpha");
        names__.push_back("beta");
        names__.push_back("gamma");
        names__.push_back("mu_alpha");
        names__.push_back("mu_beta");
        names__.push_back("mu_gamma");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_cra_linear_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
        vector_d gamma_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(gamma_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);
            validate_non_negative_index("gamma", "N", N);
            vector_d gamma(static_cast<Eigen::VectorXd::Index>(N));
            (void) gamma;  // dummy to suppress unused var warning

            stan::math::initialize(gamma, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(gamma,DUMMY_VAR__);


            stan::math::assign(alpha, multiply(Phi_approx(add(get_base1(mu_p,1,"mu_p",1),multiply(get_base1(sigma,1,"sigma",1),alpha_pr))),2));
            stan::math::assign(beta, add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),beta_pr)));
            stan::math::assign(gamma, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),gamma_pr))));

            // validate transformed parameters
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            check_greater_or_equal(function__,"gamma",gamma,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(gamma[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            double mu_gamma(0.0);
            (void) mu_gamma;  // dummy to suppress unused var warning

            stan::math::initialize(mu_gamma, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_gamma,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_alpha, (Phi_approx(get_base1(mu_p,1,"mu_p",1)) * 2));
            stan::math::assign(mu_beta, get_base1(mu_p,2,"mu_p",1));
            stan::math::assign(mu_gamma, exp(get_base1(mu_p,3,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    double u_fix(0.0);
                    (void) u_fix;  // dummy to suppress unused var warning

                    stan::math::initialize(u_fix, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(u_fix,DUMMY_VAR__);
                    double u_var(0.0);
                    (void) u_var;  // dummy to suppress unused var warning

                    stan::math::initialize(u_var, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(u_var,DUMMY_VAR__);
                    double p_var(0.0);
                    (void) p_var;  // dummy to suppress unused var warning

                    stan::math::initialize(p_var, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(p_var,DUMMY_VAR__);


                    stan::math::assign(u_fix, subjective_value(get_base1(alpha,i,"alpha",1),get_base1(beta,i,"beta",1),0.5,0,get_base1(get_base1(reward_fix,i,"reward_fix",1),t,"reward_fix",2), pstream__));
                    stan::math::assign(u_var, subjective_value(get_base1(alpha,i,"alpha",1),get_base1(beta,i,"beta",1),get_base1(get_base1(prob,i,"prob",1),t,"prob",2),get_base1(get_base1(ambig,i,"ambig",1),t,"ambig",2),get_base1(get_base1(reward_var,i,"reward_var",1),t,"reward_var",2), pstream__));
                    stan::math::assign(p_var, inv_logit((get_base1(gamma,i,"gamma",1) * (u_var - u_fix))));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),p_var)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(p_var, base_rng__));
                    }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_less_or_equal(function__,"mu_alpha",mu_alpha,2);
            check_greater_or_equal(function__,"mu_gamma",mu_gamma,0);

            // write generated quantities
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_beta);
        vars__.push_back(mu_gamma);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_cra_linear";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gamma_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gamma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_gamma";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gamma_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gamma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_gamma";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_dd_cs_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_dd_cs");
    reader.add_event(104, 104, "end", "model_dd_cs");
    return reader;
}

class model_dd_cs : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > delay_later;
    vector<vector<double> > amount_later;
    vector<vector<double> > delay_sooner;
    vector<vector<double> > amount_sooner;
    vector<vector<int> > choice;
public:
    model_dd_cs(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_dd_cs(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_dd_cs_namespace::model_dd_cs";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("delay_later", "N", N);
            validate_non_negative_index("delay_later", "T", T);
            context__.validate_dims("data initialization", "delay_later", "double", context__.to_vec(N,T));
            validate_non_negative_index("delay_later", "N", N);
            validate_non_negative_index("delay_later", "T", T);
            delay_later = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("delay_later");
            pos__ = 0;
            size_t delay_later_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < delay_later_limit_1__; ++i_1__) {
                size_t delay_later_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < delay_later_limit_0__; ++i_0__) {
                    delay_later[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("amount_later", "N", N);
            validate_non_negative_index("amount_later", "T", T);
            context__.validate_dims("data initialization", "amount_later", "double", context__.to_vec(N,T));
            validate_non_negative_index("amount_later", "N", N);
            validate_non_negative_index("amount_later", "T", T);
            amount_later = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("amount_later");
            pos__ = 0;
            size_t amount_later_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < amount_later_limit_1__; ++i_1__) {
                size_t amount_later_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < amount_later_limit_0__; ++i_0__) {
                    amount_later[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("delay_sooner", "N", N);
            validate_non_negative_index("delay_sooner", "T", T);
            context__.validate_dims("data initialization", "delay_sooner", "double", context__.to_vec(N,T));
            validate_non_negative_index("delay_sooner", "N", N);
            validate_non_negative_index("delay_sooner", "T", T);
            delay_sooner = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("delay_sooner");
            pos__ = 0;
            size_t delay_sooner_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < delay_sooner_limit_1__; ++i_1__) {
                size_t delay_sooner_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < delay_sooner_limit_0__; ++i_0__) {
                    delay_sooner[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("amount_sooner", "N", N);
            validate_non_negative_index("amount_sooner", "T", T);
            context__.validate_dims("data initialization", "amount_sooner", "double", context__.to_vec(N,T));
            validate_non_negative_index("amount_sooner", "N", N);
            validate_non_negative_index("amount_sooner", "T", T);
            amount_sooner = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("amount_sooner");
            pos__ = 0;
            size_t amount_sooner_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < amount_sooner_limit_1__; ++i_1__) {
                size_t amount_sooner_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < amount_sooner_limit_0__; ++i_0__) {
                    amount_sooner[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"delay_later[k0__][k1__]",delay_later[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"amount_later[k0__][k1__]",amount_later[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"delay_sooner[k0__][k1__]",delay_sooner[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"amount_sooner[k0__][k1__]",amount_sooner[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],1);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("r_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("s_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_dd_cs() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("r_pr")))
            throw std::runtime_error("variable r_pr missing");
        vals_r__ = context__.vals_r("r_pr");
        pos__ = 0U;
        validate_non_negative_index("r_pr", "N", N);
        context__.validate_dims("initialization", "r_pr", "vector_d", context__.to_vec(N));
        vector_d r_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            r_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(r_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable r_pr: ") + e.what());
        }

        if (!(context__.contains_r("s_pr")))
            throw std::runtime_error("variable s_pr missing");
        vals_r__ = context__.vals_r("s_pr");
        pos__ = 0U;
        validate_non_negative_index("s_pr", "N", N);
        context__.validate_dims("initialization", "s_pr", "vector_d", context__.to_vec(N));
        vector_d s_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            s_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(s_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable s_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  r_pr;
            (void) r_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                r_pr = in__.vector_constrain(N,lp__);
            else
                r_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  s_pr;
            (void) s_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                s_pr = in__.vector_constrain(N,lp__);
            else
                s_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("r", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  r(static_cast<Eigen::VectorXd::Index>(N));
            (void) r;  // dummy to suppress unused var warning

            stan::math::initialize(r, DUMMY_VAR__);
            stan::math::fill(r,DUMMY_VAR__);
            validate_non_negative_index("s", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  s(static_cast<Eigen::VectorXd::Index>(N));
            (void) s;  // dummy to suppress unused var warning

            stan::math::initialize(s, DUMMY_VAR__);
            stan::math::fill(s,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(r,i,"r",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(r_pr,i,"r_pr",1)))));
                stan::math::assign(get_base1_lhs(s,i,"s",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(s_pr,i,"s_pr",1)))) * 10));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(r(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: r" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(s(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: s" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"r",r,0);
            check_less_or_equal(function__,"r",r,1);
            check_greater_or_equal(function__,"s",s,0);
            check_less_or_equal(function__,"s",s,10);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(r_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(s_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                T__ ev_later;
                (void) ev_later;  // dummy to suppress unused var warning

                stan::math::initialize(ev_later, DUMMY_VAR__);
                stan::math::fill(ev_later,DUMMY_VAR__);
                T__ ev_sooner;
                (void) ev_sooner;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sooner, DUMMY_VAR__);
                stan::math::fill(ev_sooner,DUMMY_VAR__);


                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(ev_later, (get_base1(get_base1(amount_later,i,"amount_later",1),t,"amount_later",2) * exp((-(1) * pow((get_base1(r,i,"r",1) * get_base1(get_base1(delay_later,i,"delay_later",1),t,"delay_later",2)),get_base1(s,i,"s",1))))));
                    stan::math::assign(ev_sooner, (get_base1(get_base1(amount_sooner,i,"amount_sooner",1),t,"amount_sooner",2) * exp((-(1) * pow((get_base1(r,i,"r",1) * get_base1(get_base1(delay_sooner,i,"delay_sooner",1),t,"delay_sooner",2)),get_base1(s,i,"s",1))))));
                    lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), (get_base1(beta,i,"beta",1) * (ev_later - ev_sooner))));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("r_pr");
        names__.push_back("s_pr");
        names__.push_back("beta_pr");
        names__.push_back("r");
        names__.push_back("s");
        names__.push_back("beta");
        names__.push_back("mu_r");
        names__.push_back("mu_s");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_dd_cs_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d r_pr = in__.vector_constrain(N);
        vector_d s_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(r_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(s_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("r", "N", N);
            vector_d r(static_cast<Eigen::VectorXd::Index>(N));
            (void) r;  // dummy to suppress unused var warning

            stan::math::initialize(r, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(r,DUMMY_VAR__);
            validate_non_negative_index("s", "N", N);
            vector_d s(static_cast<Eigen::VectorXd::Index>(N));
            (void) s;  // dummy to suppress unused var warning

            stan::math::initialize(s, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(s,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(r,i,"r",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(r_pr,i,"r_pr",1)))));
                stan::math::assign(get_base1_lhs(s,i,"s",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(s_pr,i,"s_pr",1)))) * 10));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"r",r,0);
            check_less_or_equal(function__,"r",r,1);
            check_greater_or_equal(function__,"s",s,0);
            check_less_or_equal(function__,"s",s,10);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(r[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(s[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_r(0.0);
            (void) mu_r;  // dummy to suppress unused var warning

            stan::math::initialize(mu_r, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_r,DUMMY_VAR__);
            double mu_s(0.0);
            (void) mu_s;  // dummy to suppress unused var warning

            stan::math::initialize(mu_s, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_s,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_r, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_s, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 10));
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));

            for (int i = 1; i <= N; ++i) {
                {
                double ev_later(0.0);
                (void) ev_later;  // dummy to suppress unused var warning

                stan::math::initialize(ev_later, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_later,DUMMY_VAR__);
                double ev_sooner(0.0);
                (void) ev_sooner;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sooner, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_sooner,DUMMY_VAR__);


                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(ev_later, (get_base1(get_base1(amount_later,i,"amount_later",1),t,"amount_later",2) * exp((-(1) * pow((get_base1(r,i,"r",1) * get_base1(get_base1(delay_later,i,"delay_later",1),t,"delay_later",2)),get_base1(s,i,"s",1))))));
                    stan::math::assign(ev_sooner, (get_base1(get_base1(amount_sooner,i,"amount_sooner",1),t,"amount_sooner",2) * exp((-(1) * pow((get_base1(r,i,"r",1) * get_base1(get_base1(delay_sooner,i,"delay_sooner",1),t,"delay_sooner",2)),get_base1(s,i,"s",1))))));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),(get_base1(beta,i,"beta",1) * (ev_later - ev_sooner)))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(inv_logit((get_base1(beta,i,"beta",1) * (ev_later - ev_sooner))), base_rng__));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_r",mu_r,0);
            check_less_or_equal(function__,"mu_r",mu_r,1);
            check_greater_or_equal(function__,"mu_s",mu_s,0);
            check_less_or_equal(function__,"mu_s",mu_s,10);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,5);

            // write generated quantities
        vars__.push_back(mu_r);
        vars__.push_back(mu_s);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_dd_cs";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_s";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_s";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_dd_cs_single_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_dd_cs_single");
    reader.add_event(60, 60, "end", "model_dd_cs_single");
    return reader;
}

class model_dd_cs_single : public prob_grad {
private:
    int Tsubj;
    vector<double> delay_later;
    vector<double> amount_later;
    vector<double> delay_sooner;
    vector<double> amount_sooner;
    vector<int> choice;
public:
    model_dd_cs_single(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_dd_cs_single(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_dd_cs_single_namespace::model_dd_cs_single";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec());
            Tsubj = int(0);
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            Tsubj = vals_i__[pos__++];
            validate_non_negative_index("delay_later", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "delay_later", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("delay_later", "Tsubj", Tsubj);
            delay_later = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("delay_later");
            pos__ = 0;
            size_t delay_later_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < delay_later_limit_0__; ++i_0__) {
                delay_later[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("amount_later", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "amount_later", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("amount_later", "Tsubj", Tsubj);
            amount_later = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("amount_later");
            pos__ = 0;
            size_t amount_later_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < amount_later_limit_0__; ++i_0__) {
                amount_later[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("delay_sooner", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "delay_sooner", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("delay_sooner", "Tsubj", Tsubj);
            delay_sooner = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("delay_sooner");
            pos__ = 0;
            size_t delay_sooner_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < delay_sooner_limit_0__; ++i_0__) {
                delay_sooner[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("amount_sooner", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "amount_sooner", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("amount_sooner", "Tsubj", Tsubj);
            amount_sooner = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("amount_sooner");
            pos__ = 0;
            size_t amount_sooner_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < amount_sooner_limit_0__; ++i_0__) {
                amount_sooner[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("choice", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(Tsubj));
            validate_non_negative_index("choice", "Tsubj", Tsubj);
            choice = std::vector<int>(Tsubj,int(0));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                choice[i_0__] = vals_i__[pos__++];
            }

            // validate, data variables
            check_greater_or_equal(function__,"Tsubj",Tsubj,1);
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"delay_later[k0__]",delay_later[k0__],0);
            }
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"amount_later[k0__]",amount_later[k0__],0);
            }
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"delay_sooner[k0__]",delay_sooner[k0__],0);
            }
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"amount_sooner[k0__]",amount_sooner[k0__],0);
            }
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"choice[k0__]",choice[k0__],-(1));
                check_less_or_equal(function__,"choice[k0__]",choice[k0__],1);
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_dd_cs_single() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("r")))
            throw std::runtime_error("variable r missing");
        vals_r__ = context__.vals_r("r");
        pos__ = 0U;
        context__.validate_dims("initialization", "r", "double", context__.to_vec());
        double r(0);
        r = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,r);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable r: ") + e.what());
        }

        if (!(context__.contains_r("s")))
            throw std::runtime_error("variable s missing");
        vals_r__ = context__.vals_r("s");
        pos__ = 0U;
        context__.validate_dims("initialization", "s", "double", context__.to_vec());
        double s(0);
        s = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,10,s);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable s: ") + e.what());
        }

        if (!(context__.contains_r("beta")))
            throw std::runtime_error("variable beta missing");
        vals_r__ = context__.vals_r("beta");
        pos__ = 0U;
        context__.validate_dims("initialization", "beta", "double", context__.to_vec());
        double beta(0);
        beta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,5,beta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ r;
            (void) r;  // dummy to suppress unused var warning
            if (jacobian__)
                r = in__.scalar_lub_constrain(0,1,lp__);
            else
                r = in__.scalar_lub_constrain(0,1);

            T__ s;
            (void) s;  // dummy to suppress unused var warning
            if (jacobian__)
                s = in__.scalar_lub_constrain(0,10,lp__);
            else
                s = in__.scalar_lub_constrain(0,10);

            T__ beta;
            (void) beta;  // dummy to suppress unused var warning
            if (jacobian__)
                beta = in__.scalar_lub_constrain(0,5,lp__);
            else
                beta = in__.scalar_lub_constrain(0,5);


            // transformed parameters
            validate_non_negative_index("ev_later", "Tsubj", Tsubj);
            vector<T__> ev_later(Tsubj);
            stan::math::initialize(ev_later, DUMMY_VAR__);
            stan::math::fill(ev_later,DUMMY_VAR__);
            validate_non_negative_index("ev_sooner", "Tsubj", Tsubj);
            vector<T__> ev_sooner(Tsubj);
            stan::math::initialize(ev_sooner, DUMMY_VAR__);
            stan::math::fill(ev_sooner,DUMMY_VAR__);


            for (int t = 1; t <= Tsubj; ++t) {

                stan::math::assign(get_base1_lhs(ev_later,t,"ev_later",1), (get_base1(amount_later,t,"amount_later",1) * exp((-(1) * pow((r * get_base1(delay_later,t,"delay_later",1)),s)))));
                stan::math::assign(get_base1_lhs(ev_sooner,t,"ev_sooner",1), (get_base1(amount_sooner,t,"amount_sooner",1) * exp((-(1) * pow((r * get_base1(delay_sooner,t,"delay_sooner",1)),s)))));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < Tsubj; ++i0__) {
                if (stan::math::is_uninitialized(ev_later[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ev_later" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < Tsubj; ++i0__) {
                if (stan::math::is_uninitialized(ev_sooner[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ev_sooner" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            // model body

            lp_accum__.add(uniform_log<propto__>(r, 0, 1));
            lp_accum__.add(uniform_log<propto__>(s, 0, 10));
            lp_accum__.add(uniform_log<propto__>(beta, 0, 5));
            for (int t = 1; t <= Tsubj; ++t) {

                lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(choice,t,"choice",1), (beta * (get_base1(ev_later,t,"ev_later",1) - get_base1(ev_sooner,t,"ev_sooner",1)))));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("r");
        names__.push_back("s");
        names__.push_back("beta");
        names__.push_back("ev_later");
        names__.push_back("ev_sooner");
        names__.push_back("logR");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Tsubj);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Tsubj);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Tsubj);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_dd_cs_single_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double r = in__.scalar_lub_constrain(0,1);
        double s = in__.scalar_lub_constrain(0,10);
        double beta = in__.scalar_lub_constrain(0,5);
        vars__.push_back(r);
        vars__.push_back(s);
        vars__.push_back(beta);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("ev_later", "Tsubj", Tsubj);
            vector<double> ev_later(Tsubj, 0.0);
            stan::math::initialize(ev_later, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ev_later,DUMMY_VAR__);
            validate_non_negative_index("ev_sooner", "Tsubj", Tsubj);
            vector<double> ev_sooner(Tsubj, 0.0);
            stan::math::initialize(ev_sooner, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ev_sooner,DUMMY_VAR__);


            for (int t = 1; t <= Tsubj; ++t) {

                stan::math::assign(get_base1_lhs(ev_later,t,"ev_later",1), (get_base1(amount_later,t,"amount_later",1) * exp((-(1) * pow((r * get_base1(delay_later,t,"delay_later",1)),s)))));
                stan::math::assign(get_base1_lhs(ev_sooner,t,"ev_sooner",1), (get_base1(amount_sooner,t,"amount_sooner",1) * exp((-(1) * pow((r * get_base1(delay_sooner,t,"delay_sooner",1)),s)))));
            }

            // validate transformed parameters

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < Tsubj; ++k_0__) {
            vars__.push_back(ev_later[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < Tsubj; ++k_0__) {
            vars__.push_back(ev_sooner[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double logR(0.0);
            (void) logR;  // dummy to suppress unused var warning

            stan::math::initialize(logR, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(logR,DUMMY_VAR__);
            double log_lik(0.0);
            (void) log_lik;  // dummy to suppress unused var warning

            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "Tsubj", Tsubj);
            vector<double> y_pred(Tsubj, 0.0);
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            stan::math::assign(logR, log(r));

            stan::math::assign(log_lik, 0);
            for (int t = 1; t <= Tsubj; ++t) {

                stan::math::assign(log_lik, (log_lik + bernoulli_logit_log(get_base1(choice,t,"choice",1),(beta * (get_base1(ev_later,t,"ev_later",1) - get_base1(ev_sooner,t,"ev_sooner",1))))));
                stan::math::assign(get_base1_lhs(y_pred,t,"y_pred",1), bernoulli_rng(inv_logit((beta * (get_base1(ev_later,t,"ev_later",1) - get_base1(ev_sooner,t,"ev_sooner",1)))), base_rng__));
            }

            // validate generated quantities

            // write generated quantities
        vars__.push_back(logR);
        vars__.push_back(log_lik);
            for (int k_0__ = 0; k_0__ < Tsubj; ++k_0__) {
            vars__.push_back(y_pred[k_0__]);
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_dd_cs_single";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "s";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_later" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_sooner" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "logR";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "y_pred" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "s";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_later" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_sooner" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "logR";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "y_pred" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_dd_exp_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_dd_exp");
    reader.add_event(98, 98, "end", "model_dd_exp");
    return reader;
}

class model_dd_exp : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > delay_later;
    vector<vector<double> > amount_later;
    vector<vector<double> > delay_sooner;
    vector<vector<double> > amount_sooner;
    vector<vector<int> > choice;
public:
    model_dd_exp(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_dd_exp(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_dd_exp_namespace::model_dd_exp";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("delay_later", "N", N);
            validate_non_negative_index("delay_later", "T", T);
            context__.validate_dims("data initialization", "delay_later", "double", context__.to_vec(N,T));
            validate_non_negative_index("delay_later", "N", N);
            validate_non_negative_index("delay_later", "T", T);
            delay_later = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("delay_later");
            pos__ = 0;
            size_t delay_later_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < delay_later_limit_1__; ++i_1__) {
                size_t delay_later_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < delay_later_limit_0__; ++i_0__) {
                    delay_later[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("amount_later", "N", N);
            validate_non_negative_index("amount_later", "T", T);
            context__.validate_dims("data initialization", "amount_later", "double", context__.to_vec(N,T));
            validate_non_negative_index("amount_later", "N", N);
            validate_non_negative_index("amount_later", "T", T);
            amount_later = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("amount_later");
            pos__ = 0;
            size_t amount_later_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < amount_later_limit_1__; ++i_1__) {
                size_t amount_later_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < amount_later_limit_0__; ++i_0__) {
                    amount_later[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("delay_sooner", "N", N);
            validate_non_negative_index("delay_sooner", "T", T);
            context__.validate_dims("data initialization", "delay_sooner", "double", context__.to_vec(N,T));
            validate_non_negative_index("delay_sooner", "N", N);
            validate_non_negative_index("delay_sooner", "T", T);
            delay_sooner = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("delay_sooner");
            pos__ = 0;
            size_t delay_sooner_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < delay_sooner_limit_1__; ++i_1__) {
                size_t delay_sooner_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < delay_sooner_limit_0__; ++i_0__) {
                    delay_sooner[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("amount_sooner", "N", N);
            validate_non_negative_index("amount_sooner", "T", T);
            context__.validate_dims("data initialization", "amount_sooner", "double", context__.to_vec(N,T));
            validate_non_negative_index("amount_sooner", "N", N);
            validate_non_negative_index("amount_sooner", "T", T);
            amount_sooner = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("amount_sooner");
            pos__ = 0;
            size_t amount_sooner_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < amount_sooner_limit_1__; ++i_1__) {
                size_t amount_sooner_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < amount_sooner_limit_0__; ++i_0__) {
                    amount_sooner[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"delay_later[k0__][k1__]",delay_later[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"amount_later[k0__][k1__]",amount_later[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"delay_sooner[k0__][k1__]",delay_sooner[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"amount_sooner[k0__][k1__]",amount_sooner[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],1);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            validate_non_negative_index("r_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_dd_exp() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("r_pr")))
            throw std::runtime_error("variable r_pr missing");
        vals_r__ = context__.vals_r("r_pr");
        pos__ = 0U;
        validate_non_negative_index("r_pr", "N", N);
        context__.validate_dims("initialization", "r_pr", "vector_d", context__.to_vec(N));
        vector_d r_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            r_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(r_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable r_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  r_pr;
            (void) r_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                r_pr = in__.vector_constrain(N,lp__);
            else
                r_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("r", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  r(static_cast<Eigen::VectorXd::Index>(N));
            (void) r;  // dummy to suppress unused var warning

            stan::math::initialize(r, DUMMY_VAR__);
            stan::math::fill(r,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(r,i,"r",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(r_pr,i,"r_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(r(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: r" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"r",r,0);
            check_less_or_equal(function__,"r",r,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(r_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                T__ ev_later;
                (void) ev_later;  // dummy to suppress unused var warning

                stan::math::initialize(ev_later, DUMMY_VAR__);
                stan::math::fill(ev_later,DUMMY_VAR__);
                T__ ev_sooner;
                (void) ev_sooner;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sooner, DUMMY_VAR__);
                stan::math::fill(ev_sooner,DUMMY_VAR__);


                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(ev_later, (get_base1(get_base1(amount_later,i,"amount_later",1),t,"amount_later",2) * exp(((-(1) * get_base1(r,i,"r",1)) * get_base1(get_base1(delay_later,i,"delay_later",1),t,"delay_later",2)))));
                    stan::math::assign(ev_sooner, (get_base1(get_base1(amount_sooner,i,"amount_sooner",1),t,"amount_sooner",2) * exp(((-(1) * get_base1(r,i,"r",1)) * get_base1(get_base1(delay_sooner,i,"delay_sooner",1),t,"delay_sooner",2)))));
                    lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), (get_base1(beta,i,"beta",1) * (ev_later - ev_sooner))));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("r_pr");
        names__.push_back("beta_pr");
        names__.push_back("r");
        names__.push_back("beta");
        names__.push_back("mu_r");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_dd_exp_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d r_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(r_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("r", "N", N);
            vector_d r(static_cast<Eigen::VectorXd::Index>(N));
            (void) r;  // dummy to suppress unused var warning

            stan::math::initialize(r, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(r,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(r,i,"r",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(r_pr,i,"r_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"r",r,0);
            check_less_or_equal(function__,"r",r,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(r[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_r(0.0);
            (void) mu_r;  // dummy to suppress unused var warning

            stan::math::initialize(mu_r, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_r,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_r, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 5));

            for (int i = 1; i <= N; ++i) {
                {
                double ev_later(0.0);
                (void) ev_later;  // dummy to suppress unused var warning

                stan::math::initialize(ev_later, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_later,DUMMY_VAR__);
                double ev_sooner(0.0);
                (void) ev_sooner;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sooner, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_sooner,DUMMY_VAR__);


                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(ev_later, (get_base1(get_base1(amount_later,i,"amount_later",1),t,"amount_later",2) * exp(((-(1) * get_base1(r,i,"r",1)) * get_base1(get_base1(delay_later,i,"delay_later",1),t,"delay_later",2)))));
                    stan::math::assign(ev_sooner, (get_base1(get_base1(amount_sooner,i,"amount_sooner",1),t,"amount_sooner",2) * exp(((-(1) * get_base1(r,i,"r",1)) * get_base1(get_base1(delay_sooner,i,"delay_sooner",1),t,"delay_sooner",2)))));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),(get_base1(beta,i,"beta",1) * (ev_later - ev_sooner)))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(inv_logit((get_base1(beta,i,"beta",1) * (ev_later - ev_sooner))), base_rng__));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_r",mu_r,0);
            check_less_or_equal(function__,"mu_r",mu_r,1);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,5);

            // write generated quantities
        vars__.push_back(mu_r);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_dd_exp";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_dd_hyperbolic_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_dd_hyperbolic");
    reader.add_event(98, 98, "end", "model_dd_hyperbolic");
    return reader;
}

class model_dd_hyperbolic : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > delay_later;
    vector<vector<double> > amount_later;
    vector<vector<double> > delay_sooner;
    vector<vector<double> > amount_sooner;
    vector<vector<int> > choice;
public:
    model_dd_hyperbolic(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_dd_hyperbolic(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_dd_hyperbolic_namespace::model_dd_hyperbolic";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("delay_later", "N", N);
            validate_non_negative_index("delay_later", "T", T);
            context__.validate_dims("data initialization", "delay_later", "double", context__.to_vec(N,T));
            validate_non_negative_index("delay_later", "N", N);
            validate_non_negative_index("delay_later", "T", T);
            delay_later = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("delay_later");
            pos__ = 0;
            size_t delay_later_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < delay_later_limit_1__; ++i_1__) {
                size_t delay_later_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < delay_later_limit_0__; ++i_0__) {
                    delay_later[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("amount_later", "N", N);
            validate_non_negative_index("amount_later", "T", T);
            context__.validate_dims("data initialization", "amount_later", "double", context__.to_vec(N,T));
            validate_non_negative_index("amount_later", "N", N);
            validate_non_negative_index("amount_later", "T", T);
            amount_later = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("amount_later");
            pos__ = 0;
            size_t amount_later_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < amount_later_limit_1__; ++i_1__) {
                size_t amount_later_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < amount_later_limit_0__; ++i_0__) {
                    amount_later[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("delay_sooner", "N", N);
            validate_non_negative_index("delay_sooner", "T", T);
            context__.validate_dims("data initialization", "delay_sooner", "double", context__.to_vec(N,T));
            validate_non_negative_index("delay_sooner", "N", N);
            validate_non_negative_index("delay_sooner", "T", T);
            delay_sooner = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("delay_sooner");
            pos__ = 0;
            size_t delay_sooner_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < delay_sooner_limit_1__; ++i_1__) {
                size_t delay_sooner_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < delay_sooner_limit_0__; ++i_0__) {
                    delay_sooner[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("amount_sooner", "N", N);
            validate_non_negative_index("amount_sooner", "T", T);
            context__.validate_dims("data initialization", "amount_sooner", "double", context__.to_vec(N,T));
            validate_non_negative_index("amount_sooner", "N", N);
            validate_non_negative_index("amount_sooner", "T", T);
            amount_sooner = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("amount_sooner");
            pos__ = 0;
            size_t amount_sooner_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < amount_sooner_limit_1__; ++i_1__) {
                size_t amount_sooner_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < amount_sooner_limit_0__; ++i_0__) {
                    amount_sooner[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"delay_later[k0__][k1__]",delay_later[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"amount_later[k0__][k1__]",amount_later[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"delay_sooner[k0__][k1__]",delay_sooner[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"amount_sooner[k0__][k1__]",amount_sooner[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],1);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            validate_non_negative_index("k_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_dd_hyperbolic() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("k_pr")))
            throw std::runtime_error("variable k_pr missing");
        vals_r__ = context__.vals_r("k_pr");
        pos__ = 0U;
        validate_non_negative_index("k_pr", "N", N);
        context__.validate_dims("initialization", "k_pr", "vector_d", context__.to_vec(N));
        vector_d k_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            k_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(k_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable k_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  k_pr;
            (void) k_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                k_pr = in__.vector_constrain(N,lp__);
            else
                k_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("k", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  k(static_cast<Eigen::VectorXd::Index>(N));
            (void) k;  // dummy to suppress unused var warning

            stan::math::initialize(k, DUMMY_VAR__);
            stan::math::fill(k,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(k,i,"k",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(k_pr,i,"k_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(k(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: k" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"k",k,0);
            check_less_or_equal(function__,"k",k,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(k_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                T__ ev_later;
                (void) ev_later;  // dummy to suppress unused var warning

                stan::math::initialize(ev_later, DUMMY_VAR__);
                stan::math::fill(ev_later,DUMMY_VAR__);
                T__ ev_sooner;
                (void) ev_sooner;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sooner, DUMMY_VAR__);
                stan::math::fill(ev_sooner,DUMMY_VAR__);


                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(ev_later, (get_base1(get_base1(amount_later,i,"amount_later",1),t,"amount_later",2) / (1 + (get_base1(k,i,"k",1) * get_base1(get_base1(delay_later,i,"delay_later",1),t,"delay_later",2)))));
                    stan::math::assign(ev_sooner, (get_base1(get_base1(amount_sooner,i,"amount_sooner",1),t,"amount_sooner",2) / (1 + (get_base1(k,i,"k",1) * get_base1(get_base1(delay_sooner,i,"delay_sooner",1),t,"delay_sooner",2)))));
                    lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), (get_base1(beta,i,"beta",1) * (ev_later - ev_sooner))));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("k_pr");
        names__.push_back("beta_pr");
        names__.push_back("k");
        names__.push_back("beta");
        names__.push_back("mu_k");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_dd_hyperbolic_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d k_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(k_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("k", "N", N);
            vector_d k(static_cast<Eigen::VectorXd::Index>(N));
            (void) k;  // dummy to suppress unused var warning

            stan::math::initialize(k, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(k,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(k,i,"k",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(k_pr,i,"k_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"k",k,0);
            check_less_or_equal(function__,"k",k,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(k[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_k(0.0);
            (void) mu_k;  // dummy to suppress unused var warning

            stan::math::initialize(mu_k, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_k,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_k, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 5));

            for (int i = 1; i <= N; ++i) {
                {
                double ev_later(0.0);
                (void) ev_later;  // dummy to suppress unused var warning

                stan::math::initialize(ev_later, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_later,DUMMY_VAR__);
                double ev_sooner(0.0);
                (void) ev_sooner;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sooner, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_sooner,DUMMY_VAR__);


                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(ev_later, (get_base1(get_base1(amount_later,i,"amount_later",1),t,"amount_later",2) / (1 + (get_base1(k,i,"k",1) * get_base1(get_base1(delay_later,i,"delay_later",1),t,"delay_later",2)))));
                    stan::math::assign(ev_sooner, (get_base1(get_base1(amount_sooner,i,"amount_sooner",1),t,"amount_sooner",2) / (1 + (get_base1(k,i,"k",1) * get_base1(get_base1(delay_sooner,i,"delay_sooner",1),t,"delay_sooner",2)))));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),(get_base1(beta,i,"beta",1) * (ev_later - ev_sooner)))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(inv_logit((get_base1(beta,i,"beta",1) * (ev_later - ev_sooner))), base_rng__));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_k",mu_k,0);
            check_less_or_equal(function__,"mu_k",mu_k,1);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,5);

            // write generated quantities
        vars__.push_back(mu_k);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_dd_hyperbolic";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "k_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "k" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_k";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "k_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "k" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_k";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_dd_hyperbolic_single_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_dd_hyperbolic_single");
    reader.add_event(54, 54, "end", "model_dd_hyperbolic_single");
    return reader;
}

class model_dd_hyperbolic_single : public prob_grad {
private:
    int Tsubj;
    vector<double> delay_later;
    vector<double> amount_later;
    vector<double> delay_sooner;
    vector<double> amount_sooner;
    vector<int> choice;
public:
    model_dd_hyperbolic_single(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_dd_hyperbolic_single(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_dd_hyperbolic_single_namespace::model_dd_hyperbolic_single";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec());
            Tsubj = int(0);
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            Tsubj = vals_i__[pos__++];
            validate_non_negative_index("delay_later", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "delay_later", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("delay_later", "Tsubj", Tsubj);
            delay_later = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("delay_later");
            pos__ = 0;
            size_t delay_later_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < delay_later_limit_0__; ++i_0__) {
                delay_later[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("amount_later", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "amount_later", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("amount_later", "Tsubj", Tsubj);
            amount_later = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("amount_later");
            pos__ = 0;
            size_t amount_later_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < amount_later_limit_0__; ++i_0__) {
                amount_later[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("delay_sooner", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "delay_sooner", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("delay_sooner", "Tsubj", Tsubj);
            delay_sooner = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("delay_sooner");
            pos__ = 0;
            size_t delay_sooner_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < delay_sooner_limit_0__; ++i_0__) {
                delay_sooner[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("amount_sooner", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "amount_sooner", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("amount_sooner", "Tsubj", Tsubj);
            amount_sooner = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("amount_sooner");
            pos__ = 0;
            size_t amount_sooner_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < amount_sooner_limit_0__; ++i_0__) {
                amount_sooner[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("choice", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(Tsubj));
            validate_non_negative_index("choice", "Tsubj", Tsubj);
            choice = std::vector<int>(Tsubj,int(0));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                choice[i_0__] = vals_i__[pos__++];
            }

            // validate, data variables
            check_greater_or_equal(function__,"Tsubj",Tsubj,1);
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"delay_later[k0__]",delay_later[k0__],0);
            }
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"amount_later[k0__]",amount_later[k0__],0);
            }
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"delay_sooner[k0__]",delay_sooner[k0__],0);
            }
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"amount_sooner[k0__]",amount_sooner[k0__],0);
            }
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"choice[k0__]",choice[k0__],-(1));
                check_less_or_equal(function__,"choice[k0__]",choice[k0__],1);
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            ++num_params_r__;
            ++num_params_r__;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_dd_hyperbolic_single() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("k")))
            throw std::runtime_error("variable k missing");
        vals_r__ = context__.vals_r("k");
        pos__ = 0U;
        context__.validate_dims("initialization", "k", "double", context__.to_vec());
        double k(0);
        k = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,k);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable k: ") + e.what());
        }

        if (!(context__.contains_r("beta")))
            throw std::runtime_error("variable beta missing");
        vals_r__ = context__.vals_r("beta");
        pos__ = 0U;
        context__.validate_dims("initialization", "beta", "double", context__.to_vec());
        double beta(0);
        beta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,5,beta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ k;
            (void) k;  // dummy to suppress unused var warning
            if (jacobian__)
                k = in__.scalar_lub_constrain(0,1,lp__);
            else
                k = in__.scalar_lub_constrain(0,1);

            T__ beta;
            (void) beta;  // dummy to suppress unused var warning
            if (jacobian__)
                beta = in__.scalar_lub_constrain(0,5,lp__);
            else
                beta = in__.scalar_lub_constrain(0,5);


            // transformed parameters
            validate_non_negative_index("ev_later", "Tsubj", Tsubj);
            vector<T__> ev_later(Tsubj);
            stan::math::initialize(ev_later, DUMMY_VAR__);
            stan::math::fill(ev_later,DUMMY_VAR__);
            validate_non_negative_index("ev_sooner", "Tsubj", Tsubj);
            vector<T__> ev_sooner(Tsubj);
            stan::math::initialize(ev_sooner, DUMMY_VAR__);
            stan::math::fill(ev_sooner,DUMMY_VAR__);


            for (int t = 1; t <= Tsubj; ++t) {

                stan::math::assign(get_base1_lhs(ev_later,t,"ev_later",1), (get_base1(amount_later,t,"amount_later",1) / (1 + (k * get_base1(delay_later,t,"delay_later",1)))));
                stan::math::assign(get_base1_lhs(ev_sooner,t,"ev_sooner",1), (get_base1(amount_sooner,t,"amount_sooner",1) / (1 + (k * get_base1(delay_sooner,t,"delay_sooner",1)))));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < Tsubj; ++i0__) {
                if (stan::math::is_uninitialized(ev_later[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ev_later" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < Tsubj; ++i0__) {
                if (stan::math::is_uninitialized(ev_sooner[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ev_sooner" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            // model body

            lp_accum__.add(uniform_log<propto__>(k, 0, 1));
            lp_accum__.add(uniform_log<propto__>(beta, 0, 5));
            for (int t = 1; t <= Tsubj; ++t) {

                lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(choice,t,"choice",1), (beta * (get_base1(ev_later,t,"ev_later",1) - get_base1(ev_sooner,t,"ev_sooner",1)))));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("k");
        names__.push_back("beta");
        names__.push_back("ev_later");
        names__.push_back("ev_sooner");
        names__.push_back("logK");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Tsubj);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Tsubj);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Tsubj);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_dd_hyperbolic_single_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double k = in__.scalar_lub_constrain(0,1);
        double beta = in__.scalar_lub_constrain(0,5);
        vars__.push_back(k);
        vars__.push_back(beta);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("ev_later", "Tsubj", Tsubj);
            vector<double> ev_later(Tsubj, 0.0);
            stan::math::initialize(ev_later, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ev_later,DUMMY_VAR__);
            validate_non_negative_index("ev_sooner", "Tsubj", Tsubj);
            vector<double> ev_sooner(Tsubj, 0.0);
            stan::math::initialize(ev_sooner, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ev_sooner,DUMMY_VAR__);


            for (int t = 1; t <= Tsubj; ++t) {

                stan::math::assign(get_base1_lhs(ev_later,t,"ev_later",1), (get_base1(amount_later,t,"amount_later",1) / (1 + (k * get_base1(delay_later,t,"delay_later",1)))));
                stan::math::assign(get_base1_lhs(ev_sooner,t,"ev_sooner",1), (get_base1(amount_sooner,t,"amount_sooner",1) / (1 + (k * get_base1(delay_sooner,t,"delay_sooner",1)))));
            }

            // validate transformed parameters

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < Tsubj; ++k_0__) {
            vars__.push_back(ev_later[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < Tsubj; ++k_0__) {
            vars__.push_back(ev_sooner[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double logK(0.0);
            (void) logK;  // dummy to suppress unused var warning

            stan::math::initialize(logK, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(logK,DUMMY_VAR__);
            double log_lik(0.0);
            (void) log_lik;  // dummy to suppress unused var warning

            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "Tsubj", Tsubj);
            vector<double> y_pred(Tsubj, 0.0);
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            stan::math::assign(logK, log(k));

            stan::math::assign(log_lik, 0);
            for (int t = 1; t <= Tsubj; ++t) {

                stan::math::assign(log_lik, (log_lik + bernoulli_logit_log(get_base1(choice,t,"choice",1),(beta * (get_base1(ev_later,t,"ev_later",1) - get_base1(ev_sooner,t,"ev_sooner",1))))));
                stan::math::assign(get_base1_lhs(y_pred,t,"y_pred",1), bernoulli_rng(inv_logit((beta * (get_base1(ev_later,t,"ev_later",1) - get_base1(ev_sooner,t,"ev_sooner",1)))), base_rng__));
            }

            // validate generated quantities

            // write generated quantities
        vars__.push_back(logK);
        vars__.push_back(log_lik);
            for (int k_0__ = 0; k_0__ < Tsubj; ++k_0__) {
            vars__.push_back(y_pred[k_0__]);
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_dd_hyperbolic_single";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "k";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_later" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_sooner" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "logK";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "y_pred" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "k";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_later" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_sooner" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "logK";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "y_pred" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m1_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m1");
    reader.add_event(131, 131, "end", "model_gng_m1");
    return reader;
}

class model_gng_m1 : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m1(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m1(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m1_namespace::model_gng_m1";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m1() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(rho, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),rho_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rho",rho,0);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("rho_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("rho");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_rho");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m1_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(rho, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),rho_pr))));

            // validate transformed parameters
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rho",rho,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_rho, exp(get_base1(mu_p,3,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_rho);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m1";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m1_reg_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m1_reg");
    reader.add_event(141, 141, "end", "model_gng_m1_reg");
    return reader;
}

class model_gng_m1_reg : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m1_reg(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m1_reg(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m1_reg_namespace::model_gng_m1_reg";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m1_reg() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(rho, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),rho_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rho",rho,0);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("rho_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("rho");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_rho");
        names__.push_back("log_lik");
        names__.push_back("Qgo");
        names__.push_back("Qnogo");
        names__.push_back("Wgo");
        names__.push_back("Wnogo");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m1_reg_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(rho, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),rho_pr))));

            // validate transformed parameters
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rho",rho,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("Qgo", "N", N);
            validate_non_negative_index("Qgo", "T", T);
            vector<vector<double> > Qgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qgo,DUMMY_VAR__);
            validate_non_negative_index("Qnogo", "N", N);
            validate_non_negative_index("Qnogo", "T", T);
            vector<vector<double> > Qnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qnogo,DUMMY_VAR__);
            validate_non_negative_index("Wgo", "N", N);
            validate_non_negative_index("Wgo", "T", T);
            vector<vector<double> > Wgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wgo,DUMMY_VAR__);
            validate_non_negative_index("Wnogo", "N", N);
            validate_non_negative_index("Wnogo", "T", T);
            vector<vector<double> > Wnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wnogo,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_rho, exp(get_base1(mu_p,3,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qgo,i,"Qgo",1),t,"Qgo",2), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qnogo,i,"Qnogo",1),t,"Qnogo",2), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wgo,i,"Wgo",1),t,"Wgo",2), get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wnogo,i,"Wnogo",1),t,"Wnogo",2), get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1));
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_rho);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m1_reg";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m2_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m2");
    reader.add_event(142, 142, "end", "model_gng_m2");
    return reader;
}

class model_gng_m2 : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m2(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m2(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m2_namespace::model_gng_m2";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("b_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m2() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("b_pr")))
            throw std::runtime_error("variable b_pr missing");
        vals_r__ = context__.vals_r("b_pr");
        pos__ = 0U;
        validate_non_negative_index("b_pr", "N", N);
        context__.validate_dims("initialization", "b_pr", "vector_d", context__.to_vec(N));
        vector_d b_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            b_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(b_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable b_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  b_pr;
            (void) b_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                b_pr = in__.vector_constrain(N,lp__);
            else
                b_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("b", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, DUMMY_VAR__);
            stan::math::fill(b,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            stan::math::assign(rho, exp(add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),rho_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(b(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rho",rho,0);

            // model body

            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 10.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(cauchy_log<propto__>(get_base1(sigma,3,"sigma",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(sigma,4,"sigma",1), 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(b_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("b_pr");
        names__.push_back("rho_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("b");
        names__.push_back("rho");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_b");
        names__.push_back("mu_rho");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m2_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d b_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("b", "N", N);
            vector_d b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            stan::math::assign(rho, exp(add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),rho_pr))));

            // validate transformed parameters
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rho",rho,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            double mu_b(0.0);
            (void) mu_b;  // dummy to suppress unused var warning

            stan::math::initialize(mu_b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_b,DUMMY_VAR__);
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_b, get_base1(mu_p,3,"mu_p",1));
            stan::math::assign(mu_rho, exp(get_base1(mu_p,4,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_b);
        vars__.push_back(mu_rho);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m2";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m2_reg_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m2_reg");
    reader.add_event(152, 152, "end", "model_gng_m2_reg");
    return reader;
}

class model_gng_m2_reg : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m2_reg(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m2_reg(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m2_reg_namespace::model_gng_m2_reg";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("b_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m2_reg() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("b_pr")))
            throw std::runtime_error("variable b_pr missing");
        vals_r__ = context__.vals_r("b_pr");
        pos__ = 0U;
        validate_non_negative_index("b_pr", "N", N);
        context__.validate_dims("initialization", "b_pr", "vector_d", context__.to_vec(N));
        vector_d b_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            b_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(b_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable b_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  b_pr;
            (void) b_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                b_pr = in__.vector_constrain(N,lp__);
            else
                b_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("b", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, DUMMY_VAR__);
            stan::math::fill(b,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            stan::math::assign(rho, exp(add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),rho_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(b(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rho",rho,0);

            // model body

            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 10.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(cauchy_log<propto__>(get_base1(sigma,3,"sigma",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(sigma,4,"sigma",1), 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(b_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("b_pr");
        names__.push_back("rho_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("b");
        names__.push_back("rho");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_b");
        names__.push_back("mu_rho");
        names__.push_back("log_lik");
        names__.push_back("Qgo");
        names__.push_back("Qnogo");
        names__.push_back("Wgo");
        names__.push_back("Wnogo");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m2_reg_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d b_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("b", "N", N);
            vector_d b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            stan::math::assign(rho, exp(add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),rho_pr))));

            // validate transformed parameters
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rho",rho,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            double mu_b(0.0);
            (void) mu_b;  // dummy to suppress unused var warning

            stan::math::initialize(mu_b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_b,DUMMY_VAR__);
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("Qgo", "N", N);
            validate_non_negative_index("Qgo", "T", T);
            vector<vector<double> > Qgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qgo,DUMMY_VAR__);
            validate_non_negative_index("Qnogo", "N", N);
            validate_non_negative_index("Qnogo", "T", T);
            vector<vector<double> > Qnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qnogo,DUMMY_VAR__);
            validate_non_negative_index("Wgo", "N", N);
            validate_non_negative_index("Wgo", "T", T);
            vector<vector<double> > Wgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wgo,DUMMY_VAR__);
            validate_non_negative_index("Wnogo", "N", N);
            validate_non_negative_index("Wnogo", "T", T);
            vector<vector<double> > Wnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wnogo,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_b, get_base1(mu_p,3,"mu_p",1));
            stan::math::assign(mu_rho, exp(get_base1(mu_p,4,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qgo,i,"Qgo",1),t,"Qgo",2), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qnogo,i,"Qnogo",1),t,"Qnogo",2), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wgo,i,"Wgo",1),t,"Wgo",2), get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wnogo,i,"Wnogo",1),t,"Wnogo",2), get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1));
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_b);
        vars__.push_back(mu_rho);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m2_reg";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m3_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m3");
    reader.add_event(159, 159, "end", "model_gng_m3");
    return reader;
}

class model_gng_m3 : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m3(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m3(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m3_namespace::model_gng_m3";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "5", 5);
            num_params_r__ += 5;
            validate_non_negative_index("sigma", "5", 5);
            num_params_r__ += 5;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("b_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("pi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m3() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "5", 5);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(5));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "5", 5);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(5));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("b_pr")))
            throw std::runtime_error("variable b_pr missing");
        vals_r__ = context__.vals_r("b_pr");
        pos__ = 0U;
        validate_non_negative_index("b_pr", "N", N);
        context__.validate_dims("initialization", "b_pr", "vector_d", context__.to_vec(N));
        vector_d b_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            b_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(b_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable b_pr: ") + e.what());
        }

        if (!(context__.contains_r("pi_pr")))
            throw std::runtime_error("variable pi_pr missing");
        vals_r__ = context__.vals_r("pi_pr");
        pos__ = 0U;
        validate_non_negative_index("pi_pr", "N", N);
        context__.validate_dims("initialization", "pi_pr", "vector_d", context__.to_vec(N));
        vector_d pi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            pi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(pi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable pi_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(5,lp__);
            else
                mu_p = in__.vector_constrain(5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,5,lp__);
            else
                sigma = in__.vector_lb_constrain(0,5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  b_pr;
            (void) b_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                b_pr = in__.vector_constrain(N,lp__);
            else
                b_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi_pr;
            (void) pi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                pi_pr = in__.vector_constrain(N,lp__);
            else
                pi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("b", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, DUMMY_VAR__);
            stan::math::fill(b,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, DUMMY_VAR__);
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            stan::math::assign(rho, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rho_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(b(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rho",rho,0);

            // model body

            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 10.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 10.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,5,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(cauchy_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(3, 4), stan::model::nil_index_list()), "sigma"), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(sigma,5,"sigma",1), 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(b_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(pi_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("sv", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, DUMMY_VAR__);
                stan::math::fill(sv,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                stan::math::assign(sv, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("b_pr");
        names__.push_back("pi_pr");
        names__.push_back("rho_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("b");
        names__.push_back("pi");
        names__.push_back("rho");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_b");
        names__.push_back("mu_pi");
        names__.push_back("mu_rho");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m3_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(5);
        vector_d sigma = in__.vector_lb_constrain(0,5);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d b_pr = in__.vector_constrain(N);
        vector_d pi_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("b", "N", N);
            vector_d b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            vector_d pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            stan::math::assign(rho, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rho_pr))));

            // validate transformed parameters
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rho",rho,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            double mu_b(0.0);
            (void) mu_b;  // dummy to suppress unused var warning

            stan::math::initialize(mu_b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_b,DUMMY_VAR__);
            double mu_pi(0.0);
            (void) mu_pi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_pi,DUMMY_VAR__);
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_b, get_base1(mu_p,3,"mu_p",1));
            stan::math::assign(mu_pi, get_base1(mu_p,4,"mu_p",1));
            stan::math::assign(mu_rho, exp(get_base1(mu_p,5,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("sv", "4", 4);
                vector_d sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sv,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                stan::math::assign(sv, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_b);
        vars__.push_back(mu_pi);
        vars__.push_back(mu_rho);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m3";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m3_reg_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m3_reg");
    reader.add_event(171, 171, "end", "model_gng_m3_reg");
    return reader;
}

class model_gng_m3_reg : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m3_reg(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m3_reg(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m3_reg_namespace::model_gng_m3_reg";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "5", 5);
            num_params_r__ += 5;
            validate_non_negative_index("sigma", "5", 5);
            num_params_r__ += 5;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("b_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("pi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m3_reg() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "5", 5);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(5));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "5", 5);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(5));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("b_pr")))
            throw std::runtime_error("variable b_pr missing");
        vals_r__ = context__.vals_r("b_pr");
        pos__ = 0U;
        validate_non_negative_index("b_pr", "N", N);
        context__.validate_dims("initialization", "b_pr", "vector_d", context__.to_vec(N));
        vector_d b_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            b_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(b_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable b_pr: ") + e.what());
        }

        if (!(context__.contains_r("pi_pr")))
            throw std::runtime_error("variable pi_pr missing");
        vals_r__ = context__.vals_r("pi_pr");
        pos__ = 0U;
        validate_non_negative_index("pi_pr", "N", N);
        context__.validate_dims("initialization", "pi_pr", "vector_d", context__.to_vec(N));
        vector_d pi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            pi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(pi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable pi_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(5,lp__);
            else
                mu_p = in__.vector_constrain(5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,5,lp__);
            else
                sigma = in__.vector_lb_constrain(0,5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  b_pr;
            (void) b_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                b_pr = in__.vector_constrain(N,lp__);
            else
                b_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi_pr;
            (void) pi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                pi_pr = in__.vector_constrain(N,lp__);
            else
                pi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("b", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, DUMMY_VAR__);
            stan::math::fill(b,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, DUMMY_VAR__);
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            stan::math::assign(rho, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rho_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(b(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rho",rho,0);

            // model body

            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 10.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 10.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,5,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(cauchy_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(3, 4), stan::model::nil_index_list()), "sigma"), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(sigma,5,"sigma",1), 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(b_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(pi_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("sv", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, DUMMY_VAR__);
                stan::math::fill(sv,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                stan::math::assign(sv, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("b_pr");
        names__.push_back("pi_pr");
        names__.push_back("rho_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("b");
        names__.push_back("pi");
        names__.push_back("rho");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_b");
        names__.push_back("mu_pi");
        names__.push_back("mu_rho");
        names__.push_back("log_lik");
        names__.push_back("Qgo");
        names__.push_back("Qnogo");
        names__.push_back("Wgo");
        names__.push_back("Wnogo");
        names__.push_back("SV");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m3_reg_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(5);
        vector_d sigma = in__.vector_lb_constrain(0,5);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d b_pr = in__.vector_constrain(N);
        vector_d pi_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("b", "N", N);
            vector_d b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            vector_d pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            stan::math::assign(rho, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rho_pr))));

            // validate transformed parameters
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rho",rho,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            double mu_b(0.0);
            (void) mu_b;  // dummy to suppress unused var warning

            stan::math::initialize(mu_b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_b,DUMMY_VAR__);
            double mu_pi(0.0);
            (void) mu_pi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_pi,DUMMY_VAR__);
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("Qgo", "N", N);
            validate_non_negative_index("Qgo", "T", T);
            vector<vector<double> > Qgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qgo,DUMMY_VAR__);
            validate_non_negative_index("Qnogo", "N", N);
            validate_non_negative_index("Qnogo", "T", T);
            vector<vector<double> > Qnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qnogo,DUMMY_VAR__);
            validate_non_negative_index("Wgo", "N", N);
            validate_non_negative_index("Wgo", "T", T);
            vector<vector<double> > Wgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wgo,DUMMY_VAR__);
            validate_non_negative_index("Wnogo", "N", N);
            validate_non_negative_index("Wnogo", "T", T);
            vector<vector<double> > Wnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wnogo,DUMMY_VAR__);
            validate_non_negative_index("SV", "N", N);
            validate_non_negative_index("SV", "T", T);
            vector<vector<double> > SV(N, (vector<double>(T, 0.0)));
            stan::math::initialize(SV, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(SV,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_b, get_base1(mu_p,3,"mu_p",1));
            stan::math::assign(mu_pi, get_base1(mu_p,4,"mu_p",1));
            stan::math::assign(mu_rho, exp(get_base1(mu_p,5,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("sv", "4", 4);
                vector_d sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sv,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                stan::math::assign(sv, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qgo,i,"Qgo",1),t,"Qgo",2), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qnogo,i,"Qnogo",1),t,"Qnogo",2), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wgo,i,"Wgo",1),t,"Wgo",2), get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wnogo,i,"Wnogo",1),t,"Wnogo",2), get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(SV,i,"SV",1),t,"SV",2), get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1));
                    stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_b);
        vars__.push_back(mu_pi);
        vars__.push_back(mu_rho);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(SV[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m3_reg";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "SV" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "SV" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m4_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m4");
    reader.add_event(190, 190, "end", "model_gng_m4");
    return reader;
}

class model_gng_m4 : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m4(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m4(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m4_namespace::model_gng_m4";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "6", 6);
            num_params_r__ += 6;
            validate_non_negative_index("sigma", "6", 6);
            num_params_r__ += 6;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("b_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("pi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("rhoRew_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("rhoPun_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m4() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "6", 6);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(6));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(6));
        for (int j1__ = 0U; j1__ < 6; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "6", 6);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(6));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(6));
        for (int j1__ = 0U; j1__ < 6; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("b_pr")))
            throw std::runtime_error("variable b_pr missing");
        vals_r__ = context__.vals_r("b_pr");
        pos__ = 0U;
        validate_non_negative_index("b_pr", "N", N);
        context__.validate_dims("initialization", "b_pr", "vector_d", context__.to_vec(N));
        vector_d b_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            b_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(b_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable b_pr: ") + e.what());
        }

        if (!(context__.contains_r("pi_pr")))
            throw std::runtime_error("variable pi_pr missing");
        vals_r__ = context__.vals_r("pi_pr");
        pos__ = 0U;
        validate_non_negative_index("pi_pr", "N", N);
        context__.validate_dims("initialization", "pi_pr", "vector_d", context__.to_vec(N));
        vector_d pi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            pi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(pi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable pi_pr: ") + e.what());
        }

        if (!(context__.contains_r("rhoRew_pr")))
            throw std::runtime_error("variable rhoRew_pr missing");
        vals_r__ = context__.vals_r("rhoRew_pr");
        pos__ = 0U;
        validate_non_negative_index("rhoRew_pr", "N", N);
        context__.validate_dims("initialization", "rhoRew_pr", "vector_d", context__.to_vec(N));
        vector_d rhoRew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rhoRew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rhoRew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rhoRew_pr: ") + e.what());
        }

        if (!(context__.contains_r("rhoPun_pr")))
            throw std::runtime_error("variable rhoPun_pr missing");
        vals_r__ = context__.vals_r("rhoPun_pr");
        pos__ = 0U;
        validate_non_negative_index("rhoPun_pr", "N", N);
        context__.validate_dims("initialization", "rhoPun_pr", "vector_d", context__.to_vec(N));
        vector_d rhoPun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rhoPun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rhoPun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rhoPun_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(6,lp__);
            else
                mu_p = in__.vector_constrain(6);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,6,lp__);
            else
                sigma = in__.vector_lb_constrain(0,6);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  b_pr;
            (void) b_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                b_pr = in__.vector_constrain(N,lp__);
            else
                b_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi_pr;
            (void) pi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                pi_pr = in__.vector_constrain(N,lp__);
            else
                pi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoRew_pr;
            (void) rhoRew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rhoRew_pr = in__.vector_constrain(N,lp__);
            else
                rhoRew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoPun_pr;
            (void) rhoPun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rhoPun_pr = in__.vector_constrain(N,lp__);
            else
                rhoPun_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("b", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, DUMMY_VAR__);
            stan::math::fill(b,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, DUMMY_VAR__);
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("rhoRew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoRew(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoRew;  // dummy to suppress unused var warning

            stan::math::initialize(rhoRew, DUMMY_VAR__);
            stan::math::fill(rhoRew,DUMMY_VAR__);
            validate_non_negative_index("rhoPun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoPun(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoPun;  // dummy to suppress unused var warning

            stan::math::initialize(rhoPun, DUMMY_VAR__);
            stan::math::fill(rhoPun,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            stan::math::assign(rhoRew, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rhoRew_pr))));
            stan::math::assign(rhoPun, exp(add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),rhoPun_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(b(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rhoRew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rhoRew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rhoPun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rhoPun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rhoRew",rhoRew,0);
            check_greater_or_equal(function__,"rhoPun",rhoPun,0);

            // model body

            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 10.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 10.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,5,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,6,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(cauchy_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(3, 4), stan::model::nil_index_list()), "sigma"), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(5, 6), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(b_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(pi_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(rhoRew_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(rhoPun_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("sv", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, DUMMY_VAR__);
                stan::math::fill(sv,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                stan::math::assign(sv, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    }
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        } else {

                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        }
                    } else {

                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        } else {

                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        }
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("b_pr");
        names__.push_back("pi_pr");
        names__.push_back("rhoRew_pr");
        names__.push_back("rhoPun_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("b");
        names__.push_back("pi");
        names__.push_back("rhoRew");
        names__.push_back("rhoPun");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_b");
        names__.push_back("mu_pi");
        names__.push_back("mu_rhoRew");
        names__.push_back("mu_rhoPun");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(6);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(6);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m4_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(6);
        vector_d sigma = in__.vector_lb_constrain(0,6);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d b_pr = in__.vector_constrain(N);
        vector_d pi_pr = in__.vector_constrain(N);
        vector_d rhoRew_pr = in__.vector_constrain(N);
        vector_d rhoPun_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 6; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 6; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoRew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoPun_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("b", "N", N);
            vector_d b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            vector_d pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("rhoRew", "N", N);
            vector_d rhoRew(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoRew;  // dummy to suppress unused var warning

            stan::math::initialize(rhoRew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rhoRew,DUMMY_VAR__);
            validate_non_negative_index("rhoPun", "N", N);
            vector_d rhoPun(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoPun;  // dummy to suppress unused var warning

            stan::math::initialize(rhoPun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rhoPun,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            stan::math::assign(rhoRew, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rhoRew_pr))));
            stan::math::assign(rhoPun, exp(add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),rhoPun_pr))));

            // validate transformed parameters
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rhoRew",rhoRew,0);
            check_greater_or_equal(function__,"rhoPun",rhoPun,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoRew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoPun[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            double mu_b(0.0);
            (void) mu_b;  // dummy to suppress unused var warning

            stan::math::initialize(mu_b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_b,DUMMY_VAR__);
            double mu_pi(0.0);
            (void) mu_pi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_pi,DUMMY_VAR__);
            double mu_rhoRew(0.0);
            (void) mu_rhoRew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rhoRew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rhoRew,DUMMY_VAR__);
            double mu_rhoPun(0.0);
            (void) mu_rhoPun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rhoPun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rhoPun,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_b, get_base1(mu_p,3,"mu_p",1));
            stan::math::assign(mu_pi, get_base1(mu_p,4,"mu_p",1));
            stan::math::assign(mu_rhoRew, exp(get_base1(mu_p,5,"mu_p",1)));
            stan::math::assign(mu_rhoPun, exp(get_base1(mu_p,6,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("sv", "4", 4);
                vector_d sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sv,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                stan::math::assign(sv, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    }
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        } else {

                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        }
                    } else {

                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        } else {

                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        }
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            check_greater_or_equal(function__,"mu_rhoRew",mu_rhoRew,0);
            check_greater_or_equal(function__,"mu_rhoPun",mu_rhoPun,0);

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_b);
        vars__.push_back(mu_pi);
        vars__.push_back(mu_rhoRew);
        vars__.push_back(mu_rhoPun);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m4";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoRew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoPun";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoRew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoPun";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m4_reg_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m4_reg");
    reader.add_event(202, 202, "end", "model_gng_m4_reg");
    return reader;
}

class model_gng_m4_reg : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m4_reg(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m4_reg(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m4_reg_namespace::model_gng_m4_reg";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "6", 6);
            num_params_r__ += 6;
            validate_non_negative_index("sigma", "6", 6);
            num_params_r__ += 6;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("b_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("pi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("rhoRew_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("rhoPun_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m4_reg() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "6", 6);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(6));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(6));
        for (int j1__ = 0U; j1__ < 6; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "6", 6);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(6));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(6));
        for (int j1__ = 0U; j1__ < 6; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("b_pr")))
            throw std::runtime_error("variable b_pr missing");
        vals_r__ = context__.vals_r("b_pr");
        pos__ = 0U;
        validate_non_negative_index("b_pr", "N", N);
        context__.validate_dims("initialization", "b_pr", "vector_d", context__.to_vec(N));
        vector_d b_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            b_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(b_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable b_pr: ") + e.what());
        }

        if (!(context__.contains_r("pi_pr")))
            throw std::runtime_error("variable pi_pr missing");
        vals_r__ = context__.vals_r("pi_pr");
        pos__ = 0U;
        validate_non_negative_index("pi_pr", "N", N);
        context__.validate_dims("initialization", "pi_pr", "vector_d", context__.to_vec(N));
        vector_d pi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            pi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(pi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable pi_pr: ") + e.what());
        }

        if (!(context__.contains_r("rhoRew_pr")))
            throw std::runtime_error("variable rhoRew_pr missing");
        vals_r__ = context__.vals_r("rhoRew_pr");
        pos__ = 0U;
        validate_non_negative_index("rhoRew_pr", "N", N);
        context__.validate_dims("initialization", "rhoRew_pr", "vector_d", context__.to_vec(N));
        vector_d rhoRew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rhoRew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rhoRew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rhoRew_pr: ") + e.what());
        }

        if (!(context__.contains_r("rhoPun_pr")))
            throw std::runtime_error("variable rhoPun_pr missing");
        vals_r__ = context__.vals_r("rhoPun_pr");
        pos__ = 0U;
        validate_non_negative_index("rhoPun_pr", "N", N);
        context__.validate_dims("initialization", "rhoPun_pr", "vector_d", context__.to_vec(N));
        vector_d rhoPun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rhoPun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rhoPun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rhoPun_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(6,lp__);
            else
                mu_p = in__.vector_constrain(6);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,6,lp__);
            else
                sigma = in__.vector_lb_constrain(0,6);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  b_pr;
            (void) b_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                b_pr = in__.vector_constrain(N,lp__);
            else
                b_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi_pr;
            (void) pi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                pi_pr = in__.vector_constrain(N,lp__);
            else
                pi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoRew_pr;
            (void) rhoRew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rhoRew_pr = in__.vector_constrain(N,lp__);
            else
                rhoRew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoPun_pr;
            (void) rhoPun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rhoPun_pr = in__.vector_constrain(N,lp__);
            else
                rhoPun_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("b", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, DUMMY_VAR__);
            stan::math::fill(b,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, DUMMY_VAR__);
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("rhoRew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoRew(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoRew;  // dummy to suppress unused var warning

            stan::math::initialize(rhoRew, DUMMY_VAR__);
            stan::math::fill(rhoRew,DUMMY_VAR__);
            validate_non_negative_index("rhoPun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoPun(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoPun;  // dummy to suppress unused var warning

            stan::math::initialize(rhoPun, DUMMY_VAR__);
            stan::math::fill(rhoPun,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            stan::math::assign(rhoRew, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rhoRew_pr))));
            stan::math::assign(rhoPun, exp(add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),rhoPun_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(b(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rhoRew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rhoRew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rhoPun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rhoPun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rhoRew",rhoRew,0);
            check_greater_or_equal(function__,"rhoPun",rhoPun,0);

            // model body

            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 10.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 10.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,5,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,6,"mu_p",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(cauchy_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(3, 4), stan::model::nil_index_list()), "sigma"), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(5, 6), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(b_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(pi_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(rhoRew_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(rhoPun_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("sv", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, DUMMY_VAR__);
                stan::math::fill(sv,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                stan::math::assign(sv, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    }
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        } else {

                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        }
                    } else {

                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        } else {

                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        }
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("b_pr");
        names__.push_back("pi_pr");
        names__.push_back("rhoRew_pr");
        names__.push_back("rhoPun_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("b");
        names__.push_back("pi");
        names__.push_back("rhoRew");
        names__.push_back("rhoPun");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_b");
        names__.push_back("mu_pi");
        names__.push_back("mu_rhoRew");
        names__.push_back("mu_rhoPun");
        names__.push_back("log_lik");
        names__.push_back("Qgo");
        names__.push_back("Qnogo");
        names__.push_back("Wgo");
        names__.push_back("Wnogo");
        names__.push_back("SV");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(6);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(6);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m4_reg_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(6);
        vector_d sigma = in__.vector_lb_constrain(0,6);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d b_pr = in__.vector_constrain(N);
        vector_d pi_pr = in__.vector_constrain(N);
        vector_d rhoRew_pr = in__.vector_constrain(N);
        vector_d rhoPun_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 6; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 6; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoRew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoPun_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("b", "N", N);
            vector_d b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            vector_d pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("rhoRew", "N", N);
            vector_d rhoRew(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoRew;  // dummy to suppress unused var warning

            stan::math::initialize(rhoRew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rhoRew,DUMMY_VAR__);
            validate_non_negative_index("rhoPun", "N", N);
            vector_d rhoPun(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoPun;  // dummy to suppress unused var warning

            stan::math::initialize(rhoPun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rhoPun,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            stan::math::assign(rhoRew, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rhoRew_pr))));
            stan::math::assign(rhoPun, exp(add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),rhoPun_pr))));

            // validate transformed parameters
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            check_greater_or_equal(function__,"rhoRew",rhoRew,0);
            check_greater_or_equal(function__,"rhoPun",rhoPun,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoRew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoPun[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            double mu_b(0.0);
            (void) mu_b;  // dummy to suppress unused var warning

            stan::math::initialize(mu_b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_b,DUMMY_VAR__);
            double mu_pi(0.0);
            (void) mu_pi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_pi,DUMMY_VAR__);
            double mu_rhoRew(0.0);
            (void) mu_rhoRew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rhoRew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rhoRew,DUMMY_VAR__);
            double mu_rhoPun(0.0);
            (void) mu_rhoPun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rhoPun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rhoPun,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("Qgo", "N", N);
            validate_non_negative_index("Qgo", "T", T);
            vector<vector<double> > Qgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qgo,DUMMY_VAR__);
            validate_non_negative_index("Qnogo", "N", N);
            validate_non_negative_index("Qnogo", "T", T);
            vector<vector<double> > Qnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qnogo,DUMMY_VAR__);
            validate_non_negative_index("Wgo", "N", N);
            validate_non_negative_index("Wgo", "T", T);
            vector<vector<double> > Wgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wgo,DUMMY_VAR__);
            validate_non_negative_index("Wnogo", "N", N);
            validate_non_negative_index("Wnogo", "T", T);
            vector<vector<double> > Wnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wnogo,DUMMY_VAR__);
            validate_non_negative_index("SV", "N", N);
            validate_non_negative_index("SV", "T", T);
            vector<vector<double> > SV(N, (vector<double>(T, 0.0)));
            stan::math::initialize(SV, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(SV,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_b, get_base1(mu_p,3,"mu_p",1));
            stan::math::assign(mu_pi, get_base1(mu_p,4,"mu_p",1));
            stan::math::assign(mu_rhoRew, exp(get_base1(mu_p,5,"mu_p",1)));
            stan::math::assign(mu_rhoPun, exp(get_base1(mu_p,6,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                validate_non_negative_index("sv", "4", 4);
                vector_d sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sv,DUMMY_VAR__);
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                stan::math::assign(wv_g, initV);
                stan::math::assign(wv_ng, initV);
                stan::math::assign(qv_g, initV);
                stan::math::assign(qv_ng, initV);
                stan::math::assign(sv, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qgo,i,"Qgo",1),t,"Qgo",2), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qnogo,i,"Qnogo",1),t,"Qnogo",2), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wgo,i,"Wgo",1),t,"Wgo",2), get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wnogo,i,"Wnogo",1),t,"Wnogo",2), get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(SV,i,"SV",1),t,"SV",2), get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1));
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    } else {

                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    }
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        } else {

                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        }
                    } else {

                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        } else {

                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        }
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            check_greater_or_equal(function__,"mu_rhoRew",mu_rhoRew,0);
            check_greater_or_equal(function__,"mu_rhoPun",mu_rhoPun,0);

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_b);
        vars__.push_back(mu_pi);
        vars__.push_back(mu_rhoRew);
        vars__.push_back(mu_rhoPun);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(SV[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m4_reg";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoRew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoPun";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "SV" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoRew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoPun";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "SV" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_igt_orl_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_igt_orl");
    reader.add_event(204, 204, "end", "model_igt_orl");
    return reader;
}

class model_igt_orl : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<double> > sign_out;
    vector<vector<int> > choice;
    vector_d initV;
public:
    model_igt_orl(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_igt_orl(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_igt_orl_namespace::model_igt_orl";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("sign_out", "N", N);
            validate_non_negative_index("sign_out", "T", T);
            context__.validate_dims("data initialization", "sign_out", "double", context__.to_vec(N,T));
            validate_non_negative_index("sign_out", "N", N);
            validate_non_negative_index("sign_out", "T", T);
            sign_out = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("sign_out");
            pos__ = 0;
            size_t sign_out_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < sign_out_limit_1__; ++i_1__) {
                size_t sign_out_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < sign_out_limit_0__; ++i_0__) {
                    sign_out[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "5", 5);
            num_params_r__ += 5;
            validate_non_negative_index("sigma", "5", 5);
            num_params_r__ += 5;
            validate_non_negative_index("Arew_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("Apun_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("K_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("betaF_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("betaP_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_igt_orl() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "5", 5);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(5));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "5", 5);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(5));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("Arew_pr")))
            throw std::runtime_error("variable Arew_pr missing");
        vals_r__ = context__.vals_r("Arew_pr");
        pos__ = 0U;
        validate_non_negative_index("Arew_pr", "N", N);
        context__.validate_dims("initialization", "Arew_pr", "vector_d", context__.to_vec(N));
        vector_d Arew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Arew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Arew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Arew_pr: ") + e.what());
        }

        if (!(context__.contains_r("Apun_pr")))
            throw std::runtime_error("variable Apun_pr missing");
        vals_r__ = context__.vals_r("Apun_pr");
        pos__ = 0U;
        validate_non_negative_index("Apun_pr", "N", N);
        context__.validate_dims("initialization", "Apun_pr", "vector_d", context__.to_vec(N));
        vector_d Apun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Apun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Apun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Apun_pr: ") + e.what());
        }

        if (!(context__.contains_r("K_pr")))
            throw std::runtime_error("variable K_pr missing");
        vals_r__ = context__.vals_r("K_pr");
        pos__ = 0U;
        validate_non_negative_index("K_pr", "N", N);
        context__.validate_dims("initialization", "K_pr", "vector_d", context__.to_vec(N));
        vector_d K_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            K_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(K_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable K_pr: ") + e.what());
        }

        if (!(context__.contains_r("betaF_pr")))
            throw std::runtime_error("variable betaF_pr missing");
        vals_r__ = context__.vals_r("betaF_pr");
        pos__ = 0U;
        validate_non_negative_index("betaF_pr", "N", N);
        context__.validate_dims("initialization", "betaF_pr", "vector_d", context__.to_vec(N));
        vector_d betaF_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            betaF_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(betaF_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable betaF_pr: ") + e.what());
        }

        if (!(context__.contains_r("betaP_pr")))
            throw std::runtime_error("variable betaP_pr missing");
        vals_r__ = context__.vals_r("betaP_pr");
        pos__ = 0U;
        validate_non_negative_index("betaP_pr", "N", N);
        context__.validate_dims("initialization", "betaP_pr", "vector_d", context__.to_vec(N));
        vector_d betaP_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            betaP_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(betaP_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable betaP_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(5,lp__);
            else
                mu_p = in__.vector_constrain(5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,5,lp__);
            else
                sigma = in__.vector_lb_constrain(0,5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew_pr;
            (void) Arew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Arew_pr = in__.vector_constrain(N,lp__);
            else
                Arew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun_pr;
            (void) Apun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Apun_pr = in__.vector_constrain(N,lp__);
            else
                Apun_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  K_pr;
            (void) K_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                K_pr = in__.vector_constrain(N,lp__);
            else
                K_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  betaF_pr;
            (void) betaF_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                betaF_pr = in__.vector_constrain(N,lp__);
            else
                betaF_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  betaP_pr;
            (void) betaP_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                betaP_pr = in__.vector_constrain(N,lp__);
            else
                betaP_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("Arew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, DUMMY_VAR__);
            stan::math::fill(Arew,DUMMY_VAR__);
            validate_non_negative_index("Apun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, DUMMY_VAR__);
            stan::math::fill(Apun,DUMMY_VAR__);
            validate_non_negative_index("K", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  K(static_cast<Eigen::VectorXd::Index>(N));
            (void) K;  // dummy to suppress unused var warning

            stan::math::initialize(K, DUMMY_VAR__);
            stan::math::fill(K,DUMMY_VAR__);
            validate_non_negative_index("betaF", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  betaF(static_cast<Eigen::VectorXd::Index>(N));
            (void) betaF;  // dummy to suppress unused var warning

            stan::math::initialize(betaF, DUMMY_VAR__);
            stan::math::fill(betaF,DUMMY_VAR__);
            validate_non_negative_index("betaP", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  betaP(static_cast<Eigen::VectorXd::Index>(N));
            (void) betaP;  // dummy to suppress unused var warning

            stan::math::initialize(betaP, DUMMY_VAR__);
            stan::math::fill(betaP,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                stan::math::assign(get_base1_lhs(K,i,"K",1), (Phi_approx(((get_base1(mu_p,3,"mu_p",1) + get_base1(sigma,3,"sigma",1)) + get_base1(K_pr,i,"K_pr",1))) * 5));
            }
            stan::math::assign(betaF, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),betaF_pr)));
            stan::math::assign(betaP, add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),betaP_pr)));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Arew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Arew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Apun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Apun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(K(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: K" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(betaF(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: betaF" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(betaP(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: betaP" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            check_greater_or_equal(function__,"K",K,0);
            check_less_or_equal(function__,"K",K,5);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(cauchy_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(4, 5), stan::model::nil_index_list()), "sigma"), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(Arew_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(Apun_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(K_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(betaF_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(betaP_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ef", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ef(static_cast<Eigen::VectorXd::Index>(4));
                (void) ef;  // dummy to suppress unused var warning

                stan::math::initialize(ef, DUMMY_VAR__);
                stan::math::fill(ef,DUMMY_VAR__);
                validate_non_negative_index("ev", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("PEfreq_fic", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  PEfreq_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEfreq_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEfreq_fic, DUMMY_VAR__);
                stan::math::fill(PEfreq_fic,DUMMY_VAR__);
                validate_non_negative_index("PEval_fic", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  PEval_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEval_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEval_fic, DUMMY_VAR__);
                stan::math::fill(PEval_fic,DUMMY_VAR__);
                validate_non_negative_index("pers", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pers(static_cast<Eigen::VectorXd::Index>(4));
                (void) pers;  // dummy to suppress unused var warning

                stan::math::initialize(pers, DUMMY_VAR__);
                stan::math::fill(pers,DUMMY_VAR__);
                validate_non_negative_index("util", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  util(static_cast<Eigen::VectorXd::Index>(4));
                (void) util;  // dummy to suppress unused var warning

                stan::math::initialize(util, DUMMY_VAR__);
                stan::math::fill(util,DUMMY_VAR__);
                T__ PEval;
                (void) PEval;  // dummy to suppress unused var warning

                stan::math::initialize(PEval, DUMMY_VAR__);
                stan::math::fill(PEval,DUMMY_VAR__);
                T__ PEfreq;
                (void) PEfreq;  // dummy to suppress unused var warning

                stan::math::initialize(PEfreq, DUMMY_VAR__);
                stan::math::fill(PEfreq,DUMMY_VAR__);
                T__ efChosen;
                (void) efChosen;  // dummy to suppress unused var warning

                stan::math::initialize(efChosen, DUMMY_VAR__);
                stan::math::fill(efChosen,DUMMY_VAR__);
                T__ evChosen;
                (void) evChosen;  // dummy to suppress unused var warning

                stan::math::initialize(evChosen, DUMMY_VAR__);
                stan::math::fill(evChosen,DUMMY_VAR__);
                T__ K_tr;
                (void) K_tr;  // dummy to suppress unused var warning

                stan::math::initialize(K_tr, DUMMY_VAR__);
                stan::math::fill(K_tr,DUMMY_VAR__);


                stan::math::assign(ef, initV);
                stan::math::assign(ev, initV);
                stan::math::assign(pers, initV);
                stan::math::assign(util, initV);
                stan::math::assign(K_tr, (pow(3,get_base1(K,i,"K",1)) - 1));
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), util));
                    stan::math::assign(PEval, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(PEfreq, (get_base1(get_base1(sign_out,i,"sign_out",1),t,"sign_out",2) - get_base1(ef,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ef",1)));
                    stan::math::assign(PEfreq_fic, subtract((-(get_base1(get_base1(sign_out,i,"sign_out",1),t,"sign_out",2)) / 3),ef));
                    stan::math::assign(efChosen, get_base1(ef,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ef",1));
                    stan::math::assign(evChosen, get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1));
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        stan::math::assign(ef, add(ef,multiply(get_base1(Apun,i,"Apun",1),PEfreq_fic)));
                        stan::math::assign(get_base1_lhs(ef,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ef",1), (efChosen + (get_base1(Arew,i,"Arew",1) * PEfreq)));
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (evChosen + (get_base1(Arew,i,"Arew",1) * PEval)));
                    } else {

                        stan::math::assign(ef, add(ef,multiply(get_base1(Arew,i,"Arew",1),PEfreq_fic)));
                        stan::math::assign(get_base1_lhs(ef,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ef",1), (efChosen + (get_base1(Apun,i,"Apun",1) * PEfreq)));
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (evChosen + (get_base1(Apun,i,"Apun",1) * PEval)));
                    }
                    stan::math::assign(get_base1_lhs(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1), 1);
                    stan::math::assign(pers, divide(pers,(1 + K_tr)));
                    stan::math::assign(util, add(add(ev,multiply(ef,get_base1(betaF,i,"betaF",1))),multiply(pers,get_base1(betaP,i,"betaP",1))));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("Arew_pr");
        names__.push_back("Apun_pr");
        names__.push_back("K_pr");
        names__.push_back("betaF_pr");
        names__.push_back("betaP_pr");
        names__.push_back("Arew");
        names__.push_back("Apun");
        names__.push_back("K");
        names__.push_back("betaF");
        names__.push_back("betaP");
        names__.push_back("mu_Arew");
        names__.push_back("mu_Apun");
        names__.push_back("mu_K");
        names__.push_back("mu_betaF");
        names__.push_back("mu_betaP");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_igt_orl_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(5);
        vector_d sigma = in__.vector_lb_constrain(0,5);
        vector_d Arew_pr = in__.vector_constrain(N);
        vector_d Apun_pr = in__.vector_constrain(N);
        vector_d K_pr = in__.vector_constrain(N);
        vector_d betaF_pr = in__.vector_constrain(N);
        vector_d betaP_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(K_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(betaF_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(betaP_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("Arew", "N", N);
            vector_d Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Arew,DUMMY_VAR__);
            validate_non_negative_index("Apun", "N", N);
            vector_d Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Apun,DUMMY_VAR__);
            validate_non_negative_index("K", "N", N);
            vector_d K(static_cast<Eigen::VectorXd::Index>(N));
            (void) K;  // dummy to suppress unused var warning

            stan::math::initialize(K, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(K,DUMMY_VAR__);
            validate_non_negative_index("betaF", "N", N);
            vector_d betaF(static_cast<Eigen::VectorXd::Index>(N));
            (void) betaF;  // dummy to suppress unused var warning

            stan::math::initialize(betaF, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(betaF,DUMMY_VAR__);
            validate_non_negative_index("betaP", "N", N);
            vector_d betaP(static_cast<Eigen::VectorXd::Index>(N));
            (void) betaP;  // dummy to suppress unused var warning

            stan::math::initialize(betaP, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(betaP,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                stan::math::assign(get_base1_lhs(K,i,"K",1), (Phi_approx(((get_base1(mu_p,3,"mu_p",1) + get_base1(sigma,3,"sigma",1)) + get_base1(K_pr,i,"K_pr",1))) * 5));
            }
            stan::math::assign(betaF, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),betaF_pr)));
            stan::math::assign(betaP, add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),betaP_pr)));

            // validate transformed parameters
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            check_greater_or_equal(function__,"K",K,0);
            check_less_or_equal(function__,"K",K,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(K[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(betaF[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(betaP[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_Arew(0.0);
            (void) mu_Arew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Arew,DUMMY_VAR__);
            double mu_Apun(0.0);
            (void) mu_Apun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Apun,DUMMY_VAR__);
            double mu_K(0.0);
            (void) mu_K;  // dummy to suppress unused var warning

            stan::math::initialize(mu_K, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_K,DUMMY_VAR__);
            double mu_betaF(0.0);
            (void) mu_betaF;  // dummy to suppress unused var warning

            stan::math::initialize(mu_betaF, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_betaF,DUMMY_VAR__);
            double mu_betaP(0.0);
            (void) mu_betaP;  // dummy to suppress unused var warning

            stan::math::initialize(mu_betaP, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_betaP,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_Arew, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_Apun, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_K, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));
            stan::math::assign(mu_betaF, get_base1(mu_p,4,"mu_p",1));
            stan::math::assign(mu_betaP, get_base1(mu_p,5,"mu_p",1));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ef", "4", 4);
                vector_d ef(static_cast<Eigen::VectorXd::Index>(4));
                (void) ef;  // dummy to suppress unused var warning

                stan::math::initialize(ef, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ef,DUMMY_VAR__);
                validate_non_negative_index("ev", "4", 4);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("PEfreq_fic", "4", 4);
                vector_d PEfreq_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEfreq_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEfreq_fic, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEfreq_fic,DUMMY_VAR__);
                validate_non_negative_index("PEval_fic", "4", 4);
                vector_d PEval_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEval_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEval_fic, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEval_fic,DUMMY_VAR__);
                validate_non_negative_index("pers", "4", 4);
                vector_d pers(static_cast<Eigen::VectorXd::Index>(4));
                (void) pers;  // dummy to suppress unused var warning

                stan::math::initialize(pers, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pers,DUMMY_VAR__);
                validate_non_negative_index("util", "4", 4);
                vector_d util(static_cast<Eigen::VectorXd::Index>(4));
                (void) util;  // dummy to suppress unused var warning

                stan::math::initialize(util, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(util,DUMMY_VAR__);
                double PEval(0.0);
                (void) PEval;  // dummy to suppress unused var warning

                stan::math::initialize(PEval, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEval,DUMMY_VAR__);
                double PEfreq(0.0);
                (void) PEfreq;  // dummy to suppress unused var warning

                stan::math::initialize(PEfreq, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEfreq,DUMMY_VAR__);
                double efChosen(0.0);
                (void) efChosen;  // dummy to suppress unused var warning

                stan::math::initialize(efChosen, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(efChosen,DUMMY_VAR__);
                double evChosen(0.0);
                (void) evChosen;  // dummy to suppress unused var warning

                stan::math::initialize(evChosen, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(evChosen,DUMMY_VAR__);
                double K_tr(0.0);
                (void) K_tr;  // dummy to suppress unused var warning

                stan::math::initialize(K_tr, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(K_tr,DUMMY_VAR__);


                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                stan::math::assign(ef, initV);
                stan::math::assign(ev, initV);
                stan::math::assign(pers, initV);
                stan::math::assign(util, initV);
                stan::math::assign(K_tr, (pow(3,get_base1(K,i,"K",1)) - 1));
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),util)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(util), base_rng__));
                    stan::math::assign(PEval, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(PEfreq, (get_base1(get_base1(sign_out,i,"sign_out",1),t,"sign_out",2) - get_base1(ef,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ef",1)));
                    stan::math::assign(PEfreq_fic, subtract((-(get_base1(get_base1(sign_out,i,"sign_out",1),t,"sign_out",2)) / 3),ef));
                    stan::math::assign(efChosen, get_base1(ef,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ef",1));
                    stan::math::assign(evChosen, get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1));
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        stan::math::assign(ef, add(ef,multiply(get_base1(Apun,i,"Apun",1),PEfreq_fic)));
                        stan::math::assign(get_base1_lhs(ef,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ef",1), (efChosen + (get_base1(Arew,i,"Arew",1) * PEfreq)));
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (evChosen + (get_base1(Arew,i,"Arew",1) * PEval)));
                    } else {

                        stan::math::assign(ef, add(ef,multiply(get_base1(Arew,i,"Arew",1),PEfreq_fic)));
                        stan::math::assign(get_base1_lhs(ef,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ef",1), (efChosen + (get_base1(Apun,i,"Apun",1) * PEfreq)));
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (evChosen + (get_base1(Apun,i,"Apun",1) * PEval)));
                    }
                    stan::math::assign(get_base1_lhs(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1), 1);
                    stan::math::assign(pers, divide(pers,(1 + K_tr)));
                    stan::math::assign(util, add(add(ev,multiply(ef,get_base1(betaF,i,"betaF",1))),multiply(pers,get_base1(betaP,i,"betaP",1))));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_Arew",mu_Arew,0);
            check_less_or_equal(function__,"mu_Arew",mu_Arew,1);
            check_greater_or_equal(function__,"mu_Apun",mu_Apun,0);
            check_less_or_equal(function__,"mu_Apun",mu_Apun,1);
            check_greater_or_equal(function__,"mu_K",mu_K,0);
            check_less_or_equal(function__,"mu_K",mu_K,5);

            // write generated quantities
        vars__.push_back(mu_Arew);
        vars__.push_back(mu_Apun);
        vars__.push_back(mu_K);
        vars__.push_back(mu_betaF);
        vars__.push_back(mu_betaP);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_igt_orl";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "K_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "betaF_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "betaP_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "K" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "betaF" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "betaP" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_K";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_betaF";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_betaP";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "K_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "betaF_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "betaP_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "K" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "betaF" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "betaP" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_K";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_betaF";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_betaP";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_igt_pvl_decay_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_igt_pvl_decay");
    reader.add_event(131, 131, "end", "model_igt_pvl_decay");
    return reader;
}

class model_igt_pvl_decay : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > choice;
    vector_d initV;
public:
    model_igt_pvl_decay(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_igt_pvl_decay(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_igt_pvl_decay_namespace::model_igt_pvl_decay";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("A_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("cons_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("lambda_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_igt_pvl_decay() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("A_pr")))
            throw std::runtime_error("variable A_pr missing");
        vals_r__ = context__.vals_r("A_pr");
        pos__ = 0U;
        validate_non_negative_index("A_pr", "N", N);
        context__.validate_dims("initialization", "A_pr", "vector_d", context__.to_vec(N));
        vector_d A_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            A_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(A_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable A_pr: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("cons_pr")))
            throw std::runtime_error("variable cons_pr missing");
        vals_r__ = context__.vals_r("cons_pr");
        pos__ = 0U;
        validate_non_negative_index("cons_pr", "N", N);
        context__.validate_dims("initialization", "cons_pr", "vector_d", context__.to_vec(N));
        vector_d cons_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            cons_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(cons_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable cons_pr: ") + e.what());
        }

        if (!(context__.contains_r("lambda_pr")))
            throw std::runtime_error("variable lambda_pr missing");
        vals_r__ = context__.vals_r("lambda_pr");
        pos__ = 0U;
        validate_non_negative_index("lambda_pr", "N", N);
        context__.validate_dims("initialization", "lambda_pr", "vector_d", context__.to_vec(N));
        vector_d lambda_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            lambda_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(lambda_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  A_pr;
            (void) A_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                A_pr = in__.vector_constrain(N,lp__);
            else
                A_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  cons_pr;
            (void) cons_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                cons_pr = in__.vector_constrain(N,lp__);
            else
                cons_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda_pr;
            (void) lambda_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_pr = in__.vector_constrain(N,lp__);
            else
                lambda_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("A", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, DUMMY_VAR__);
            stan::math::fill(A,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("cons", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  cons(static_cast<Eigen::VectorXd::Index>(N));
            (void) cons;  // dummy to suppress unused var warning

            stan::math::initialize(cons, DUMMY_VAR__);
            stan::math::fill(cons,DUMMY_VAR__);
            validate_non_negative_index("lambda", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, DUMMY_VAR__);
            stan::math::fill(lambda,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 2));
                stan::math::assign(get_base1_lhs(cons,i,"cons",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(cons_pr,i,"cons_pr",1)))) * 5));
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(A(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: A" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(cons(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: cons" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(lambda(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: lambda" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            check_greater_or_equal(function__,"cons",cons,0);
            check_less_or_equal(function__,"cons",cons,5);
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,10);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(A_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(cons_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(lambda_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                T__ curUtil;
                (void) curUtil;  // dummy to suppress unused var warning

                stan::math::initialize(curUtil, DUMMY_VAR__);
                stan::math::fill(curUtil,DUMMY_VAR__);
                T__ theta;
                (void) theta;  // dummy to suppress unused var warning

                stan::math::initialize(theta, DUMMY_VAR__);
                stan::math::fill(theta,DUMMY_VAR__);


                stan::math::assign(theta, (pow(3,get_base1(cons,i,"cons",1)) - 1));
                stan::math::assign(ev, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), multiply(theta,ev)));
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        stan::math::assign(curUtil, pow(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),get_base1(alpha,i,"alpha",1)));
                    } else {

                        stan::math::assign(curUtil, ((-(1) * get_base1(lambda,i,"lambda",1)) * pow((-(1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)),get_base1(alpha,i,"alpha",1))));
                    }
                    stan::math::assign(ev, multiply(ev,get_base1(A,i,"A",1)));
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + curUtil));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("A_pr");
        names__.push_back("alpha_pr");
        names__.push_back("cons_pr");
        names__.push_back("lambda_pr");
        names__.push_back("A");
        names__.push_back("alpha");
        names__.push_back("cons");
        names__.push_back("lambda");
        names__.push_back("mu_A");
        names__.push_back("mu_alpha");
        names__.push_back("mu_cons");
        names__.push_back("mu_lambda");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_igt_pvl_decay_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d A_pr = in__.vector_constrain(N);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d cons_pr = in__.vector_constrain(N);
        vector_d lambda_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(cons_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("A", "N", N);
            vector_d A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(A,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("cons", "N", N);
            vector_d cons(static_cast<Eigen::VectorXd::Index>(N));
            (void) cons;  // dummy to suppress unused var warning

            stan::math::initialize(cons, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(cons,DUMMY_VAR__);
            validate_non_negative_index("lambda", "N", N);
            vector_d lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(lambda,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 2));
                stan::math::assign(get_base1_lhs(cons,i,"cons",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(cons_pr,i,"cons_pr",1)))) * 5));
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))) * 10));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            check_greater_or_equal(function__,"cons",cons,0);
            check_less_or_equal(function__,"cons",cons,5);
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(cons[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_A(0.0);
            (void) mu_A;  // dummy to suppress unused var warning

            stan::math::initialize(mu_A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_A,DUMMY_VAR__);
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            double mu_cons(0.0);
            (void) mu_cons;  // dummy to suppress unused var warning

            stan::math::initialize(mu_cons, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_cons,DUMMY_VAR__);
            double mu_lambda(0.0);
            (void) mu_lambda;  // dummy to suppress unused var warning

            stan::math::initialize(mu_lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_lambda,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_A, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_alpha, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 2));
            stan::math::assign(mu_cons, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));
            stan::math::assign(mu_lambda, (Phi_approx(get_base1(mu_p,4,"mu_p",1)) * 10));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "4", 4);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                double curUtil(0.0);
                (void) curUtil;  // dummy to suppress unused var warning

                stan::math::initialize(curUtil, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(curUtil,DUMMY_VAR__);
                double theta(0.0);
                (void) theta;  // dummy to suppress unused var warning

                stan::math::initialize(theta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(theta,DUMMY_VAR__);


                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                stan::math::assign(theta, (pow(3,get_base1(cons,i,"cons",1)) - 1));
                stan::math::assign(ev, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),multiply(theta,ev))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(multiply(theta,ev)), base_rng__));
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        stan::math::assign(curUtil, pow(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),get_base1(alpha,i,"alpha",1)));
                    } else {

                        stan::math::assign(curUtil, ((-(1) * get_base1(lambda,i,"lambda",1)) * pow((-(1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)),get_base1(alpha,i,"alpha",1))));
                    }
                    stan::math::assign(ev, multiply(ev,get_base1(A,i,"A",1)));
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + curUtil));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_A",mu_A,0);
            check_less_or_equal(function__,"mu_A",mu_A,1);
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_less_or_equal(function__,"mu_alpha",mu_alpha,2);
            check_greater_or_equal(function__,"mu_cons",mu_cons,0);
            check_less_or_equal(function__,"mu_cons",mu_cons,5);
            check_greater_or_equal(function__,"mu_lambda",mu_lambda,0);
            check_less_or_equal(function__,"mu_lambda",mu_lambda,10);

            // write generated quantities
        vars__.push_back(mu_A);
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_cons);
        vars__.push_back(mu_lambda);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_igt_pvl_decay";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_cons";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_cons";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_igt_pvl_delta_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_igt_pvl_delta");
    reader.add_event(129, 129, "end", "model_igt_pvl_delta");
    return reader;
}

class model_igt_pvl_delta : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > choice;
    vector_d initV;
public:
    model_igt_pvl_delta(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_igt_pvl_delta(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_igt_pvl_delta_namespace::model_igt_pvl_delta";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("A_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("cons_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("lambda_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_igt_pvl_delta() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("A_pr")))
            throw std::runtime_error("variable A_pr missing");
        vals_r__ = context__.vals_r("A_pr");
        pos__ = 0U;
        validate_non_negative_index("A_pr", "N", N);
        context__.validate_dims("initialization", "A_pr", "vector_d", context__.to_vec(N));
        vector_d A_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            A_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(A_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable A_pr: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("cons_pr")))
            throw std::runtime_error("variable cons_pr missing");
        vals_r__ = context__.vals_r("cons_pr");
        pos__ = 0U;
        validate_non_negative_index("cons_pr", "N", N);
        context__.validate_dims("initialization", "cons_pr", "vector_d", context__.to_vec(N));
        vector_d cons_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            cons_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(cons_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable cons_pr: ") + e.what());
        }

        if (!(context__.contains_r("lambda_pr")))
            throw std::runtime_error("variable lambda_pr missing");
        vals_r__ = context__.vals_r("lambda_pr");
        pos__ = 0U;
        validate_non_negative_index("lambda_pr", "N", N);
        context__.validate_dims("initialization", "lambda_pr", "vector_d", context__.to_vec(N));
        vector_d lambda_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            lambda_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(lambda_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  A_pr;
            (void) A_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                A_pr = in__.vector_constrain(N,lp__);
            else
                A_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  cons_pr;
            (void) cons_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                cons_pr = in__.vector_constrain(N,lp__);
            else
                cons_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda_pr;
            (void) lambda_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_pr = in__.vector_constrain(N,lp__);
            else
                lambda_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("A", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, DUMMY_VAR__);
            stan::math::fill(A,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("cons", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  cons(static_cast<Eigen::VectorXd::Index>(N));
            (void) cons;  // dummy to suppress unused var warning

            stan::math::initialize(cons, DUMMY_VAR__);
            stan::math::fill(cons,DUMMY_VAR__);
            validate_non_negative_index("lambda", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, DUMMY_VAR__);
            stan::math::fill(lambda,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 2));
                stan::math::assign(get_base1_lhs(cons,i,"cons",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(cons_pr,i,"cons_pr",1)))) * 5));
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(A(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: A" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(cons(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: cons" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(lambda(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: lambda" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            check_greater_or_equal(function__,"cons",cons,0);
            check_less_or_equal(function__,"cons",cons,5);
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,10);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(A_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(cons_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(lambda_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                T__ curUtil;
                (void) curUtil;  // dummy to suppress unused var warning

                stan::math::initialize(curUtil, DUMMY_VAR__);
                stan::math::fill(curUtil,DUMMY_VAR__);
                T__ theta;
                (void) theta;  // dummy to suppress unused var warning

                stan::math::initialize(theta, DUMMY_VAR__);
                stan::math::fill(theta,DUMMY_VAR__);


                stan::math::assign(theta, (pow(3,get_base1(cons,i,"cons",1)) - 1));
                stan::math::assign(ev, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), multiply(theta,ev)));
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        stan::math::assign(curUtil, pow(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),get_base1(alpha,i,"alpha",1)));
                    } else {

                        stan::math::assign(curUtil, ((-(1) * get_base1(lambda,i,"lambda",1)) * pow((-(1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)),get_base1(alpha,i,"alpha",1))));
                    }
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(A,i,"A",1) * (curUtil - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)))));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("A_pr");
        names__.push_back("alpha_pr");
        names__.push_back("cons_pr");
        names__.push_back("lambda_pr");
        names__.push_back("A");
        names__.push_back("alpha");
        names__.push_back("cons");
        names__.push_back("lambda");
        names__.push_back("mu_A");
        names__.push_back("mu_alpha");
        names__.push_back("mu_cons");
        names__.push_back("mu_lambda");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_igt_pvl_delta_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d A_pr = in__.vector_constrain(N);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d cons_pr = in__.vector_constrain(N);
        vector_d lambda_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(cons_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("A", "N", N);
            vector_d A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(A,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("cons", "N", N);
            vector_d cons(static_cast<Eigen::VectorXd::Index>(N));
            (void) cons;  // dummy to suppress unused var warning

            stan::math::initialize(cons, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(cons,DUMMY_VAR__);
            validate_non_negative_index("lambda", "N", N);
            vector_d lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(lambda,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 2));
                stan::math::assign(get_base1_lhs(cons,i,"cons",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(cons_pr,i,"cons_pr",1)))) * 5));
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))) * 10));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            check_greater_or_equal(function__,"cons",cons,0);
            check_less_or_equal(function__,"cons",cons,5);
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(cons[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_A(0.0);
            (void) mu_A;  // dummy to suppress unused var warning

            stan::math::initialize(mu_A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_A,DUMMY_VAR__);
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            double mu_cons(0.0);
            (void) mu_cons;  // dummy to suppress unused var warning

            stan::math::initialize(mu_cons, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_cons,DUMMY_VAR__);
            double mu_lambda(0.0);
            (void) mu_lambda;  // dummy to suppress unused var warning

            stan::math::initialize(mu_lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_lambda,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_A, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_alpha, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 2));
            stan::math::assign(mu_cons, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));
            stan::math::assign(mu_lambda, (Phi_approx(get_base1(mu_p,4,"mu_p",1)) * 10));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "4", 4);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                double curUtil(0.0);
                (void) curUtil;  // dummy to suppress unused var warning

                stan::math::initialize(curUtil, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(curUtil,DUMMY_VAR__);
                double theta(0.0);
                (void) theta;  // dummy to suppress unused var warning

                stan::math::initialize(theta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(theta,DUMMY_VAR__);


                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                stan::math::assign(theta, (pow(3,get_base1(cons,i,"cons",1)) - 1));
                stan::math::assign(ev, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),multiply(theta,ev))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(multiply(theta,ev)), base_rng__));
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        stan::math::assign(curUtil, pow(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),get_base1(alpha,i,"alpha",1)));
                    } else {

                        stan::math::assign(curUtil, ((-(1) * get_base1(lambda,i,"lambda",1)) * pow((-(1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)),get_base1(alpha,i,"alpha",1))));
                    }
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(A,i,"A",1) * (curUtil - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)))));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_A",mu_A,0);
            check_less_or_equal(function__,"mu_A",mu_A,1);
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_less_or_equal(function__,"mu_alpha",mu_alpha,2);
            check_greater_or_equal(function__,"mu_cons",mu_cons,0);
            check_less_or_equal(function__,"mu_cons",mu_cons,5);
            check_greater_or_equal(function__,"mu_lambda",mu_lambda,0);
            check_less_or_equal(function__,"mu_lambda",mu_lambda,10);

            // write generated quantities
        vars__.push_back(mu_A);
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_cons);
        vars__.push_back(mu_lambda);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_igt_pvl_delta";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_cons";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_cons";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_igt_vpp_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_igt_vpp");
    reader.add_event(185, 185, "end", "model_igt_vpp");
    return reader;
}

class model_igt_vpp : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > choice;
    vector_d initV;
public:
    model_igt_vpp(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_igt_vpp(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_igt_vpp_namespace::model_igt_vpp";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            // initialize data variables
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "8", 8);
            num_params_r__ += 8;
            validate_non_negative_index("sigma", "8", 8);
            num_params_r__ += 8;
            validate_non_negative_index("A_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("cons_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("lambda_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("epP_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("epN_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("K_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("w_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_igt_vpp() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "8", 8);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(8));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(8));
        for (int j1__ = 0U; j1__ < 8; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "8", 8);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(8));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(8));
        for (int j1__ = 0U; j1__ < 8; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("A_pr")))
            throw std::runtime_error("variable A_pr missing");
        vals_r__ = context__.vals_r("A_pr");
        pos__ = 0U;
        validate_non_negative_index("A_pr", "N", N);
        context__.validate_dims("initialization", "A_pr", "vector_d", context__.to_vec(N));
        vector_d A_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            A_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(A_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable A_pr: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("cons_pr")))
            throw std::runtime_error("variable cons_pr missing");
        vals_r__ = context__.vals_r("cons_pr");
        pos__ = 0U;
        validate_non_negative_index("cons_pr", "N", N);
        context__.validate_dims("initialization", "cons_pr", "vector_d", context__.to_vec(N));
        vector_d cons_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            cons_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(cons_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable cons_pr: ") + e.what());
        }

        if (!(context__.contains_r("lambda_pr")))
            throw std::runtime_error("variable lambda_pr missing");
        vals_r__ = context__.vals_r("lambda_pr");
        pos__ = 0U;
        validate_non_negative_index("lambda_pr", "N", N);
        context__.validate_dims("initialization", "lambda_pr", "vector_d", context__.to_vec(N));
        vector_d lambda_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            lambda_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(lambda_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_pr: ") + e.what());
        }

        if (!(context__.contains_r("epP_pr")))
            throw std::runtime_error("variable epP_pr missing");
        vals_r__ = context__.vals_r("epP_pr");
        pos__ = 0U;
        validate_non_negative_index("epP_pr", "N", N);
        context__.validate_dims("initialization", "epP_pr", "vector_d", context__.to_vec(N));
        vector_d epP_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            epP_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(epP_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable epP_pr: ") + e.what());
        }

        if (!(context__.contains_r("epN_pr")))
            throw std::runtime_error("variable epN_pr missing");
        vals_r__ = context__.vals_r("epN_pr");
        pos__ = 0U;
        validate_non_negative_index("epN_pr", "N", N);
        context__.validate_dims("initialization", "epN_pr", "vector_d", context__.to_vec(N));
        vector_d epN_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            epN_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(epN_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable epN_pr: ") + e.what());
        }

        if (!(context__.contains_r("K_pr")))
            throw std::runtime_error("variable K_pr missing");
        vals_r__ = context__.vals_r("K_pr");
        pos__ = 0U;
        validate_non_negative_index("K_pr", "N", N);
        context__.validate_dims("initialization", "K_pr", "vector_d", context__.to_vec(N));
        vector_d K_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            K_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(K_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable K_pr: ") + e.what());
        }

        if (!(context__.contains_r("w_pr")))
            throw std::runtime_error("variable w_pr missing");
        vals_r__ = context__.vals_r("w_pr");
        pos__ = 0U;
        validate_non_negative_index("w_pr", "N", N);
        context__.validate_dims("initialization", "w_pr", "vector_d", context__.to_vec(N));
        vector_d w_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            w_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(w_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable w_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(8,lp__);
            else
                mu_p = in__.vector_constrain(8);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,8,lp__);
            else
                sigma = in__.vector_lb_constrain(0,8);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  A_pr;
            (void) A_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                A_pr = in__.vector_constrain(N,lp__);
            else
                A_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  cons_pr;
            (void) cons_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                cons_pr = in__.vector_constrain(N,lp__);
            else
                cons_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda_pr;
            (void) lambda_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_pr = in__.vector_constrain(N,lp__);
            else
                lambda_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  epP_pr;
            (void) epP_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                epP_pr = in__.vector_constrain(N,lp__);
            else
                epP_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  epN_pr;
            (void) epN_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                epN_pr = in__.vector_constrain(N,lp__);
            else
                epN_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  K_pr;
            (void) K_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                K_pr = in__.vector_constrain(N,lp__);
            else
                K_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  w_pr;
            (void) w_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                w_pr = in__.vector_constrain(N,lp__);
            else
                w_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("A", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, DUMMY_VAR__);
            stan::math::fill(A,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("cons", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  cons(static_cast<Eigen::VectorXd::Index>(N));
            (void) cons;  // dummy to suppress unused var warning

            stan::math::initialize(cons, DUMMY_VAR__);
            stan::math::fill(cons,DUMMY_VAR__);
            validate_non_negative_index("lambda", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, DUMMY_VAR__);
            stan::math::fill(lambda,DUMMY_VAR__);
            validate_non_negative_index("epP", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  epP(static_cast<Eigen::VectorXd::Index>(N));
            (void) epP;  // dummy to suppress unused var warning

            stan::math::initialize(epP, DUMMY_VAR__);
            stan::math::fill(epP,DUMMY_VAR__);
            validate_non_negative_index("epN", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  epN(static_cast<Eigen::VectorXd::Index>(N));
            (void) epN;  // dummy to suppress unused var warning

            stan::math::initialize(epN, DUMMY_VAR__);
            stan::math::fill(epN,DUMMY_VAR__);
            validate_non_negative_index("K", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  K(static_cast<Eigen::VectorXd::Index>(N));
            (void) K;  // dummy to suppress unused var warning

            stan::math::initialize(K, DUMMY_VAR__);
            stan::math::fill(K,DUMMY_VAR__);
            validate_non_negative_index("w", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  w(static_cast<Eigen::VectorXd::Index>(N));
            (void) w;  // dummy to suppress unused var warning

            stan::math::initialize(w, DUMMY_VAR__);
            stan::math::fill(w,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 2));
                stan::math::assign(get_base1_lhs(cons,i,"cons",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(cons_pr,i,"cons_pr",1)))) * 5));
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))) * 10));
                stan::math::assign(get_base1_lhs(K,i,"K",1), Phi_approx((get_base1(mu_p,7,"mu_p",1) + (get_base1(sigma,7,"sigma",1) * get_base1(K_pr,i,"K_pr",1)))));
                stan::math::assign(get_base1_lhs(w,i,"w",1), Phi_approx((get_base1(mu_p,8,"mu_p",1) + (get_base1(sigma,8,"sigma",1) * get_base1(w_pr,i,"w_pr",1)))));
            }
            stan::math::assign(epP, add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),epP_pr)));
            stan::math::assign(epN, add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),epN_pr)));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(A(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: A" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(cons(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: cons" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(lambda(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: lambda" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(epP(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: epP" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(epN(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: epN" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(K(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: K" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(w(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: w" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            check_greater_or_equal(function__,"cons",cons,0);
            check_less_or_equal(function__,"cons",cons,5);
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,10);
            check_greater_or_equal(function__,"K",K,0);
            check_less_or_equal(function__,"K",K,1);
            check_greater_or_equal(function__,"w",w,0);
            check_less_or_equal(function__,"w",w,1);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(1, 4), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(cauchy_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(5, 6), stan::model::nil_index_list()), "sigma"), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(7, 8), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(A_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(cons_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(lambda_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(epP_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(epN_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(K_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(w_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("p_next", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  p_next(static_cast<Eigen::VectorXd::Index>(4));
                (void) p_next;  // dummy to suppress unused var warning

                stan::math::initialize(p_next, DUMMY_VAR__);
                stan::math::fill(p_next,DUMMY_VAR__);
                validate_non_negative_index("str", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  str(static_cast<Eigen::VectorXd::Index>(4));
                (void) str;  // dummy to suppress unused var warning

                stan::math::initialize(str, DUMMY_VAR__);
                stan::math::fill(str,DUMMY_VAR__);
                validate_non_negative_index("pers", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pers(static_cast<Eigen::VectorXd::Index>(4));
                (void) pers;  // dummy to suppress unused var warning

                stan::math::initialize(pers, DUMMY_VAR__);
                stan::math::fill(pers,DUMMY_VAR__);
                validate_non_negative_index("V", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  V(static_cast<Eigen::VectorXd::Index>(4));
                (void) V;  // dummy to suppress unused var warning

                stan::math::initialize(V, DUMMY_VAR__);
                stan::math::fill(V,DUMMY_VAR__);
                T__ curUtil;
                (void) curUtil;  // dummy to suppress unused var warning

                stan::math::initialize(curUtil, DUMMY_VAR__);
                stan::math::fill(curUtil,DUMMY_VAR__);
                T__ theta;
                (void) theta;  // dummy to suppress unused var warning

                stan::math::initialize(theta, DUMMY_VAR__);
                stan::math::fill(theta,DUMMY_VAR__);


                stan::math::assign(theta, (pow(3,get_base1(cons,i,"cons",1)) - 1));
                stan::math::assign(ev, initV);
                stan::math::assign(pers, initV);
                stan::math::assign(V, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), multiply(theta,V)));
                    stan::math::assign(pers, multiply(pers,get_base1(K,i,"K",1)));
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        stan::math::assign(curUtil, pow(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),get_base1(alpha,i,"alpha",1)));
                        stan::math::assign(get_base1_lhs(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1), (get_base1(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1) + get_base1(epP,i,"epP",1)));
                    } else {

                        stan::math::assign(curUtil, ((-(1) * get_base1(lambda,i,"lambda",1)) * pow((-(1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)),get_base1(alpha,i,"alpha",1))));
                        stan::math::assign(get_base1_lhs(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1), (get_base1(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1) + get_base1(epN,i,"epN",1)));
                    }
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(A,i,"A",1) * (curUtil - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)))));
                    stan::math::assign(V, add(multiply(get_base1(w,i,"w",1),ev),multiply((1 - get_base1(w,i,"w",1)),pers)));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("A_pr");
        names__.push_back("alpha_pr");
        names__.push_back("cons_pr");
        names__.push_back("lambda_pr");
        names__.push_back("epP_pr");
        names__.push_back("epN_pr");
        names__.push_back("K_pr");
        names__.push_back("w_pr");
        names__.push_back("A");
        names__.push_back("alpha");
        names__.push_back("cons");
        names__.push_back("lambda");
        names__.push_back("epP");
        names__.push_back("epN");
        names__.push_back("K");
        names__.push_back("w");
        names__.push_back("mu_A");
        names__.push_back("mu_alpha");
        names__.push_back("mu_cons");
        names__.push_back("mu_lambda");
        names__.push_back("mu_epP");
        names__.push_back("mu_epN");
        names__.push_back("mu_K");
        names__.push_back("mu_w");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(8);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(8);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_igt_vpp_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(8);
        vector_d sigma = in__.vector_lb_constrain(0,8);
        vector_d A_pr = in__.vector_constrain(N);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d cons_pr = in__.vector_constrain(N);
        vector_d lambda_pr = in__.vector_constrain(N);
        vector_d epP_pr = in__.vector_constrain(N);
        vector_d epN_pr = in__.vector_constrain(N);
        vector_d K_pr = in__.vector_constrain(N);
        vector_d w_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 8; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 8; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(cons_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(epP_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(epN_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(K_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("A", "N", N);
            vector_d A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(A,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("cons", "N", N);
            vector_d cons(static_cast<Eigen::VectorXd::Index>(N));
            (void) cons;  // dummy to suppress unused var warning

            stan::math::initialize(cons, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(cons,DUMMY_VAR__);
            validate_non_negative_index("lambda", "N", N);
            vector_d lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(lambda,DUMMY_VAR__);
            validate_non_negative_index("epP", "N", N);
            vector_d epP(static_cast<Eigen::VectorXd::Index>(N));
            (void) epP;  // dummy to suppress unused var warning

            stan::math::initialize(epP, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(epP,DUMMY_VAR__);
            validate_non_negative_index("epN", "N", N);
            vector_d epN(static_cast<Eigen::VectorXd::Index>(N));
            (void) epN;  // dummy to suppress unused var warning

            stan::math::initialize(epN, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(epN,DUMMY_VAR__);
            validate_non_negative_index("K", "N", N);
            vector_d K(static_cast<Eigen::VectorXd::Index>(N));
            (void) K;  // dummy to suppress unused var warning

            stan::math::initialize(K, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(K,DUMMY_VAR__);
            validate_non_negative_index("w", "N", N);
            vector_d w(static_cast<Eigen::VectorXd::Index>(N));
            (void) w;  // dummy to suppress unused var warning

            stan::math::initialize(w, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(w,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 2));
                stan::math::assign(get_base1_lhs(cons,i,"cons",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(cons_pr,i,"cons_pr",1)))) * 5));
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))) * 10));
                stan::math::assign(get_base1_lhs(K,i,"K",1), Phi_approx((get_base1(mu_p,7,"mu_p",1) + (get_base1(sigma,7,"sigma",1) * get_base1(K_pr,i,"K_pr",1)))));
                stan::math::assign(get_base1_lhs(w,i,"w",1), Phi_approx((get_base1(mu_p,8,"mu_p",1) + (get_base1(sigma,8,"sigma",1) * get_base1(w_pr,i,"w_pr",1)))));
            }
            stan::math::assign(epP, add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),epP_pr)));
            stan::math::assign(epN, add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),epN_pr)));

            // validate transformed parameters
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            check_greater_or_equal(function__,"cons",cons,0);
            check_less_or_equal(function__,"cons",cons,5);
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,10);
            check_greater_or_equal(function__,"K",K,0);
            check_less_or_equal(function__,"K",K,1);
            check_greater_or_equal(function__,"w",w,0);
            check_less_or_equal(function__,"w",w,1);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(cons[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(epP[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(epN[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(K[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_A(0.0);
            (void) mu_A;  // dummy to suppress unused var warning

            stan::math::initialize(mu_A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_A,DUMMY_VAR__);
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            double mu_cons(0.0);
            (void) mu_cons;  // dummy to suppress unused var warning

            stan::math::initialize(mu_cons, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_cons,DUMMY_VAR__);
            double mu_lambda(0.0);
            (void) mu_lambda;  // dummy to suppress unused var warning

            stan::math::initialize(mu_lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_lambda,DUMMY_VAR__);
            double mu_epP(0.0);
            (void) mu_epP;  // dummy to suppress unused var warning

            stan::math::initialize(mu_epP, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_epP,DUMMY_VAR__);
            double mu_epN(0.0);
            (void) mu_epN;  // dummy to suppress unused var warning

            stan::math::initialize(mu_epN, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_epN,DUMMY_VAR__);
            double mu_K(0.0);
            (void) mu_K;  // dummy to suppress unused var warning

            stan::math::initialize(mu_K, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_K,DUMMY_VAR__);
            double mu_w(0.0);
            (void) mu_w;  // dummy to suppress unused var warning

            stan::math::initialize(mu_w, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_w,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_A, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_alpha, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 2));
            stan::math::assign(mu_cons, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));
            stan::math::assign(mu_lambda, (Phi_approx(get_base1(mu_p,4,"mu_p",1)) * 10));
            stan::math::assign(mu_epP, get_base1(mu_p,5,"mu_p",1));
            stan::math::assign(mu_epN, get_base1(mu_p,6,"mu_p",1));
            stan::math::assign(mu_K, Phi_approx(get_base1(mu_p,7,"mu_p",1)));
            stan::math::assign(mu_w, Phi_approx(get_base1(mu_p,8,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "4", 4);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("p_next", "4", 4);
                vector_d p_next(static_cast<Eigen::VectorXd::Index>(4));
                (void) p_next;  // dummy to suppress unused var warning

                stan::math::initialize(p_next, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(p_next,DUMMY_VAR__);
                validate_non_negative_index("str", "4", 4);
                vector_d str(static_cast<Eigen::VectorXd::Index>(4));
                (void) str;  // dummy to suppress unused var warning

                stan::math::initialize(str, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(str,DUMMY_VAR__);
                validate_non_negative_index("pers", "4", 4);
                vector_d pers(static_cast<Eigen::VectorXd::Index>(4));
                (void) pers;  // dummy to suppress unused var warning

                stan::math::initialize(pers, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pers,DUMMY_VAR__);
                validate_non_negative_index("V", "4", 4);
                vector_d V(static_cast<Eigen::VectorXd::Index>(4));
                (void) V;  // dummy to suppress unused var warning

                stan::math::initialize(V, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(V,DUMMY_VAR__);
                double curUtil(0.0);
                (void) curUtil;  // dummy to suppress unused var warning

                stan::math::initialize(curUtil, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(curUtil,DUMMY_VAR__);
                double theta(0.0);
                (void) theta;  // dummy to suppress unused var warning

                stan::math::initialize(theta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(theta,DUMMY_VAR__);


                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                stan::math::assign(theta, (pow(3,get_base1(cons,i,"cons",1)) - 1));
                stan::math::assign(ev, initV);
                stan::math::assign(pers, initV);
                stan::math::assign(V, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),multiply(theta,V))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(multiply(theta,V)), base_rng__));
                    stan::math::assign(pers, multiply(pers,get_base1(K,i,"K",1)));
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        stan::math::assign(curUtil, pow(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),get_base1(alpha,i,"alpha",1)));
                        stan::math::assign(get_base1_lhs(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1), (get_base1(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1) + get_base1(epP,i,"epP",1)));
                    } else {

                        stan::math::assign(curUtil, ((-(1) * get_base1(lambda,i,"lambda",1)) * pow((-(1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)),get_base1(alpha,i,"alpha",1))));
                        stan::math::assign(get_base1_lhs(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1), (get_base1(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1) + get_base1(epN,i,"epN",1)));
                    }
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(A,i,"A",1) * (curUtil - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)))));
                    stan::math::assign(V, add(multiply(get_base1(w,i,"w",1),ev),multiply((1 - get_base1(w,i,"w",1)),pers)));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_A",mu_A,0);
            check_less_or_equal(function__,"mu_A",mu_A,1);
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_less_or_equal(function__,"mu_alpha",mu_alpha,2);
            check_greater_or_equal(function__,"mu_cons",mu_cons,0);
            check_less_or_equal(function__,"mu_cons",mu_cons,5);
            check_greater_or_equal(function__,"mu_lambda",mu_lambda,0);
            check_less_or_equal(function__,"mu_lambda",mu_lambda,10);
            check_greater_or_equal(function__,"mu_K",mu_K,0);
            check_less_or_equal(function__,"mu_K",mu_K,1);
            check_greater_or_equal(function__,"mu_w",mu_w,0);
            check_less_or_equal(function__,"mu_w",mu_w,1);

            // write generated quantities
        vars__.push_back(mu_A);
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_cons);
        vars__.push_back(mu_lambda);
        vars__.push_back(mu_epP);
        vars__.push_back(mu_epN);
        vars__.push_back(mu_K);
        vars__.push_back(mu_w);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_igt_vpp";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 8; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 8; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epP_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epN_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "K_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epP" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epN" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "K" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_cons";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_epP";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_epN";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_K";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 8; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 8; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epP_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epN_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "K_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epP" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epN" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "K" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_cons";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_epP";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_epN";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_K";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_peer_ocu_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_peer_ocu");
    reader.add_event(112, 112, "end", "model_peer_ocu");
    return reader;
}

class model_peer_ocu : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<int> > condition;
    vector<vector<double> > safe_Hpayoff;
    vector<vector<double> > safe_Lpayoff;
    vector<vector<double> > risky_Hpayoff;
    vector<vector<double> > risky_Lpayoff;
    vector<vector<double> > p_gamble;
public:
    model_peer_ocu(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_peer_ocu(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_peer_ocu_namespace::model_peer_ocu";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("condition", "N", N);
            validate_non_negative_index("condition", "T", T);
            context__.validate_dims("data initialization", "condition", "int", context__.to_vec(N,T));
            validate_non_negative_index("condition", "N", N);
            validate_non_negative_index("condition", "T", T);
            condition = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("condition");
            pos__ = 0;
            size_t condition_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < condition_limit_1__; ++i_1__) {
                size_t condition_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < condition_limit_0__; ++i_0__) {
                    condition[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("safe_Hpayoff", "N", N);
            validate_non_negative_index("safe_Hpayoff", "T", T);
            context__.validate_dims("data initialization", "safe_Hpayoff", "double", context__.to_vec(N,T));
            validate_non_negative_index("safe_Hpayoff", "N", N);
            validate_non_negative_index("safe_Hpayoff", "T", T);
            safe_Hpayoff = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("safe_Hpayoff");
            pos__ = 0;
            size_t safe_Hpayoff_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < safe_Hpayoff_limit_1__; ++i_1__) {
                size_t safe_Hpayoff_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < safe_Hpayoff_limit_0__; ++i_0__) {
                    safe_Hpayoff[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("safe_Lpayoff", "N", N);
            validate_non_negative_index("safe_Lpayoff", "T", T);
            context__.validate_dims("data initialization", "safe_Lpayoff", "double", context__.to_vec(N,T));
            validate_non_negative_index("safe_Lpayoff", "N", N);
            validate_non_negative_index("safe_Lpayoff", "T", T);
            safe_Lpayoff = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("safe_Lpayoff");
            pos__ = 0;
            size_t safe_Lpayoff_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < safe_Lpayoff_limit_1__; ++i_1__) {
                size_t safe_Lpayoff_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < safe_Lpayoff_limit_0__; ++i_0__) {
                    safe_Lpayoff[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("risky_Hpayoff", "N", N);
            validate_non_negative_index("risky_Hpayoff", "T", T);
            context__.validate_dims("data initialization", "risky_Hpayoff", "double", context__.to_vec(N,T));
            validate_non_negative_index("risky_Hpayoff", "N", N);
            validate_non_negative_index("risky_Hpayoff", "T", T);
            risky_Hpayoff = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("risky_Hpayoff");
            pos__ = 0;
            size_t risky_Hpayoff_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < risky_Hpayoff_limit_1__; ++i_1__) {
                size_t risky_Hpayoff_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < risky_Hpayoff_limit_0__; ++i_0__) {
                    risky_Hpayoff[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("risky_Lpayoff", "N", N);
            validate_non_negative_index("risky_Lpayoff", "T", T);
            context__.validate_dims("data initialization", "risky_Lpayoff", "double", context__.to_vec(N,T));
            validate_non_negative_index("risky_Lpayoff", "N", N);
            validate_non_negative_index("risky_Lpayoff", "T", T);
            risky_Lpayoff = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("risky_Lpayoff");
            pos__ = 0;
            size_t risky_Lpayoff_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < risky_Lpayoff_limit_1__; ++i_1__) {
                size_t risky_Lpayoff_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < risky_Lpayoff_limit_0__; ++i_0__) {
                    risky_Lpayoff[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("p_gamble", "N", N);
            validate_non_negative_index("p_gamble", "T", T);
            context__.validate_dims("data initialization", "p_gamble", "double", context__.to_vec(N,T));
            validate_non_negative_index("p_gamble", "N", N);
            validate_non_negative_index("p_gamble", "T", T);
            p_gamble = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("p_gamble");
            pos__ = 0;
            size_t p_gamble_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < p_gamble_limit_1__; ++i_1__) {
                size_t p_gamble_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < p_gamble_limit_0__; ++i_0__) {
                    p_gamble[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"condition[k0__][k1__]",condition[k0__][k1__],0);
                    check_less_or_equal(function__,"condition[k0__][k1__]",condition[k0__][k1__],3);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"p_gamble[k0__][k1__]",p_gamble[k0__][k1__],0);
                    check_less_or_equal(function__,"p_gamble[k0__][k1__]",p_gamble[k0__][k1__],1);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("rho_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("tau_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("ocu_p", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_peer_ocu() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("rho_p")))
            throw std::runtime_error("variable rho_p missing");
        vals_r__ = context__.vals_r("rho_p");
        pos__ = 0U;
        validate_non_negative_index("rho_p", "N", N);
        context__.validate_dims("initialization", "rho_p", "vector_d", context__.to_vec(N));
        vector_d rho_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_p: ") + e.what());
        }

        if (!(context__.contains_r("tau_p")))
            throw std::runtime_error("variable tau_p missing");
        vals_r__ = context__.vals_r("tau_p");
        pos__ = 0U;
        validate_non_negative_index("tau_p", "N", N);
        context__.validate_dims("initialization", "tau_p", "vector_d", context__.to_vec(N));
        vector_d tau_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_p: ") + e.what());
        }

        if (!(context__.contains_r("ocu_p")))
            throw std::runtime_error("variable ocu_p missing");
        vals_r__ = context__.vals_r("ocu_p");
        pos__ = 0U;
        validate_non_negative_index("ocu_p", "N", N);
        context__.validate_dims("initialization", "ocu_p", "vector_d", context__.to_vec(N));
        vector_d ocu_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ocu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ocu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ocu_p: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_p;
            (void) rho_p;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_p = in__.vector_constrain(N,lp__);
            else
                rho_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_p;
            (void) tau_p;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_p = in__.vector_constrain(N,lp__);
            else
                tau_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ocu_p;
            (void) ocu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                ocu_p = in__.vector_constrain(N,lp__);
            else
                ocu_p = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);
            validate_non_negative_index("ocu", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ocu(static_cast<Eigen::VectorXd::Index>(N));
            (void) ocu;  // dummy to suppress unused var warning

            stan::math::initialize(ocu, DUMMY_VAR__);
            stan::math::fill(ocu,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(rho,i,"rho",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(rho_p,i,"rho_p",1)))) * 2));
            }
            stan::math::assign(tau, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),tau_p))));
            stan::math::assign(ocu, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),ocu_p)));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ocu(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ocu" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,2);
            check_greater_or_equal(function__,"tau",tau,0);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(cauchy_log<propto__>(get_base1(sigma,3,"sigma",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(rho_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(tau_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(ocu_p, 0, 1.0));
            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    T__ U_safe;
                    (void) U_safe;  // dummy to suppress unused var warning

                    stan::math::initialize(U_safe, DUMMY_VAR__);
                    stan::math::fill(U_safe,DUMMY_VAR__);
                    T__ U_risky;
                    (void) U_risky;  // dummy to suppress unused var warning

                    stan::math::initialize(U_risky, DUMMY_VAR__);
                    stan::math::fill(U_risky,DUMMY_VAR__);


                    stan::math::assign(U_safe, ((get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2) * pow(get_base1(get_base1(safe_Hpayoff,i,"safe_Hpayoff",1),t,"safe_Hpayoff",2),get_base1(rho,i,"rho",1))) + ((1 - get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2)) * pow(get_base1(get_base1(safe_Lpayoff,i,"safe_Lpayoff",1),t,"safe_Lpayoff",2),get_base1(rho,i,"rho",1)))));
                    stan::math::assign(U_risky, ((get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2) * pow(get_base1(get_base1(risky_Hpayoff,i,"risky_Hpayoff",1),t,"risky_Hpayoff",2),get_base1(rho,i,"rho",1))) + ((1 - get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2)) * pow(get_base1(get_base1(risky_Lpayoff,i,"risky_Lpayoff",1),t,"risky_Lpayoff",2),get_base1(rho,i,"rho",1)))));
                    if (as_bool(logical_eq(get_base1(get_base1(condition,i,"condition",1),t,"condition",2),1))) {

                        stan::math::assign(U_safe, (U_safe + get_base1(ocu,i,"ocu",1)));
                    }
                    if (as_bool(logical_eq(get_base1(get_base1(condition,i,"condition",1),t,"condition",2),3))) {

                        stan::math::assign(U_risky, (U_risky + get_base1(ocu,i,"ocu",1)));
                    }
                    lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), (get_base1(tau,i,"tau",1) * (U_risky - U_safe))));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("rho_p");
        names__.push_back("tau_p");
        names__.push_back("ocu_p");
        names__.push_back("rho");
        names__.push_back("tau");
        names__.push_back("ocu");
        names__.push_back("mu_rho");
        names__.push_back("mu_tau");
        names__.push_back("mu_ocu");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_peer_ocu_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d rho_p = in__.vector_constrain(N);
        vector_d tau_p = in__.vector_constrain(N);
        vector_d ocu_p = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ocu_p[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);
            validate_non_negative_index("ocu", "N", N);
            vector_d ocu(static_cast<Eigen::VectorXd::Index>(N));
            (void) ocu;  // dummy to suppress unused var warning

            stan::math::initialize(ocu, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ocu,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(rho,i,"rho",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(rho_p,i,"rho_p",1)))) * 2));
            }
            stan::math::assign(tau, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),tau_p))));
            stan::math::assign(ocu, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),ocu_p)));

            // validate transformed parameters
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,2);
            check_greater_or_equal(function__,"tau",tau,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ocu[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            double mu_ocu(0.0);
            (void) mu_ocu;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ocu, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ocu,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_rho, (Phi_approx(get_base1(mu_p,1,"mu_p",1)) * 2));
            stan::math::assign(mu_tau, exp(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_ocu, get_base1(mu_p,3,"mu_p",1));

            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0.0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    double U_safe(0.0);
                    (void) U_safe;  // dummy to suppress unused var warning

                    stan::math::initialize(U_safe, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(U_safe,DUMMY_VAR__);
                    double U_risky(0.0);
                    (void) U_risky;  // dummy to suppress unused var warning

                    stan::math::initialize(U_risky, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(U_risky,DUMMY_VAR__);


                    stan::math::assign(U_safe, ((get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2) * pow(get_base1(get_base1(safe_Hpayoff,i,"safe_Hpayoff",1),t,"safe_Hpayoff",2),get_base1(rho,i,"rho",1))) + ((1 - get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2)) * pow(get_base1(get_base1(safe_Lpayoff,i,"safe_Lpayoff",1),t,"safe_Lpayoff",2),get_base1(rho,i,"rho",1)))));
                    stan::math::assign(U_risky, ((get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2) * pow(get_base1(get_base1(risky_Hpayoff,i,"risky_Hpayoff",1),t,"risky_Hpayoff",2),get_base1(rho,i,"rho",1))) + ((1 - get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2)) * pow(get_base1(get_base1(risky_Lpayoff,i,"risky_Lpayoff",1),t,"risky_Lpayoff",2),get_base1(rho,i,"rho",1)))));
                    if (as_bool(logical_eq(get_base1(get_base1(condition,i,"condition",1),t,"condition",2),1))) {

                        stan::math::assign(U_safe, (U_safe + get_base1(ocu,i,"ocu",1)));
                    }
                    if (as_bool(logical_eq(get_base1(get_base1(condition,i,"condition",1),t,"condition",2),3))) {

                        stan::math::assign(U_risky, (U_risky + get_base1(ocu,i,"ocu",1)));
                    }
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),(get_base1(tau,i,"tau",1) * (U_risky - U_safe)))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(inv_logit((get_base1(tau,i,"tau",1) * (U_risky - U_safe))), base_rng__));
                    }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            check_less_or_equal(function__,"mu_rho",mu_rho,2);
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);

            // write generated quantities
        vars__.push_back(mu_rho);
        vars__.push_back(mu_tau);
        vars__.push_back(mu_ocu);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_peer_ocu";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ocu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ocu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ocu";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ocu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ocu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ocu";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_ewa_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_ewa");
    reader.add_event(162, 162, "end", "model_prl_ewa");
    return reader;
}

class model_prl_ewa : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > outcome;
    vector_d initV;
public:
    model_prl_ewa(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_ewa(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_ewa_namespace::model_prl_ewa";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],2);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("phi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_ewa() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("phi_pr")))
            throw std::runtime_error("variable phi_pr missing");
        vals_r__ = context__.vals_r("phi_pr");
        pos__ = 0U;
        validate_non_negative_index("phi_pr", "N", N);
        context__.validate_dims("initialization", "phi_pr", "vector_d", context__.to_vec(N));
        vector_d phi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            phi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(phi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable phi_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  phi_pr;
            (void) phi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                phi_pr = in__.vector_constrain(N,lp__);
            else
                phi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("phi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  phi(static_cast<Eigen::VectorXd::Index>(N));
            (void) phi;  // dummy to suppress unused var warning

            stan::math::initialize(phi, DUMMY_VAR__);
            stan::math::fill(phi,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(phi,i,"phi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(phi_pr,i,"phi_pr",1)))));
                stan::math::assign(get_base1_lhs(rho,i,"rho",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(rho_pr,i,"rho_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(phi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: phi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"phi",phi,0);
            check_less_or_equal(function__,"phi",phi,1);
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(phi_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("ew", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ew(static_cast<Eigen::VectorXd::Index>(2));
                (void) ew;  // dummy to suppress unused var warning

                stan::math::initialize(ew, DUMMY_VAR__);
                stan::math::fill(ew,DUMMY_VAR__);
                T__ ewt1;
                (void) ewt1;  // dummy to suppress unused var warning

                stan::math::initialize(ewt1, DUMMY_VAR__);
                stan::math::fill(ewt1,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                stan::math::assign(ew, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), multiply(ev,get_base1(beta,i,"beta",1))));
                    stan::math::assign(ewt1, get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1));
                    stan::math::assign(get_base1_lhs(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1), ((get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1) * get_base1(rho,i,"rho",1)) + 1));
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), ((((get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) * get_base1(phi,i,"phi",1)) * ewt1) + get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) / get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1)));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("phi_pr");
        names__.push_back("rho_pr");
        names__.push_back("beta_pr");
        names__.push_back("phi");
        names__.push_back("rho");
        names__.push_back("beta");
        names__.push_back("mu_phi");
        names__.push_back("mu_rho");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_ew_c");
        names__.push_back("mr_ew_nc");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_ewa_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d phi_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(phi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("phi", "N", N);
            vector_d phi(static_cast<Eigen::VectorXd::Index>(N));
            (void) phi;  // dummy to suppress unused var warning

            stan::math::initialize(phi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(phi,DUMMY_VAR__);
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(phi,i,"phi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(phi_pr,i,"phi_pr",1)))));
                stan::math::assign(get_base1_lhs(rho,i,"rho",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(rho_pr,i,"rho_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"phi",phi,0);
            check_less_or_equal(function__,"phi",phi,1);
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(phi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_phi(0.0);
            (void) mu_phi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_phi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_phi,DUMMY_VAR__);
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<double> > mr_ev_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<double> > mr_ev_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_ew_c", "N", N);
            validate_non_negative_index("mr_ew_c", "T", T);
            vector<vector<double> > mr_ew_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ew_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ew_c,DUMMY_VAR__);
            validate_non_negative_index("mr_ew_nc", "N", N);
            validate_non_negative_index("mr_ew_nc", "T", T);
            vector<vector<double> > mr_ew_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ew_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ew_nc,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ew_c,i,"mr_ew_c",1),t,"mr_ew_c",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ew_nc,i,"mr_ew_nc",1),t,"mr_ew_nc",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_phi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_rho, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 10));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("ew", "2", 2);
                vector_d ew(static_cast<Eigen::VectorXd::Index>(2));
                (void) ew;  // dummy to suppress unused var warning

                stan::math::initialize(ew, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ew,DUMMY_VAR__);
                double ewt1(0.0);
                (void) ewt1;  // dummy to suppress unused var warning

                stan::math::initialize(ewt1, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ewt1,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                stan::math::assign(ew, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),multiply(ev,get_base1(beta,i,"beta",1)))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(multiply(ev,get_base1(beta,i,"beta",1))), base_rng__));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ew_c,i,"mr_ew_c",1),t,"mr_ew_c",2), get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ew_nc,i,"mr_ew_nc",1),t,"mr_ew_nc",2), get_base1(ew,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ew",1));
                    stan::math::assign(ewt1, get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1));
                    stan::math::assign(get_base1_lhs(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1), ((get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1) * get_base1(rho,i,"rho",1)) + 1));
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), ((((get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) * get_base1(phi,i,"phi",1)) * ewt1) + get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) / get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1)));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_phi",mu_phi,0);
            check_less_or_equal(function__,"mu_phi",mu_phi,1);
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            check_less_or_equal(function__,"mu_rho",mu_rho,1);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,10);

            // write generated quantities
        vars__.push_back(mu_phi);
        vars__.push_back(mu_rho);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ew_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ew_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_ewa";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_phi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ew_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ew_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_phi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ew_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ew_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_fictitious_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_fictitious");
    reader.add_event(166, 166, "end", "model_prl_fictitious");
    return reader;
}

class model_prl_fictitious : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > outcome;
    vector_d initV;
public:
    model_prl_fictitious(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_fictitious(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_fictitious_namespace::model_prl_fictitious";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],2);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("eta_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_fictitious() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("eta_pr")))
            throw std::runtime_error("variable eta_pr missing");
        vals_r__ = context__.vals_r("eta_pr");
        pos__ = 0U;
        validate_non_negative_index("eta_pr", "N", N);
        context__.validate_dims("initialization", "eta_pr", "vector_d", context__.to_vec(N));
        vector_d eta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            eta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(eta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eta_pr: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_pr;
            (void) eta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                eta_pr = in__.vector_constrain(N,lp__);
            else
                eta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("eta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, DUMMY_VAR__);
            stan::math::fill(eta,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(eta,i,"eta",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pr,i,"eta_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }
            stan::math::assign(alpha, add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),alpha_pr)));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(eta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: eta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"eta",eta,0);
            check_less_or_equal(function__,"eta",eta,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(get_base1(sigma,1,"sigma",1), 0, 0.20000000000000001));
            lp_accum__.add(cauchy_log<propto__>(get_base1(sigma,2,"sigma",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(sigma,3,"sigma",1), 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(eta_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("prob", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  prob(static_cast<Eigen::VectorXd::Index>(2));
                (void) prob;  // dummy to suppress unused var warning

                stan::math::initialize(prob, DUMMY_VAR__);
                stan::math::fill(prob,DUMMY_VAR__);
                T__ PE;
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, DUMMY_VAR__);
                stan::math::fill(PE,DUMMY_VAR__);
                T__ PEnc;
                (void) PEnc;  // dummy to suppress unused var warning

                stan::math::initialize(PEnc, DUMMY_VAR__);
                stan::math::fill(PEnc,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(alpha,i,"alpha",1) - (get_base1(ev,1,"ev",1) - get_base1(ev,2,"ev",1))))))));
                    stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                    lp_accum__.add(categorical_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), prob));
                    stan::math::assign(PE, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(PEnc, (-(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1)));
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta,i,"eta",1) * PE)));
                    stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta,i,"eta",1) * PEnc)));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("eta_pr");
        names__.push_back("alpha_pr");
        names__.push_back("beta_pr");
        names__.push_back("eta");
        names__.push_back("alpha");
        names__.push_back("beta");
        names__.push_back("mu_eta");
        names__.push_back("mu_alpha");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_pe_c");
        names__.push_back("mr_pe_nc");
        names__.push_back("mr_dv");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_fictitious_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d eta_pr = in__.vector_constrain(N);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("eta", "N", N);
            vector_d eta(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eta,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(eta,i,"eta",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pr,i,"eta_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }
            stan::math::assign(alpha, add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),alpha_pr)));

            // validate transformed parameters
            check_greater_or_equal(function__,"eta",eta,0);
            check_less_or_equal(function__,"eta",eta,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_eta(0.0);
            (void) mu_eta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_eta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_eta,DUMMY_VAR__);
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<double> > mr_ev_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<double> > mr_ev_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_pe_c", "N", N);
            validate_non_negative_index("mr_pe_c", "T", T);
            vector<vector<double> > mr_pe_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_c,DUMMY_VAR__);
            validate_non_negative_index("mr_pe_nc", "N", N);
            validate_non_negative_index("mr_pe_nc", "T", T);
            vector<vector<double> > mr_pe_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_dv", "N", N);
            validate_non_negative_index("mr_dv", "T", T);
            vector<vector<double> > mr_dv(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_dv, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_dv,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),t,"mr_pe_c",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),t,"mr_pe_nc",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),t,"mr_dv",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_eta, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_alpha, get_base1(mu_p,2,"mu_p",1));
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("prob", "2", 2);
                vector_d prob(static_cast<Eigen::VectorXd::Index>(2));
                (void) prob;  // dummy to suppress unused var warning

                stan::math::initialize(prob, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(prob,DUMMY_VAR__);
                double PE(0.0);
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PE,DUMMY_VAR__);
                double PEnc(0.0);
                (void) PEnc;  // dummy to suppress unused var warning

                stan::math::initialize(PEnc, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEnc,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(alpha,i,"alpha",1) - (get_base1(ev,1,"ev",1) - get_base1(ev,2,"ev",1))))))));
                    stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),prob)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(prob, base_rng__));
                    stan::math::assign(PE, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(PEnc, (-(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),t,"mr_pe_c",2), PE);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),t,"mr_pe_nc",2), PEnc);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),t,"mr_dv",2), (PE - PEnc));
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta,i,"eta",1) * PE)));
                    stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta,i,"eta",1) * PEnc)));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_eta",mu_eta,0);
            check_less_or_equal(function__,"mu_eta",mu_eta,1);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,5);

            // write generated quantities
        vars__.push_back(mu_eta);
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_dv[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_fictitious";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_fictitious_multipleB_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_fictitious_multipleB");
    reader.add_event(176, 176, "end", "model_prl_fictitious_multipleB");
    return reader;
}

class model_prl_fictitious_multipleB : public prob_grad {
private:
    int N;
    int T;
    int maxB;
    vector<int> B;
    vector<vector<int> > Tsubj;
    vector<vector<vector<int> > > choice;
    vector<vector<vector<double> > > outcome;
    vector_d initV;
public:
    model_prl_fictitious_multipleB(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_fictitious_multipleB(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_fictitious_multipleB_namespace::model_prl_fictitious_multipleB";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            context__.validate_dims("data initialization", "maxB", "int", context__.to_vec());
            maxB = int(0);
            vals_i__ = context__.vals_i("maxB");
            pos__ = 0;
            maxB = vals_i__[pos__++];
            validate_non_negative_index("B", "N", N);
            context__.validate_dims("data initialization", "B", "int", context__.to_vec(N));
            validate_non_negative_index("B", "N", N);
            B = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("B");
            pos__ = 0;
            size_t B_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < B_limit_0__; ++i_0__) {
                B[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("Tsubj", "N", N);
            validate_non_negative_index("Tsubj", "maxB", maxB);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N,maxB));
            validate_non_negative_index("Tsubj", "N", N);
            validate_non_negative_index("Tsubj", "maxB", maxB);
            Tsubj = std::vector<std::vector<int> >(N,std::vector<int>(maxB,int(0)));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_1__ = maxB;
            for (size_t i_1__ = 0; i_1__ < Tsubj_limit_1__; ++i_1__) {
                size_t Tsubj_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                    Tsubj[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "maxB", maxB);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,maxB,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "maxB", maxB);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<std::vector<int> > >(N,std::vector<std::vector<int> >(maxB,std::vector<int>(T,int(0))));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_2__ = T;
            for (size_t i_2__ = 0; i_2__ < choice_limit_2__; ++i_2__) {
                size_t choice_limit_1__ = maxB;
                for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                    size_t choice_limit_0__ = N;
                    for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                        choice[i_0__][i_1__][i_2__] = vals_i__[pos__++];
                    }
                }
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "maxB", maxB);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,maxB,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "maxB", maxB);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<std::vector<double> > >(N,std::vector<std::vector<double> >(maxB,std::vector<double>(T,double(0))));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_2__ = T;
            for (size_t i_2__ = 0; i_2__ < outcome_limit_2__; ++i_2__) {
                size_t outcome_limit_1__ = maxB;
                for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                    size_t outcome_limit_0__ = N;
                    for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                        outcome[i_0__][i_1__][i_2__] = vals_r__[pos__++];
                    }
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,0);
            check_greater_or_equal(function__,"maxB",maxB,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"B[k0__]",B[k0__],1);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < maxB; ++k1__) {
                    check_greater_or_equal(function__,"Tsubj[k0__][k1__]",Tsubj[k0__][k1__],0);
                    check_less_or_equal(function__,"Tsubj[k0__][k1__]",Tsubj[k0__][k1__],T);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < maxB; ++k1__) {
                    for (int k2__ = 0; k2__ < T; ++k2__) {
                        check_greater_or_equal(function__,"choice[k0__][k1__][k2__]",choice[k0__][k1__][k2__],-(1));
                        check_less_or_equal(function__,"choice[k0__][k1__][k2__]",choice[k0__][k1__][k2__],2);
                    }
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("eta_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_fictitious_multipleB() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("eta_pr")))
            throw std::runtime_error("variable eta_pr missing");
        vals_r__ = context__.vals_r("eta_pr");
        pos__ = 0U;
        validate_non_negative_index("eta_pr", "N", N);
        context__.validate_dims("initialization", "eta_pr", "vector_d", context__.to_vec(N));
        vector_d eta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            eta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(eta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eta_pr: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_pr;
            (void) eta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                eta_pr = in__.vector_constrain(N,lp__);
            else
                eta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("eta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, DUMMY_VAR__);
            stan::math::fill(eta,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(eta,i,"eta",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pr,i,"eta_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }
            stan::math::assign(alpha, add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),alpha_pr)));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(eta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: eta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"eta",eta,0);
            check_less_or_equal(function__,"eta",eta,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(get_base1(sigma,1,"sigma",1), 0, 0.20000000000000001));
            lp_accum__.add(cauchy_log<propto__>(get_base1(sigma,2,"sigma",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(sigma,3,"sigma",1), 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(eta_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {

                for (int bIdx = 1; bIdx <= get_base1(B,i,"B",1); ++bIdx) {
                    {
                    validate_non_negative_index("ev", "2", 2);
                    Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                    (void) ev;  // dummy to suppress unused var warning

                    stan::math::initialize(ev, DUMMY_VAR__);
                    stan::math::fill(ev,DUMMY_VAR__);
                    validate_non_negative_index("prob", "2", 2);
                    Eigen::Matrix<T__,Eigen::Dynamic,1>  prob(static_cast<Eigen::VectorXd::Index>(2));
                    (void) prob;  // dummy to suppress unused var warning

                    stan::math::initialize(prob, DUMMY_VAR__);
                    stan::math::fill(prob,DUMMY_VAR__);
                    T__ PE;
                    (void) PE;  // dummy to suppress unused var warning

                    stan::math::initialize(PE, DUMMY_VAR__);
                    stan::math::fill(PE,DUMMY_VAR__);
                    T__ PEnc;
                    (void) PEnc;  // dummy to suppress unused var warning

                    stan::math::initialize(PEnc, DUMMY_VAR__);
                    stan::math::fill(PEnc,DUMMY_VAR__);


                    stan::math::assign(ev, initV);
                    for (int t = 1; t <= get_base1(get_base1(Tsubj,i,"Tsubj",1),bIdx,"Tsubj",2); ++t) {

                        stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(alpha,i,"alpha",1) - (get_base1(ev,1,"ev",1) - get_base1(ev,2,"ev",1))))))));
                        stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                        lp_accum__.add(categorical_log<propto__>(get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3), prob));
                        stan::math::assign(PE, (get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3) - get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1)));
                        stan::math::assign(PEnc, (-(get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3)) - get_base1(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1)));
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1), (get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1) + (get_base1(eta,i,"eta",1) * PE)));
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1) + (get_base1(eta,i,"eta",1) * PEnc)));
                    }
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("eta_pr");
        names__.push_back("alpha_pr");
        names__.push_back("beta_pr");
        names__.push_back("eta");
        names__.push_back("alpha");
        names__.push_back("beta");
        names__.push_back("mu_eta");
        names__.push_back("mu_alpha");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_pe_c");
        names__.push_back("mr_pe_nc");
        names__.push_back("mr_dv");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_fictitious_multipleB_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d eta_pr = in__.vector_constrain(N);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("eta", "N", N);
            vector_d eta(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eta,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(eta,i,"eta",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pr,i,"eta_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }
            stan::math::assign(alpha, add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),alpha_pr)));

            // validate transformed parameters
            check_greater_or_equal(function__,"eta",eta,0);
            check_less_or_equal(function__,"eta",eta,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_eta(0.0);
            (void) mu_eta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_eta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_eta,DUMMY_VAR__);
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "maxB", maxB);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<vector<double> > > mr_ev_c(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "maxB", maxB);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<vector<double> > > mr_ev_nc(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_pe_c", "N", N);
            validate_non_negative_index("mr_pe_c", "maxB", maxB);
            validate_non_negative_index("mr_pe_c", "T", T);
            vector<vector<vector<double> > > mr_pe_c(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_pe_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_c,DUMMY_VAR__);
            validate_non_negative_index("mr_pe_nc", "N", N);
            validate_non_negative_index("mr_pe_nc", "maxB", maxB);
            validate_non_negative_index("mr_pe_nc", "T", T);
            vector<vector<vector<double> > > mr_pe_nc(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_pe_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_dv", "N", N);
            validate_non_negative_index("mr_dv", "maxB", maxB);
            validate_non_negative_index("mr_dv", "T", T);
            vector<vector<vector<double> > > mr_dv(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_dv, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_dv,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "maxB", maxB);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<vector<double> > > y_pred(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int b = 1; b <= maxB; ++b) {

                    for (int t = 1; t <= T; ++t) {

                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),b,"mr_ev_c",2),t,"mr_ev_c",3), 0);
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),b,"mr_ev_nc",2),t,"mr_ev_nc",3), 0);
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),b,"mr_pe_c",2),t,"mr_pe_c",3), 0);
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),b,"mr_pe_nc",2),t,"mr_pe_nc",3), 0);
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),b,"mr_dv",2),t,"mr_dv",3), 0);
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),b,"y_pred",2),t,"y_pred",3), -(1));
                    }
                }
            }
            stan::math::assign(mu_eta, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_alpha, get_base1(mu_p,2,"mu_p",1));
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 10));

            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int bIdx = 1; bIdx <= get_base1(B,i,"B",1); ++bIdx) {
                    {
                    validate_non_negative_index("ev", "2", 2);
                    vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                    (void) ev;  // dummy to suppress unused var warning

                    stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(ev,DUMMY_VAR__);
                    validate_non_negative_index("prob", "2", 2);
                    vector_d prob(static_cast<Eigen::VectorXd::Index>(2));
                    (void) prob;  // dummy to suppress unused var warning

                    stan::math::initialize(prob, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(prob,DUMMY_VAR__);
                    double PE(0.0);
                    (void) PE;  // dummy to suppress unused var warning

                    stan::math::initialize(PE, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(PE,DUMMY_VAR__);
                    double PEnc(0.0);
                    (void) PEnc;  // dummy to suppress unused var warning

                    stan::math::initialize(PEnc, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(PEnc,DUMMY_VAR__);


                    stan::math::assign(ev, initV);
                    for (int t = 1; t <= get_base1(get_base1(Tsubj,i,"Tsubj",1),bIdx,"Tsubj",2); ++t) {

                        stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(alpha,i,"alpha",1) - (get_base1(ev,1,"ev",1) - get_base1(ev,2,"ev",1))))))));
                        stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                        stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_log(get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),prob)));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),bIdx,"y_pred",2),t,"y_pred",3), categorical_rng(prob, base_rng__));
                        stan::math::assign(PE, (get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3) - get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1)));
                        stan::math::assign(PEnc, (-(get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3)) - get_base1(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1)));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),bIdx,"mr_ev_c",2),t,"mr_ev_c",3), get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),bIdx,"mr_ev_nc",2),t,"mr_ev_nc",3), get_base1(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),bIdx,"mr_pe_c",2),t,"mr_pe_c",3), PE);
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),bIdx,"mr_pe_nc",2),t,"mr_pe_nc",3), PEnc);
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),bIdx,"mr_dv",2),t,"mr_dv",3), (PE - PEnc));
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1), (get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1) + (get_base1(eta,i,"eta",1) * PE)));
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1) + (get_base1(eta,i,"eta",1) * PEnc)));
                    }
                    }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_eta",mu_eta,0);
            check_less_or_equal(function__,"mu_eta",mu_eta,1);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,10);

            // write generated quantities
        vars__.push_back(mu_eta);
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_ev_c[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_ev_nc[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_pe_c[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_pe_nc[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_dv[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(y_pred[k_0__][k_1__][k_2__]);
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_fictitious_multipleB";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_fictitious_rp_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_fictitious_rp");
    reader.add_event(181, 181, "end", "model_prl_fictitious_rp");
    return reader;
}

class model_prl_fictitious_rp : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > outcome;
    vector_d initV;
public:
    model_prl_fictitious_rp(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_fictitious_rp(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_fictitious_rp_namespace::model_prl_fictitious_rp";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],2);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("eta_pos_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("eta_neg_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_fictitious_rp() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("eta_pos_pr")))
            throw std::runtime_error("variable eta_pos_pr missing");
        vals_r__ = context__.vals_r("eta_pos_pr");
        pos__ = 0U;
        validate_non_negative_index("eta_pos_pr", "N", N);
        context__.validate_dims("initialization", "eta_pos_pr", "vector_d", context__.to_vec(N));
        vector_d eta_pos_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            eta_pos_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(eta_pos_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eta_pos_pr: ") + e.what());
        }

        if (!(context__.contains_r("eta_neg_pr")))
            throw std::runtime_error("variable eta_neg_pr missing");
        vals_r__ = context__.vals_r("eta_neg_pr");
        pos__ = 0U;
        validate_non_negative_index("eta_neg_pr", "N", N);
        context__.validate_dims("initialization", "eta_neg_pr", "vector_d", context__.to_vec(N));
        vector_d eta_neg_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            eta_neg_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(eta_neg_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eta_neg_pr: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_pos_pr;
            (void) eta_pos_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                eta_pos_pr = in__.vector_constrain(N,lp__);
            else
                eta_pos_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_neg_pr;
            (void) eta_neg_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                eta_neg_pr = in__.vector_constrain(N,lp__);
            else
                eta_neg_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("eta_pos", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_pos(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta_pos;  // dummy to suppress unused var warning

            stan::math::initialize(eta_pos, DUMMY_VAR__);
            stan::math::fill(eta_pos,DUMMY_VAR__);
            validate_non_negative_index("eta_neg", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_neg(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta_neg;  // dummy to suppress unused var warning

            stan::math::initialize(eta_neg, DUMMY_VAR__);
            stan::math::fill(eta_neg,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(eta_pos,i,"eta_pos",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pos_pr,i,"eta_pos_pr",1)))));
                stan::math::assign(get_base1_lhs(eta_neg,i,"eta_neg",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(eta_neg_pr,i,"eta_neg_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }
            stan::math::assign(alpha, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),alpha_pr)));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(eta_pos(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: eta_pos" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(eta_neg(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: eta_neg" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"eta_pos",eta_pos,0);
            check_less_or_equal(function__,"eta_pos",eta_pos,1);
            check_greater_or_equal(function__,"eta_neg",eta_neg,0);
            check_less_or_equal(function__,"eta_neg",eta_neg,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "sigma"), 0, 0.20000000000000001));
            lp_accum__.add(cauchy_log<propto__>(get_base1(sigma,3,"sigma",1), 0, 1.0));
            lp_accum__.add(normal_log<propto__>(get_base1(sigma,4,"sigma",1), 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(eta_pos_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(eta_neg_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("prob", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  prob(static_cast<Eigen::VectorXd::Index>(2));
                (void) prob;  // dummy to suppress unused var warning

                stan::math::initialize(prob, DUMMY_VAR__);
                stan::math::fill(prob,DUMMY_VAR__);
                T__ pe_c;
                (void) pe_c;  // dummy to suppress unused var warning

                stan::math::initialize(pe_c, DUMMY_VAR__);
                stan::math::fill(pe_c,DUMMY_VAR__);
                T__ pe_nc;
                (void) pe_nc;  // dummy to suppress unused var warning

                stan::math::initialize(pe_nc, DUMMY_VAR__);
                stan::math::fill(pe_nc,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(alpha,i,"alpha",1) - (get_base1(ev,1,"ev",1) - get_base1(ev,2,"ev",1))))))));
                    stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                    lp_accum__.add(categorical_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), prob));
                    stan::math::assign(pe_c, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(pe_nc, (-(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1)));
                    if (as_bool(logical_gte(pe_c,0))) {

                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta_pos,i,"eta_pos",1) * pe_c)));
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta_pos,i,"eta_pos",1) * pe_nc)));
                    } else {

                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta_neg,i,"eta_neg",1) * pe_c)));
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta_neg,i,"eta_neg",1) * pe_nc)));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("eta_pos_pr");
        names__.push_back("eta_neg_pr");
        names__.push_back("alpha_pr");
        names__.push_back("beta_pr");
        names__.push_back("eta_pos");
        names__.push_back("eta_neg");
        names__.push_back("alpha");
        names__.push_back("beta");
        names__.push_back("mu_eta_pos");
        names__.push_back("mu_eta_neg");
        names__.push_back("mu_alpha");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_pe_c");
        names__.push_back("mr_pe_nc");
        names__.push_back("mr_dv");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_fictitious_rp_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d eta_pos_pr = in__.vector_constrain(N);
        vector_d eta_neg_pr = in__.vector_constrain(N);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_pos_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_neg_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("eta_pos", "N", N);
            vector_d eta_pos(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta_pos;  // dummy to suppress unused var warning

            stan::math::initialize(eta_pos, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eta_pos,DUMMY_VAR__);
            validate_non_negative_index("eta_neg", "N", N);
            vector_d eta_neg(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta_neg;  // dummy to suppress unused var warning

            stan::math::initialize(eta_neg, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eta_neg,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(eta_pos,i,"eta_pos",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pos_pr,i,"eta_pos_pr",1)))));
                stan::math::assign(get_base1_lhs(eta_neg,i,"eta_neg",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(eta_neg_pr,i,"eta_neg_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }
            stan::math::assign(alpha, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),alpha_pr)));

            // validate transformed parameters
            check_greater_or_equal(function__,"eta_pos",eta_pos,0);
            check_less_or_equal(function__,"eta_pos",eta_pos,1);
            check_greater_or_equal(function__,"eta_neg",eta_neg,0);
            check_less_or_equal(function__,"eta_neg",eta_neg,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_pos[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_neg[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_eta_pos(0.0);
            (void) mu_eta_pos;  // dummy to suppress unused var warning

            stan::math::initialize(mu_eta_pos, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_eta_pos,DUMMY_VAR__);
            double mu_eta_neg(0.0);
            (void) mu_eta_neg;  // dummy to suppress unused var warning

            stan::math::initialize(mu_eta_neg, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_eta_neg,DUMMY_VAR__);
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<double> > mr_ev_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<double> > mr_ev_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_pe_c", "N", N);
            validate_non_negative_index("mr_pe_c", "T", T);
            vector<vector<double> > mr_pe_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_c,DUMMY_VAR__);
            validate_non_negative_index("mr_pe_nc", "N", N);
            validate_non_negative_index("mr_pe_nc", "T", T);
            vector<vector<double> > mr_pe_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_dv", "N", N);
            validate_non_negative_index("mr_dv", "T", T);
            vector<vector<double> > mr_dv(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_dv, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_dv,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),t,"mr_pe_c",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),t,"mr_pe_nc",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),t,"mr_dv",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_eta_pos, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_eta_neg, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_alpha, get_base1(mu_p,3,"mu_p",1));
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,4,"mu_p",1)) * 5));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("prob", "2", 2);
                vector_d prob(static_cast<Eigen::VectorXd::Index>(2));
                (void) prob;  // dummy to suppress unused var warning

                stan::math::initialize(prob, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(prob,DUMMY_VAR__);
                double pe_c(0.0);
                (void) pe_c;  // dummy to suppress unused var warning

                stan::math::initialize(pe_c, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pe_c,DUMMY_VAR__);
                double pe_nc(0.0);
                (void) pe_nc;  // dummy to suppress unused var warning

                stan::math::initialize(pe_nc, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pe_nc,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(alpha,i,"alpha",1) - (get_base1(ev,1,"ev",1) - get_base1(ev,2,"ev",1))))))));
                    stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),prob)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(prob, base_rng__));
                    stan::math::assign(pe_c, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(pe_nc, (-(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),t,"mr_pe_c",2), pe_c);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),t,"mr_pe_nc",2), pe_nc);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),t,"mr_dv",2), (pe_c - pe_nc));
                    if (as_bool(logical_gte(pe_c,0))) {

                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta_pos,i,"eta_pos",1) * pe_c)));
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta_pos,i,"eta_pos",1) * pe_nc)));
                    } else {

                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta_neg,i,"eta_neg",1) * pe_c)));
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta_neg,i,"eta_neg",1) * pe_nc)));
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_eta_pos",mu_eta_pos,0);
            check_less_or_equal(function__,"mu_eta_pos",mu_eta_pos,1);
            check_greater_or_equal(function__,"mu_eta_neg",mu_eta_neg,0);
            check_less_or_equal(function__,"mu_eta_neg",mu_eta_neg,1);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,5);

            // write generated quantities
        vars__.push_back(mu_eta_pos);
        vars__.push_back(mu_eta_neg);
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_dv[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_fictitious_rp";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pos_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_neg_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pos" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_neg" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta_pos";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta_neg";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pos_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_neg_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pos" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_neg" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta_pos";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta_neg";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_fictitious_rp_woa_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_fictitious_rp_woa");
    reader.add_event(173, 173, "end", "model_prl_fictitious_rp_woa");
    return reader;
}

class model_prl_fictitious_rp_woa : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > outcome;
    vector_d initV;
public:
    model_prl_fictitious_rp_woa(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_fictitious_rp_woa(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_fictitious_rp_woa_namespace::model_prl_fictitious_rp_woa";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],2);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("eta_pos_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("eta_neg_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_fictitious_rp_woa() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("eta_pos_pr")))
            throw std::runtime_error("variable eta_pos_pr missing");
        vals_r__ = context__.vals_r("eta_pos_pr");
        pos__ = 0U;
        validate_non_negative_index("eta_pos_pr", "N", N);
        context__.validate_dims("initialization", "eta_pos_pr", "vector_d", context__.to_vec(N));
        vector_d eta_pos_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            eta_pos_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(eta_pos_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eta_pos_pr: ") + e.what());
        }

        if (!(context__.contains_r("eta_neg_pr")))
            throw std::runtime_error("variable eta_neg_pr missing");
        vals_r__ = context__.vals_r("eta_neg_pr");
        pos__ = 0U;
        validate_non_negative_index("eta_neg_pr", "N", N);
        context__.validate_dims("initialization", "eta_neg_pr", "vector_d", context__.to_vec(N));
        vector_d eta_neg_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            eta_neg_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(eta_neg_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eta_neg_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_pos_pr;
            (void) eta_pos_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                eta_pos_pr = in__.vector_constrain(N,lp__);
            else
                eta_pos_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_neg_pr;
            (void) eta_neg_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                eta_neg_pr = in__.vector_constrain(N,lp__);
            else
                eta_neg_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("eta_pos", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_pos(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta_pos;  // dummy to suppress unused var warning

            stan::math::initialize(eta_pos, DUMMY_VAR__);
            stan::math::fill(eta_pos,DUMMY_VAR__);
            validate_non_negative_index("eta_neg", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_neg(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta_neg;  // dummy to suppress unused var warning

            stan::math::initialize(eta_neg, DUMMY_VAR__);
            stan::math::fill(eta_neg,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(eta_pos,i,"eta_pos",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pos_pr,i,"eta_pos_pr",1)))));
                stan::math::assign(get_base1_lhs(eta_neg,i,"eta_neg",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(eta_neg_pr,i,"eta_neg_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(eta_pos(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: eta_pos" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(eta_neg(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: eta_neg" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"eta_pos",eta_pos,0);
            check_less_or_equal(function__,"eta_pos",eta_pos,1);
            check_greater_or_equal(function__,"eta_neg",eta_neg,0);
            check_less_or_equal(function__,"eta_neg",eta_neg,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(eta_pos_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(eta_neg_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("prob", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  prob(static_cast<Eigen::VectorXd::Index>(2));
                (void) prob;  // dummy to suppress unused var warning

                stan::math::initialize(prob, DUMMY_VAR__);
                stan::math::fill(prob,DUMMY_VAR__);
                T__ pe_c;
                (void) pe_c;  // dummy to suppress unused var warning

                stan::math::initialize(pe_c, DUMMY_VAR__);
                stan::math::fill(pe_c,DUMMY_VAR__);
                T__ pe_nc;
                (void) pe_nc;  // dummy to suppress unused var warning

                stan::math::initialize(pe_nc, DUMMY_VAR__);
                stan::math::fill(pe_nc,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(ev,2,"ev",1) - get_base1(ev,1,"ev",1)))))));
                    stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                    lp_accum__.add(categorical_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), prob));
                    stan::math::assign(pe_c, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(pe_nc, (-(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1)));
                    if (as_bool(logical_gte(pe_c,0))) {

                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta_pos,i,"eta_pos",1) * pe_c)));
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta_pos,i,"eta_pos",1) * pe_nc)));
                    } else {

                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta_neg,i,"eta_neg",1) * pe_c)));
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta_neg,i,"eta_neg",1) * pe_nc)));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("eta_pos_pr");
        names__.push_back("eta_neg_pr");
        names__.push_back("beta_pr");
        names__.push_back("eta_pos");
        names__.push_back("eta_neg");
        names__.push_back("beta");
        names__.push_back("mu_eta_pos");
        names__.push_back("mu_eta_neg");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_pe_c");
        names__.push_back("mr_pe_nc");
        names__.push_back("mr_dv");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_fictitious_rp_woa_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d eta_pos_pr = in__.vector_constrain(N);
        vector_d eta_neg_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_pos_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_neg_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("eta_pos", "N", N);
            vector_d eta_pos(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta_pos;  // dummy to suppress unused var warning

            stan::math::initialize(eta_pos, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eta_pos,DUMMY_VAR__);
            validate_non_negative_index("eta_neg", "N", N);
            vector_d eta_neg(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta_neg;  // dummy to suppress unused var warning

            stan::math::initialize(eta_neg, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eta_neg,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(eta_pos,i,"eta_pos",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pos_pr,i,"eta_pos_pr",1)))));
                stan::math::assign(get_base1_lhs(eta_neg,i,"eta_neg",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(eta_neg_pr,i,"eta_neg_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"eta_pos",eta_pos,0);
            check_less_or_equal(function__,"eta_pos",eta_pos,1);
            check_greater_or_equal(function__,"eta_neg",eta_neg,0);
            check_less_or_equal(function__,"eta_neg",eta_neg,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_pos[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_neg[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_eta_pos(0.0);
            (void) mu_eta_pos;  // dummy to suppress unused var warning

            stan::math::initialize(mu_eta_pos, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_eta_pos,DUMMY_VAR__);
            double mu_eta_neg(0.0);
            (void) mu_eta_neg;  // dummy to suppress unused var warning

            stan::math::initialize(mu_eta_neg, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_eta_neg,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<double> > mr_ev_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<double> > mr_ev_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_pe_c", "N", N);
            validate_non_negative_index("mr_pe_c", "T", T);
            vector<vector<double> > mr_pe_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_c,DUMMY_VAR__);
            validate_non_negative_index("mr_pe_nc", "N", N);
            validate_non_negative_index("mr_pe_nc", "T", T);
            vector<vector<double> > mr_pe_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_dv", "N", N);
            validate_non_negative_index("mr_dv", "T", T);
            vector<vector<double> > mr_dv(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_dv, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_dv,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),t,"mr_pe_c",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),t,"mr_pe_nc",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),t,"mr_dv",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_eta_pos, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_eta_neg, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("prob", "2", 2);
                vector_d prob(static_cast<Eigen::VectorXd::Index>(2));
                (void) prob;  // dummy to suppress unused var warning

                stan::math::initialize(prob, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(prob,DUMMY_VAR__);
                double pe_c(0.0);
                (void) pe_c;  // dummy to suppress unused var warning

                stan::math::initialize(pe_c, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pe_c,DUMMY_VAR__);
                double pe_nc(0.0);
                (void) pe_nc;  // dummy to suppress unused var warning

                stan::math::initialize(pe_nc, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pe_nc,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(ev,2,"ev",1) - get_base1(ev,1,"ev",1)))))));
                    stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),prob)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(prob, base_rng__));
                    stan::math::assign(pe_c, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(pe_nc, (-(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),t,"mr_pe_c",2), pe_c);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),t,"mr_pe_nc",2), pe_nc);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),t,"mr_dv",2), (pe_c - pe_nc));
                    if (as_bool(logical_gte(pe_c,0))) {

                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta_pos,i,"eta_pos",1) * pe_c)));
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta_pos,i,"eta_pos",1) * pe_nc)));
                    } else {

                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta_neg,i,"eta_neg",1) * pe_c)));
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta_neg,i,"eta_neg",1) * pe_nc)));
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_eta_pos",mu_eta_pos,0);
            check_less_or_equal(function__,"mu_eta_pos",mu_eta_pos,1);
            check_greater_or_equal(function__,"mu_eta_neg",mu_eta_neg,0);
            check_less_or_equal(function__,"mu_eta_neg",mu_eta_neg,1);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,5);

            // write generated quantities
        vars__.push_back(mu_eta_pos);
        vars__.push_back(mu_eta_neg);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_dv[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_fictitious_rp_woa";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pos_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_neg_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pos" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_neg" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta_pos";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta_neg";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pos_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_neg_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pos" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_neg" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta_pos";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta_neg";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_fictitious_woa_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_fictitious_woa");
    reader.add_event(158, 158, "end", "model_prl_fictitious_woa");
    return reader;
}

class model_prl_fictitious_woa : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > outcome;
    vector_d initV;
public:
    model_prl_fictitious_woa(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_fictitious_woa(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_fictitious_woa_namespace::model_prl_fictitious_woa";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],2);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            validate_non_negative_index("eta_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_fictitious_woa() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("eta_pr")))
            throw std::runtime_error("variable eta_pr missing");
        vals_r__ = context__.vals_r("eta_pr");
        pos__ = 0U;
        validate_non_negative_index("eta_pr", "N", N);
        context__.validate_dims("initialization", "eta_pr", "vector_d", context__.to_vec(N));
        vector_d eta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            eta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(eta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eta_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_pr;
            (void) eta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                eta_pr = in__.vector_constrain(N,lp__);
            else
                eta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("eta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, DUMMY_VAR__);
            stan::math::fill(eta,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(eta,i,"eta",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pr,i,"eta_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(eta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: eta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"eta",eta,0);
            check_less_or_equal(function__,"eta",eta,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(eta_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("prob", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  prob(static_cast<Eigen::VectorXd::Index>(2));
                (void) prob;  // dummy to suppress unused var warning

                stan::math::initialize(prob, DUMMY_VAR__);
                stan::math::fill(prob,DUMMY_VAR__);
                T__ PE;
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, DUMMY_VAR__);
                stan::math::fill(PE,DUMMY_VAR__);
                T__ PEnc;
                (void) PEnc;  // dummy to suppress unused var warning

                stan::math::initialize(PEnc, DUMMY_VAR__);
                stan::math::fill(PEnc,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(ev,2,"ev",1) - get_base1(ev,1,"ev",1)))))));
                    stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                    lp_accum__.add(categorical_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), prob));
                    stan::math::assign(PE, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(PEnc, (-(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1)));
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta,i,"eta",1) * PE)));
                    stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta,i,"eta",1) * PEnc)));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("eta_pr");
        names__.push_back("beta_pr");
        names__.push_back("eta");
        names__.push_back("beta");
        names__.push_back("mu_eta");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_pe_c");
        names__.push_back("mr_pe_nc");
        names__.push_back("mr_dv");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_fictitious_woa_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d eta_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("eta", "N", N);
            vector_d eta(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eta,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(eta,i,"eta",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pr,i,"eta_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"eta",eta,0);
            check_less_or_equal(function__,"eta",eta,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_eta(0.0);
            (void) mu_eta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_eta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_eta,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<double> > mr_ev_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<double> > mr_ev_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_pe_c", "N", N);
            validate_non_negative_index("mr_pe_c", "T", T);
            vector<vector<double> > mr_pe_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_c,DUMMY_VAR__);
            validate_non_negative_index("mr_pe_nc", "N", N);
            validate_non_negative_index("mr_pe_nc", "T", T);
            vector<vector<double> > mr_pe_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_dv", "N", N);
            validate_non_negative_index("mr_dv", "T", T);
            vector<vector<double> > mr_dv(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_dv, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_dv,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),t,"mr_pe_c",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),t,"mr_pe_nc",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),t,"mr_dv",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_eta, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 5));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                validate_non_negative_index("prob", "2", 2);
                vector_d prob(static_cast<Eigen::VectorXd::Index>(2));
                (void) prob;  // dummy to suppress unused var warning

                stan::math::initialize(prob, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(prob,DUMMY_VAR__);
                double PE(0.0);
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PE,DUMMY_VAR__);
                double PEnc(0.0);
                (void) PEnc;  // dummy to suppress unused var warning

                stan::math::initialize(PEnc, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEnc,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(ev,2,"ev",1) - get_base1(ev,1,"ev",1)))))));
                    stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),prob)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(prob, base_rng__));
                    stan::math::assign(PE, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(PEnc, (-(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),t,"mr_pe_c",2), PE);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),t,"mr_pe_nc",2), PEnc);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),t,"mr_dv",2), (PE - PEnc));
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta,i,"eta",1) * PE)));
                    stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta,i,"eta",1) * PEnc)));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_eta",mu_eta,0);
            check_less_or_equal(function__,"mu_eta",mu_eta,1);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,5);

            // write generated quantities
        vars__.push_back(mu_eta);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_dv[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_fictitious_woa";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_rp_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_rp");
    reader.add_event(146, 146, "end", "model_prl_rp");
    return reader;
}

class model_prl_rp : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > outcome;
    vector_d initV;
public:
    model_prl_rp(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_rp(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_rp_namespace::model_prl_rp";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],2);
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("Apun_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("Arew_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_rp() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("Apun_pr")))
            throw std::runtime_error("variable Apun_pr missing");
        vals_r__ = context__.vals_r("Apun_pr");
        pos__ = 0U;
        validate_non_negative_index("Apun_pr", "N", N);
        context__.validate_dims("initialization", "Apun_pr", "vector_d", context__.to_vec(N));
        vector_d Apun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Apun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Apun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Apun_pr: ") + e.what());
        }

        if (!(context__.contains_r("Arew_pr")))
            throw std::runtime_error("variable Arew_pr missing");
        vals_r__ = context__.vals_r("Arew_pr");
        pos__ = 0U;
        validate_non_negative_index("Arew_pr", "N", N);
        context__.validate_dims("initialization", "Arew_pr", "vector_d", context__.to_vec(N));
        vector_d Arew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Arew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Arew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Arew_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun_pr;
            (void) Apun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Apun_pr = in__.vector_constrain(N,lp__);
            else
                Apun_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew_pr;
            (void) Arew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Arew_pr = in__.vector_constrain(N,lp__);
            else
                Arew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("Apun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, DUMMY_VAR__);
            stan::math::fill(Apun,DUMMY_VAR__);
            validate_non_negative_index("Arew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, DUMMY_VAR__);
            stan::math::fill(Arew,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Apun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Apun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Arew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Arew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(Apun_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(Arew_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                T__ pe;
                (void) pe;  // dummy to suppress unused var warning

                stan::math::initialize(pe, DUMMY_VAR__);
                stan::math::fill(pe,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), multiply(ev,get_base1(beta,i,"beta",1))));
                    stan::math::assign(pe, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    if (as_bool(logical_gt(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(Arew,i,"Arew",1) * pe)));
                    } else {
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(Apun,i,"Apun",1) * pe)));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("Apun_pr");
        names__.push_back("Arew_pr");
        names__.push_back("beta_pr");
        names__.push_back("Apun");
        names__.push_back("Arew");
        names__.push_back("beta");
        names__.push_back("mu_Apun");
        names__.push_back("mu_Arew");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_pe");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_rp_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d Apun_pr = in__.vector_constrain(N);
        vector_d Arew_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("Apun", "N", N);
            vector_d Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Apun,DUMMY_VAR__);
            validate_non_negative_index("Arew", "N", N);
            vector_d Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Arew,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_Apun(0.0);
            (void) mu_Apun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Apun,DUMMY_VAR__);
            double mu_Arew(0.0);
            (void) mu_Arew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Arew,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<double> > mr_ev_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<double> > mr_ev_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_pe", "N", N);
            validate_non_negative_index("mr_pe", "T", T);
            vector<vector<double> > mr_pe(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe,i,"mr_pe",1),t,"mr_pe",2), 0);
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_Apun, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_Arew, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 10));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("ev", "2", 2);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                double pe(0.0);
                (void) pe;  // dummy to suppress unused var warning

                stan::math::initialize(pe, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pe,DUMMY_VAR__);


                stan::math::assign(ev, initV);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),multiply(ev,get_base1(beta,i,"beta",1)))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(multiply(ev,get_base1(beta,i,"beta",1))), base_rng__));
                    stan::math::assign(pe, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe,i,"mr_pe",1),t,"mr_pe",2), pe);
                    if (as_bool(logical_gt(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(Arew,i,"Arew",1) * pe)));
                    } else {
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(Apun,i,"Apun",1) * pe)));
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_Apun",mu_Apun,0);
            check_less_or_equal(function__,"mu_Apun",mu_Apun,1);
            check_greater_or_equal(function__,"mu_Arew",mu_Arew,0);
            check_less_or_equal(function__,"mu_Arew",mu_Arew,1);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,10);

            // write generated quantities
        vars__.push_back(mu_Apun);
        vars__.push_back(mu_Arew);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_rp";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_rp_multipleB_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_rp_multipleB");
    reader.add_event(157, 157, "end", "model_prl_rp_multipleB");
    return reader;
}

class model_prl_rp_multipleB : public prob_grad {
private:
    int N;
    int T;
    int maxB;
    vector<int> B;
    vector<vector<int> > Tsubj;
    vector<vector<vector<int> > > choice;
    vector<vector<vector<double> > > outcome;
    vector_d initV;
public:
    model_prl_rp_multipleB(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_rp_multipleB(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_rp_multipleB_namespace::model_prl_rp_multipleB";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            context__.validate_dims("data initialization", "maxB", "int", context__.to_vec());
            maxB = int(0);
            vals_i__ = context__.vals_i("maxB");
            pos__ = 0;
            maxB = vals_i__[pos__++];
            validate_non_negative_index("B", "N", N);
            context__.validate_dims("data initialization", "B", "int", context__.to_vec(N));
            validate_non_negative_index("B", "N", N);
            B = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("B");
            pos__ = 0;
            size_t B_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < B_limit_0__; ++i_0__) {
                B[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("Tsubj", "N", N);
            validate_non_negative_index("Tsubj", "maxB", maxB);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N,maxB));
            validate_non_negative_index("Tsubj", "N", N);
            validate_non_negative_index("Tsubj", "maxB", maxB);
            Tsubj = std::vector<std::vector<int> >(N,std::vector<int>(maxB,int(0)));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_1__ = maxB;
            for (size_t i_1__ = 0; i_1__ < Tsubj_limit_1__; ++i_1__) {
                size_t Tsubj_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                    Tsubj[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "maxB", maxB);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,maxB,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "maxB", maxB);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<std::vector<int> > >(N,std::vector<std::vector<int> >(maxB,std::vector<int>(T,int(0))));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_2__ = T;
            for (size_t i_2__ = 0; i_2__ < choice_limit_2__; ++i_2__) {
                size_t choice_limit_1__ = maxB;
                for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                    size_t choice_limit_0__ = N;
                    for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                        choice[i_0__][i_1__][i_2__] = vals_i__[pos__++];
                    }
                }
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "maxB", maxB);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,maxB,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "maxB", maxB);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<std::vector<double> > >(N,std::vector<std::vector<double> >(maxB,std::vector<double>(T,double(0))));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_2__ = T;
            for (size_t i_2__ = 0; i_2__ < outcome_limit_2__; ++i_2__) {
                size_t outcome_limit_1__ = maxB;
                for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                    size_t outcome_limit_0__ = N;
                    for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                        outcome[i_0__][i_1__][i_2__] = vals_r__[pos__++];
                    }
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,0);
            check_greater_or_equal(function__,"maxB",maxB,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"B[k0__]",B[k0__],1);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < maxB; ++k1__) {
                    check_greater_or_equal(function__,"Tsubj[k0__][k1__]",Tsubj[k0__][k1__],0);
                    check_less_or_equal(function__,"Tsubj[k0__][k1__]",Tsubj[k0__][k1__],T);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < maxB; ++k1__) {
                    for (int k2__ = 0; k2__ < T; ++k2__) {
                        check_greater_or_equal(function__,"choice[k0__][k1__][k2__]",choice[k0__][k1__][k2__],-(1));
                        check_less_or_equal(function__,"choice[k0__][k1__][k2__]",choice[k0__][k1__][k2__],2);
                    }
                }
            }
            // initialize data variables
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("Apun_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("Arew_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_rp_multipleB() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("Apun_pr")))
            throw std::runtime_error("variable Apun_pr missing");
        vals_r__ = context__.vals_r("Apun_pr");
        pos__ = 0U;
        validate_non_negative_index("Apun_pr", "N", N);
        context__.validate_dims("initialization", "Apun_pr", "vector_d", context__.to_vec(N));
        vector_d Apun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Apun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Apun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Apun_pr: ") + e.what());
        }

        if (!(context__.contains_r("Arew_pr")))
            throw std::runtime_error("variable Arew_pr missing");
        vals_r__ = context__.vals_r("Arew_pr");
        pos__ = 0U;
        validate_non_negative_index("Arew_pr", "N", N);
        context__.validate_dims("initialization", "Arew_pr", "vector_d", context__.to_vec(N));
        vector_d Arew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Arew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Arew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Arew_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun_pr;
            (void) Apun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Apun_pr = in__.vector_constrain(N,lp__);
            else
                Apun_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew_pr;
            (void) Arew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Arew_pr = in__.vector_constrain(N,lp__);
            else
                Arew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("Apun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, DUMMY_VAR__);
            stan::math::fill(Apun,DUMMY_VAR__);
            validate_non_negative_index("Arew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, DUMMY_VAR__);
            stan::math::fill(Arew,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Apun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Apun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Arew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Arew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(Apun_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(Arew_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {

                for (int bIdx = 1; bIdx <= get_base1(B,i,"B",1); ++bIdx) {
                    {
                    validate_non_negative_index("ev", "2", 2);
                    Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                    (void) ev;  // dummy to suppress unused var warning

                    stan::math::initialize(ev, DUMMY_VAR__);
                    stan::math::fill(ev,DUMMY_VAR__);
                    T__ pe;
                    (void) pe;  // dummy to suppress unused var warning

                    stan::math::initialize(pe, DUMMY_VAR__);
                    stan::math::fill(pe,DUMMY_VAR__);


                    stan::math::assign(ev, initV);
                    for (int t = 1; t <= get_base1(get_base1(Tsubj,i,"Tsubj",1),bIdx,"Tsubj",2); ++t) {

                        lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3), multiply(ev,get_base1(beta,i,"beta",1))));
                        stan::math::assign(pe, (get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3) - get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1)));
                        if (as_bool(logical_gt(get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3),0))) {
                            stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1), (get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1) + (get_base1(Arew,i,"Arew",1) * pe)));
                        } else {
                            stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1), (get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1) + (get_base1(Apun,i,"Apun",1) * pe)));
                        }
                    }
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("Apun_pr");
        names__.push_back("Arew_pr");
        names__.push_back("beta_pr");
        names__.push_back("Apun");
        names__.push_back("Arew");
        names__.push_back("beta");
        names__.push_back("mu_Apun");
        names__.push_back("mu_Arew");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_pe");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_rp_multipleB_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d Apun_pr = in__.vector_constrain(N);
        vector_d Arew_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("Apun", "N", N);
            vector_d Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Apun,DUMMY_VAR__);
            validate_non_negative_index("Arew", "N", N);
            vector_d Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Arew,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_Apun(0.0);
            (void) mu_Apun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Apun,DUMMY_VAR__);
            double mu_Arew(0.0);
            (void) mu_Arew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Arew,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "maxB", maxB);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<vector<double> > > mr_ev_c(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "maxB", maxB);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<vector<double> > > mr_ev_nc(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            validate_non_negative_index("mr_pe", "N", N);
            validate_non_negative_index("mr_pe", "maxB", maxB);
            validate_non_negative_index("mr_pe", "T", T);
            vector<vector<vector<double> > > mr_pe(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_pe, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "maxB", maxB);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<vector<double> > > y_pred(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int b = 1; b <= maxB; ++b) {

                    for (int t = 1; t <= T; ++t) {

                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),b,"mr_ev_c",2),t,"mr_ev_c",3), 0);
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),b,"mr_ev_nc",2),t,"mr_ev_nc",3), 0);
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_pe,i,"mr_pe",1),b,"mr_pe",2),t,"mr_pe",3), 0);
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),b,"y_pred",2),t,"y_pred",3), -(1));
                    }
                }
            }
            stan::math::assign(mu_Apun, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_Arew, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 10));

            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int bIdx = 1; bIdx <= get_base1(B,i,"B",1); ++bIdx) {
                    {
                    validate_non_negative_index("ev", "2", 2);
                    vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                    (void) ev;  // dummy to suppress unused var warning

                    stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(ev,DUMMY_VAR__);
                    double pe(0.0);
                    (void) pe;  // dummy to suppress unused var warning

                    stan::math::initialize(pe, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(pe,DUMMY_VAR__);


                    stan::math::assign(ev, initV);
                    for (int t = 1; t <= get_base1(get_base1(Tsubj,i,"Tsubj",1),bIdx,"Tsubj",2); ++t) {

                        stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),multiply(ev,get_base1(beta,i,"beta",1)))));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),bIdx,"y_pred",2),t,"y_pred",3), categorical_rng(softmax(multiply(ev,get_base1(beta,i,"beta",1))), base_rng__));
                        stan::math::assign(pe, (get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3) - get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1)));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),bIdx,"mr_ev_c",2),t,"mr_ev_c",3), get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),bIdx,"mr_ev_nc",2),t,"mr_ev_nc",3), get_base1(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_pe,i,"mr_pe",1),bIdx,"mr_pe",2),t,"mr_pe",3), pe);
                        if (as_bool(logical_gt(get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3),0))) {
                            stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1), (get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1) + (get_base1(Arew,i,"Arew",1) * pe)));
                        } else {
                            stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1), (get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1) + (get_base1(Apun,i,"Apun",1) * pe)));
                        }
                    }
                    }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_Apun",mu_Apun,0);
            check_less_or_equal(function__,"mu_Apun",mu_Apun,1);
            check_greater_or_equal(function__,"mu_Arew",mu_Arew,0);
            check_less_or_equal(function__,"mu_Arew",mu_Arew,1);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,10);

            // write generated quantities
        vars__.push_back(mu_Apun);
        vars__.push_back(mu_Arew);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_ev_c[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_ev_nc[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_pe[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(y_pred[k_0__][k_1__][k_2__]);
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_rp_multipleB";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_pe" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_pe" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_pst_gainloss_Q_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_pst_gainloss_Q");
    reader.add_event(111, 111, "end", "model_pst_gainloss_Q");
    return reader;
}

class model_pst_gainloss_Q : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > option1;
    vector<vector<int> > option2;
    vector<vector<int> > choice;
    vector<vector<double> > reward;
    vector_d initial_values;
public:
    model_pst_gainloss_Q(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_pst_gainloss_Q(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_pst_gainloss_Q_namespace::model_pst_gainloss_Q";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("option1", "N", N);
            validate_non_negative_index("option1", "T", T);
            context__.validate_dims("data initialization", "option1", "int", context__.to_vec(N,T));
            validate_non_negative_index("option1", "N", N);
            validate_non_negative_index("option1", "T", T);
            option1 = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("option1");
            pos__ = 0;
            size_t option1_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < option1_limit_1__; ++i_1__) {
                size_t option1_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < option1_limit_0__; ++i_0__) {
                    option1[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("option2", "N", N);
            validate_non_negative_index("option2", "T", T);
            context__.validate_dims("data initialization", "option2", "int", context__.to_vec(N,T));
            validate_non_negative_index("option2", "N", N);
            validate_non_negative_index("option2", "T", T);
            option2 = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("option2");
            pos__ = 0;
            size_t option2_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < option2_limit_1__; ++i_1__) {
                size_t option2_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < option2_limit_0__; ++i_0__) {
                    option2[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("reward", "N", N);
            validate_non_negative_index("reward", "T", T);
            context__.validate_dims("data initialization", "reward", "double", context__.to_vec(N,T));
            validate_non_negative_index("reward", "N", N);
            validate_non_negative_index("reward", "T", T);
            reward = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("reward");
            pos__ = 0;
            size_t reward_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < reward_limit_1__; ++i_1__) {
                size_t reward_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < reward_limit_0__; ++i_0__) {
                    reward[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"option1[k0__][k1__]",option1[k0__][k1__],-(1));
                    check_less_or_equal(function__,"option1[k0__][k1__]",option1[k0__][k1__],6);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"option2[k0__][k1__]",option2[k0__][k1__],-(1));
                    check_less_or_equal(function__,"option2[k0__][k1__]",option2[k0__][k1__],6);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],1);
                }
            }
            // initialize data variables
            validate_non_negative_index("initial_values", "6", 6);
            initial_values = vector_d(static_cast<Eigen::VectorXd::Index>(6));
            stan::math::fill(initial_values,DUMMY_VAR__);

            stan::math::assign(initial_values, rep_vector(0,6));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("alpha_pos_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("alpha_neg_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_pst_gainloss_Q() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu")))
            throw std::runtime_error("variable mu missing");
        vals_r__ = context__.vals_r("mu");
        pos__ = 0U;
        validate_non_negative_index("mu", "3", 3);
        context__.validate_dims("initialization", "mu", "vector_d", context__.to_vec(3));
        vector_d mu(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pos_pr")))
            throw std::runtime_error("variable alpha_pos_pr missing");
        vals_r__ = context__.vals_r("alpha_pos_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pos_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pos_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pos_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pos_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pos_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pos_pr: ") + e.what());
        }

        if (!(context__.contains_r("alpha_neg_pr")))
            throw std::runtime_error("variable alpha_neg_pr missing");
        vals_r__ = context__.vals_r("alpha_neg_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_neg_pr", "N", N);
        context__.validate_dims("initialization", "alpha_neg_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_neg_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_neg_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_neg_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_neg_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu;
            (void) mu;  // dummy to suppress unused var warning
            if (jacobian__)
                mu = in__.vector_constrain(3,lp__);
            else
                mu = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pos_pr;
            (void) alpha_pos_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pos_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pos_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_neg_pr;
            (void) alpha_neg_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_neg_pr = in__.vector_constrain(N,lp__);
            else
                alpha_neg_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("alpha_pos", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pos(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha_pos;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_pos, DUMMY_VAR__);
            stan::math::fill(alpha_pos,DUMMY_VAR__);
            validate_non_negative_index("alpha_neg", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_neg(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha_neg;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_neg, DUMMY_VAR__);
            stan::math::fill(alpha_neg,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            stan::math::assign(alpha_pos, Phi_approx(add(get_base1(mu,1,"mu",1),multiply(get_base1(sigma,1,"sigma",1),alpha_pos_pr))));
            stan::math::assign(alpha_neg, Phi_approx(add(get_base1(mu,2,"mu",1),multiply(get_base1(sigma,2,"sigma",1),alpha_neg_pr))));
            stan::math::assign(beta, multiply(Phi_approx(add(get_base1(mu,3,"mu",1),multiply(get_base1(sigma,3,"sigma",1),beta_pr))),10));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha_pos(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha_pos" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha_neg(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha_neg" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"alpha_pos",alpha_pos,0);
            check_less_or_equal(function__,"alpha_pos",alpha_pos,1);
            check_greater_or_equal(function__,"alpha_neg",alpha_neg,0);
            check_less_or_equal(function__,"alpha_neg",alpha_neg,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // model body

            lp_accum__.add(normal_log<propto__>(mu, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(alpha_pos_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(alpha_neg_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                int co(0);
                (void) co;  // dummy to suppress unused var warning

                stan::math::fill(co, std::numeric_limits<int>::min());
                T__ delta;
                (void) delta;  // dummy to suppress unused var warning

                stan::math::initialize(delta, DUMMY_VAR__);
                stan::math::fill(delta,DUMMY_VAR__);
                T__ pe;
                (void) pe;  // dummy to suppress unused var warning

                stan::math::initialize(pe, DUMMY_VAR__);
                stan::math::fill(pe,DUMMY_VAR__);
                T__ alpha;
                (void) alpha;  // dummy to suppress unused var warning

                stan::math::initialize(alpha, DUMMY_VAR__);
                stan::math::fill(alpha,DUMMY_VAR__);
                validate_non_negative_index("ev", "6", 6);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(6));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);


                stan::math::assign(ev, initial_values);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(co, (logical_gt(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),0) ? get_base1(get_base1(option1,i,"option1",1),t,"option1",2) : get_base1(get_base1(option2,i,"option2",1),t,"option2",2) ));
                    stan::math::assign(delta, (get_base1(ev,get_base1(get_base1(option1,i,"option1",1),t,"option1",2),"ev",1) - get_base1(ev,get_base1(get_base1(option2,i,"option2",1),t,"option2",2),"ev",1)));
                    lp_accum__.add(bernoulli_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),(get_base1(beta,i,"beta",1) * delta)));
                    stan::math::assign(pe, (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(ev,co,"ev",1)));
                    stan::math::assign(alpha, (logical_gte(pe,0) ? stan::math::promote_scalar<T__>(get_base1(alpha_pos,i,"alpha_pos",1)) : stan::math::promote_scalar<T__>(get_base1(alpha_neg,i,"alpha_neg",1)) ));
                    stan::math::assign(get_base1_lhs(ev,co,"ev",1), (get_base1(ev,co,"ev",1) + (alpha * pe)));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu");
        names__.push_back("sigma");
        names__.push_back("alpha_pos_pr");
        names__.push_back("alpha_neg_pr");
        names__.push_back("beta_pr");
        names__.push_back("alpha_pos");
        names__.push_back("alpha_neg");
        names__.push_back("beta");
        names__.push_back("mu_alpha_pos");
        names__.push_back("mu_alpha_neg");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_pst_gainloss_Q_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d alpha_pos_pr = in__.vector_constrain(N);
        vector_d alpha_neg_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pos_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_neg_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("alpha_pos", "N", N);
            vector_d alpha_pos(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha_pos;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_pos, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_pos,DUMMY_VAR__);
            validate_non_negative_index("alpha_neg", "N", N);
            vector_d alpha_neg(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha_neg;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_neg, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_neg,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            stan::math::assign(alpha_pos, Phi_approx(add(get_base1(mu,1,"mu",1),multiply(get_base1(sigma,1,"sigma",1),alpha_pos_pr))));
            stan::math::assign(alpha_neg, Phi_approx(add(get_base1(mu,2,"mu",1),multiply(get_base1(sigma,2,"sigma",1),alpha_neg_pr))));
            stan::math::assign(beta, multiply(Phi_approx(add(get_base1(mu,3,"mu",1),multiply(get_base1(sigma,3,"sigma",1),beta_pr))),10));

            // validate transformed parameters
            check_greater_or_equal(function__,"alpha_pos",alpha_pos,0);
            check_less_or_equal(function__,"alpha_pos",alpha_pos,1);
            check_greater_or_equal(function__,"alpha_neg",alpha_neg,0);
            check_less_or_equal(function__,"alpha_neg",alpha_neg,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pos[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_neg[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_alpha_pos(0.0);
            (void) mu_alpha_pos;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha_pos, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha_pos,DUMMY_VAR__);
            double mu_alpha_neg(0.0);
            (void) mu_alpha_neg;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha_neg, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha_neg,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);


            stan::math::assign(mu_alpha_pos, Phi_approx(get_base1(mu,1,"mu",1)));
            stan::math::assign(mu_alpha_neg, Phi_approx(get_base1(mu,2,"mu",1)));
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu,3,"mu",1)) * 10));

            for (int i = 1; i <= N; ++i) {
                {
                int co(0);
                (void) co;  // dummy to suppress unused var warning

                stan::math::fill(co, std::numeric_limits<int>::min());
                double delta(0.0);
                (void) delta;  // dummy to suppress unused var warning

                stan::math::initialize(delta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(delta,DUMMY_VAR__);
                double pe(0.0);
                (void) pe;  // dummy to suppress unused var warning

                stan::math::initialize(pe, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pe,DUMMY_VAR__);
                double alpha(0.0);
                (void) alpha;  // dummy to suppress unused var warning

                stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(alpha,DUMMY_VAR__);
                validate_non_negative_index("ev", "6", 6);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(6));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);


                stan::math::assign(ev, initial_values);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(co, (logical_gt(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),0) ? get_base1(get_base1(option1,i,"option1",1),t,"option1",2) : get_base1(get_base1(option2,i,"option2",1),t,"option2",2) ));
                    stan::math::assign(delta, (get_base1(ev,get_base1(get_base1(option1,i,"option1",1),t,"option1",2),"ev",1) - get_base1(ev,get_base1(get_base1(option2,i,"option2",1),t,"option2",2),"ev",1)));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),(get_base1(beta,i,"beta",1) * delta))));
                    stan::math::assign(pe, (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(ev,co,"ev",1)));
                    stan::math::assign(alpha, (logical_gte(pe,0) ? stan::math::promote_scalar<double>(get_base1(alpha_pos,i,"alpha_pos",1)) : stan::math::promote_scalar<double>(get_base1(alpha_neg,i,"alpha_neg",1)) ));
                    stan::math::assign(get_base1_lhs(ev,co,"ev",1), (get_base1(ev,co,"ev",1) + (alpha * pe)));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_alpha_pos",mu_alpha_pos,0);
            check_less_or_equal(function__,"mu_alpha_pos",mu_alpha_pos,1);
            check_greater_or_equal(function__,"mu_alpha_neg",mu_alpha_neg,0);
            check_less_or_equal(function__,"mu_alpha_neg",mu_alpha_neg,1);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,10);

            // write generated quantities
        vars__.push_back(mu_alpha_pos);
        vars__.push_back(mu_alpha_neg);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_pst_gainloss_Q";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pos_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_neg_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pos" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_neg" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha_pos";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha_neg";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pos_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_neg_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pos" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_neg" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha_pos";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha_neg";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ra_noLA_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ra_noLA");
    reader.add_event(92, 92, "end", "model_ra_noLA");
    return reader;
}

class model_ra_noLA : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > gamble;
    vector<vector<double> > gain;
    vector<vector<double> > cert;
    vector<vector<double> > loss;
public:
    model_ra_noLA(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ra_noLA(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ra_noLA_namespace::model_ra_noLA";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            context__.validate_dims("data initialization", "gamble", "int", context__.to_vec(N,T));
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            gamble = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("gamble");
            pos__ = 0;
            size_t gamble_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gamble_limit_1__; ++i_1__) {
                size_t gamble_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gamble_limit_0__; ++i_0__) {
                    gamble[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            context__.validate_dims("data initialization", "gain", "double", context__.to_vec(N,T));
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            gain = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("gain");
            pos__ = 0;
            size_t gain_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gain_limit_1__; ++i_1__) {
                size_t gain_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gain_limit_0__; ++i_0__) {
                    gain[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            context__.validate_dims("data initialization", "cert", "double", context__.to_vec(N,T));
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            cert = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("cert");
            pos__ = 0;
            size_t cert_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cert_limit_1__; ++i_1__) {
                size_t cert_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cert_limit_0__; ++i_0__) {
                    cert[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            context__.validate_dims("data initialization", "loss", "double", context__.to_vec(N,T));
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            loss = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("loss");
            pos__ = 0;
            size_t loss_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < loss_limit_1__; ++i_1__) {
                size_t loss_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < loss_limit_0__; ++i_0__) {
                    loss[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],-(1));
                    check_less_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gain[k0__][k1__]",gain[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"loss[k0__][k1__]",loss[k0__][k1__],0);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            validate_non_negative_index("rho_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("tau_p", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ra_noLA() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("rho_p")))
            throw std::runtime_error("variable rho_p missing");
        vals_r__ = context__.vals_r("rho_p");
        pos__ = 0U;
        validate_non_negative_index("rho_p", "N", N);
        context__.validate_dims("initialization", "rho_p", "vector_d", context__.to_vec(N));
        vector_d rho_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_p: ") + e.what());
        }

        if (!(context__.contains_r("tau_p")))
            throw std::runtime_error("variable tau_p missing");
        vals_r__ = context__.vals_r("tau_p");
        pos__ = 0U;
        validate_non_negative_index("tau_p", "N", N);
        context__.validate_dims("initialization", "tau_p", "vector_d", context__.to_vec(N));
        vector_d tau_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_p: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_p;
            (void) rho_p;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_p = in__.vector_constrain(N,lp__);
            else
                rho_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_p;
            (void) tau_p;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_p = in__.vector_constrain(N,lp__);
            else
                tau_p = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(rho,i,"rho",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(rho_p,i,"rho_p",1)))) * 2));
            }
            stan::math::assign(tau, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),tau_p))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,2);
            check_greater_or_equal(function__,"tau",tau,0);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(rho_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(tau_p, 0, 1.0));
            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    T__ evSafe;
                    (void) evSafe;  // dummy to suppress unused var warning

                    stan::math::initialize(evSafe, DUMMY_VAR__);
                    stan::math::fill(evSafe,DUMMY_VAR__);
                    T__ evGamble;
                    (void) evGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(evGamble, DUMMY_VAR__);
                    stan::math::fill(evGamble,DUMMY_VAR__);
                    T__ pGamble;
                    (void) pGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(pGamble, DUMMY_VAR__);
                    stan::math::fill(pGamble,DUMMY_VAR__);


                    stan::math::assign(evSafe, pow(get_base1(get_base1(cert,i,"cert",1),t,"cert",2),get_base1(rho,i,"rho",1)));
                    stan::math::assign(evGamble, (0.5 * (pow(get_base1(get_base1(gain,i,"gain",1),t,"gain",2),get_base1(rho,i,"rho",1)) - pow(get_base1(get_base1(loss,i,"loss",1),t,"loss",2),get_base1(rho,i,"rho",1)))));
                    stan::math::assign(pGamble, inv_logit((get_base1(tau,i,"tau",1) * (evGamble - evSafe))));
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2), pGamble));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("rho_p");
        names__.push_back("tau_p");
        names__.push_back("rho");
        names__.push_back("tau");
        names__.push_back("mu_rho");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ra_noLA_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d rho_p = in__.vector_constrain(N);
        vector_d tau_p = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_p[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(rho,i,"rho",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(rho_p,i,"rho_p",1)))) * 2));
            }
            stan::math::assign(tau, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),tau_p))));

            // validate transformed parameters
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,2);
            check_greater_or_equal(function__,"tau",tau,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_rho, (Phi_approx(get_base1(mu_p,1,"mu_p",1)) * 2));
            stan::math::assign(mu_tau, exp(get_base1(mu_p,2,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    double evSafe(0.0);
                    (void) evSafe;  // dummy to suppress unused var warning

                    stan::math::initialize(evSafe, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(evSafe,DUMMY_VAR__);
                    double evGamble(0.0);
                    (void) evGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(evGamble, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(evGamble,DUMMY_VAR__);
                    double pGamble(0.0);
                    (void) pGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(pGamble, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(pGamble,DUMMY_VAR__);


                    stan::math::assign(evSafe, pow(get_base1(get_base1(cert,i,"cert",1),t,"cert",2),get_base1(rho,i,"rho",1)));
                    stan::math::assign(evGamble, (0.5 * (pow(get_base1(get_base1(gain,i,"gain",1),t,"gain",2),get_base1(rho,i,"rho",1)) - pow(get_base1(get_base1(loss,i,"loss",1),t,"loss",2),get_base1(rho,i,"rho",1)))));
                    stan::math::assign(pGamble, inv_logit((get_base1(tau,i,"tau",1) * (evGamble - evSafe))));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2),pGamble)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(pGamble, base_rng__));
                    }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            check_less_or_equal(function__,"mu_rho",mu_rho,2);
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);

            // write generated quantities
        vars__.push_back(mu_rho);
        vars__.push_back(mu_tau);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ra_noLA";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ra_noRA_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ra_noRA");
    reader.add_event(92, 92, "end", "model_ra_noRA");
    return reader;
}

class model_ra_noRA : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > gamble;
    vector<vector<double> > gain;
    vector<vector<double> > cert;
    vector<vector<double> > loss;
public:
    model_ra_noRA(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ra_noRA(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ra_noRA_namespace::model_ra_noRA";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            context__.validate_dims("data initialization", "gamble", "int", context__.to_vec(N,T));
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            gamble = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("gamble");
            pos__ = 0;
            size_t gamble_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gamble_limit_1__; ++i_1__) {
                size_t gamble_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gamble_limit_0__; ++i_0__) {
                    gamble[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            context__.validate_dims("data initialization", "gain", "double", context__.to_vec(N,T));
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            gain = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("gain");
            pos__ = 0;
            size_t gain_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gain_limit_1__; ++i_1__) {
                size_t gain_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gain_limit_0__; ++i_0__) {
                    gain[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            context__.validate_dims("data initialization", "cert", "double", context__.to_vec(N,T));
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            cert = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("cert");
            pos__ = 0;
            size_t cert_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cert_limit_1__; ++i_1__) {
                size_t cert_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cert_limit_0__; ++i_0__) {
                    cert[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            context__.validate_dims("data initialization", "loss", "double", context__.to_vec(N,T));
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            loss = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("loss");
            pos__ = 0;
            size_t loss_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < loss_limit_1__; ++i_1__) {
                size_t loss_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < loss_limit_0__; ++i_0__) {
                    loss[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],-(1));
                    check_less_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gain[k0__][k1__]",gain[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"loss[k0__][k1__]",loss[k0__][k1__],0);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            validate_non_negative_index("lambda_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("tau_p", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ra_noRA() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("lambda_p")))
            throw std::runtime_error("variable lambda_p missing");
        vals_r__ = context__.vals_r("lambda_p");
        pos__ = 0U;
        validate_non_negative_index("lambda_p", "N", N);
        context__.validate_dims("initialization", "lambda_p", "vector_d", context__.to_vec(N));
        vector_d lambda_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            lambda_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(lambda_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_p: ") + e.what());
        }

        if (!(context__.contains_r("tau_p")))
            throw std::runtime_error("variable tau_p missing");
        vals_r__ = context__.vals_r("tau_p");
        pos__ = 0U;
        validate_non_negative_index("tau_p", "N", N);
        context__.validate_dims("initialization", "tau_p", "vector_d", context__.to_vec(N));
        vector_d tau_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_p: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda_p;
            (void) lambda_p;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_p = in__.vector_constrain(N,lp__);
            else
                lambda_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_p;
            (void) tau_p;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_p = in__.vector_constrain(N,lp__);
            else
                tau_p = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("lambda", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, DUMMY_VAR__);
            stan::math::fill(lambda,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(lambda_p,i,"lambda_p",1)))) * 5));
            }
            stan::math::assign(tau, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),tau_p))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(lambda(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: lambda" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,5);
            check_greater_or_equal(function__,"tau",tau,0);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(lambda_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(tau_p, 0, 1.0));
            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    T__ evSafe;
                    (void) evSafe;  // dummy to suppress unused var warning

                    stan::math::initialize(evSafe, DUMMY_VAR__);
                    stan::math::fill(evSafe,DUMMY_VAR__);
                    T__ evGamble;
                    (void) evGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(evGamble, DUMMY_VAR__);
                    stan::math::fill(evGamble,DUMMY_VAR__);
                    T__ pGamble;
                    (void) pGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(pGamble, DUMMY_VAR__);
                    stan::math::fill(pGamble,DUMMY_VAR__);


                    stan::math::assign(evSafe, get_base1(get_base1(cert,i,"cert",1),t,"cert",2));
                    stan::math::assign(evGamble, (0.5 * (get_base1(get_base1(gain,i,"gain",1),t,"gain",2) - (get_base1(lambda,i,"lambda",1) * get_base1(get_base1(loss,i,"loss",1),t,"loss",2)))));
                    stan::math::assign(pGamble, inv_logit((get_base1(tau,i,"tau",1) * (evGamble - evSafe))));
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2), pGamble));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("lambda_p");
        names__.push_back("tau_p");
        names__.push_back("lambda");
        names__.push_back("tau");
        names__.push_back("mu_lambda");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ra_noRA_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d lambda_p = in__.vector_constrain(N);
        vector_d tau_p = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_p[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("lambda", "N", N);
            vector_d lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(lambda,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(lambda_p,i,"lambda_p",1)))) * 5));
            }
            stan::math::assign(tau, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),tau_p))));

            // validate transformed parameters
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,5);
            check_greater_or_equal(function__,"tau",tau,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_lambda(0.0);
            (void) mu_lambda;  // dummy to suppress unused var warning

            stan::math::initialize(mu_lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_lambda,DUMMY_VAR__);
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_lambda, (Phi_approx(get_base1(mu_p,1,"mu_p",1)) * 5));
            stan::math::assign(mu_tau, exp(get_base1(mu_p,2,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    double evSafe(0.0);
                    (void) evSafe;  // dummy to suppress unused var warning

                    stan::math::initialize(evSafe, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(evSafe,DUMMY_VAR__);
                    double evGamble(0.0);
                    (void) evGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(evGamble, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(evGamble,DUMMY_VAR__);
                    double pGamble(0.0);
                    (void) pGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(pGamble, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(pGamble,DUMMY_VAR__);


                    stan::math::assign(evSafe, get_base1(get_base1(cert,i,"cert",1),t,"cert",2));
                    stan::math::assign(evGamble, (0.5 * (get_base1(get_base1(gain,i,"gain",1),t,"gain",2) - (get_base1(lambda,i,"lambda",1) * get_base1(get_base1(loss,i,"loss",1),t,"loss",2)))));
                    stan::math::assign(pGamble, inv_logit((get_base1(tau,i,"tau",1) * (evGamble - evSafe))));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2),pGamble)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(pGamble, base_rng__));
                    }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_lambda",mu_lambda,0);
            check_less_or_equal(function__,"mu_lambda",mu_lambda,5);
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);

            // write generated quantities
        vars__.push_back(mu_lambda);
        vars__.push_back(mu_tau);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ra_noRA";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ra_prospect_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ra_prospect");
    reader.add_event(94, 94, "end", "model_ra_prospect");
    return reader;
}

class model_ra_prospect : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > gamble;
    vector<vector<double> > cert;
    vector<vector<double> > gain;
    vector<vector<double> > loss;
public:
    model_ra_prospect(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ra_prospect(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ra_prospect_namespace::model_ra_prospect";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            context__.validate_dims("data initialization", "gamble", "int", context__.to_vec(N,T));
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            gamble = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("gamble");
            pos__ = 0;
            size_t gamble_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gamble_limit_1__; ++i_1__) {
                size_t gamble_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gamble_limit_0__; ++i_0__) {
                    gamble[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            context__.validate_dims("data initialization", "cert", "double", context__.to_vec(N,T));
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            cert = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("cert");
            pos__ = 0;
            size_t cert_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cert_limit_1__; ++i_1__) {
                size_t cert_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cert_limit_0__; ++i_0__) {
                    cert[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            context__.validate_dims("data initialization", "gain", "double", context__.to_vec(N,T));
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            gain = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("gain");
            pos__ = 0;
            size_t gain_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gain_limit_1__; ++i_1__) {
                size_t gain_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gain_limit_0__; ++i_0__) {
                    gain[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            context__.validate_dims("data initialization", "loss", "double", context__.to_vec(N,T));
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            loss = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("loss");
            pos__ = 0;
            size_t loss_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < loss_limit_1__; ++i_1__) {
                size_t loss_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < loss_limit_0__; ++i_0__) {
                    loss[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],-(1));
                    check_less_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gain[k0__][k1__]",gain[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"loss[k0__][k1__]",loss[k0__][k1__],0);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("rho_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("lambda_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("tau_p", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ra_prospect() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("rho_p")))
            throw std::runtime_error("variable rho_p missing");
        vals_r__ = context__.vals_r("rho_p");
        pos__ = 0U;
        validate_non_negative_index("rho_p", "N", N);
        context__.validate_dims("initialization", "rho_p", "vector_d", context__.to_vec(N));
        vector_d rho_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_p: ") + e.what());
        }

        if (!(context__.contains_r("lambda_p")))
            throw std::runtime_error("variable lambda_p missing");
        vals_r__ = context__.vals_r("lambda_p");
        pos__ = 0U;
        validate_non_negative_index("lambda_p", "N", N);
        context__.validate_dims("initialization", "lambda_p", "vector_d", context__.to_vec(N));
        vector_d lambda_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            lambda_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(lambda_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_p: ") + e.what());
        }

        if (!(context__.contains_r("tau_p")))
            throw std::runtime_error("variable tau_p missing");
        vals_r__ = context__.vals_r("tau_p");
        pos__ = 0U;
        validate_non_negative_index("tau_p", "N", N);
        context__.validate_dims("initialization", "tau_p", "vector_d", context__.to_vec(N));
        vector_d tau_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_p: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_p;
            (void) rho_p;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_p = in__.vector_constrain(N,lp__);
            else
                rho_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda_p;
            (void) lambda_p;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_p = in__.vector_constrain(N,lp__);
            else
                lambda_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_p;
            (void) tau_p;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_p = in__.vector_constrain(N,lp__);
            else
                tau_p = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);
            validate_non_negative_index("lambda", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, DUMMY_VAR__);
            stan::math::fill(lambda,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(rho,i,"rho",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(rho_p,i,"rho_p",1)))) * 2));
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(lambda_p,i,"lambda_p",1)))) * 5));
            }
            stan::math::assign(tau, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),tau_p))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(lambda(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: lambda" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,2);
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,5);
            check_greater_or_equal(function__,"tau",tau,0);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(rho_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(lambda_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(tau_p, 0, 1.0));
            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    T__ evSafe;
                    (void) evSafe;  // dummy to suppress unused var warning

                    stan::math::initialize(evSafe, DUMMY_VAR__);
                    stan::math::fill(evSafe,DUMMY_VAR__);
                    T__ evGamble;
                    (void) evGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(evGamble, DUMMY_VAR__);
                    stan::math::fill(evGamble,DUMMY_VAR__);
                    T__ pGamble;
                    (void) pGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(pGamble, DUMMY_VAR__);
                    stan::math::fill(pGamble,DUMMY_VAR__);


                    stan::math::assign(evSafe, pow(get_base1(get_base1(cert,i,"cert",1),t,"cert",2),get_base1(rho,i,"rho",1)));
                    stan::math::assign(evGamble, (0.5 * (pow(get_base1(get_base1(gain,i,"gain",1),t,"gain",2),get_base1(rho,i,"rho",1)) - (get_base1(lambda,i,"lambda",1) * pow(get_base1(get_base1(loss,i,"loss",1),t,"loss",2),get_base1(rho,i,"rho",1))))));
                    stan::math::assign(pGamble, inv_logit((get_base1(tau,i,"tau",1) * (evGamble - evSafe))));
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2), pGamble));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("rho_p");
        names__.push_back("lambda_p");
        names__.push_back("tau_p");
        names__.push_back("rho");
        names__.push_back("lambda");
        names__.push_back("tau");
        names__.push_back("mu_rho");
        names__.push_back("mu_lambda");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ra_prospect_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d rho_p = in__.vector_constrain(N);
        vector_d lambda_p = in__.vector_constrain(N);
        vector_d tau_p = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_p[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);
            validate_non_negative_index("lambda", "N", N);
            vector_d lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(lambda,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(rho,i,"rho",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(rho_p,i,"rho_p",1)))) * 2));
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(lambda_p,i,"lambda_p",1)))) * 5));
            }
            stan::math::assign(tau, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),tau_p))));

            // validate transformed parameters
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,2);
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,5);
            check_greater_or_equal(function__,"tau",tau,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            double mu_lambda(0.0);
            (void) mu_lambda;  // dummy to suppress unused var warning

            stan::math::initialize(mu_lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_lambda,DUMMY_VAR__);
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_rho, (Phi_approx(get_base1(mu_p,1,"mu_p",1)) * 2));
            stan::math::assign(mu_lambda, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 5));
            stan::math::assign(mu_tau, exp(get_base1(mu_p,3,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    double evSafe(0.0);
                    (void) evSafe;  // dummy to suppress unused var warning

                    stan::math::initialize(evSafe, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(evSafe,DUMMY_VAR__);
                    double evGamble(0.0);
                    (void) evGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(evGamble, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(evGamble,DUMMY_VAR__);
                    double pGamble(0.0);
                    (void) pGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(pGamble, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(pGamble,DUMMY_VAR__);


                    stan::math::assign(evSafe, pow(get_base1(get_base1(cert,i,"cert",1),t,"cert",2),get_base1(rho,i,"rho",1)));
                    stan::math::assign(evGamble, (0.5 * (pow(get_base1(get_base1(gain,i,"gain",1),t,"gain",2),get_base1(rho,i,"rho",1)) - (get_base1(lambda,i,"lambda",1) * pow(fabs(get_base1(get_base1(loss,i,"loss",1),t,"loss",2)),get_base1(rho,i,"rho",1))))));
                    stan::math::assign(pGamble, inv_logit((get_base1(tau,i,"tau",1) * (evGamble - evSafe))));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2),pGamble)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(pGamble, base_rng__));
                    }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            check_less_or_equal(function__,"mu_rho",mu_rho,2);
            check_greater_or_equal(function__,"mu_lambda",mu_lambda,0);
            check_less_or_equal(function__,"mu_lambda",mu_lambda,5);
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);

            // write generated quantities
        vars__.push_back(mu_rho);
        vars__.push_back(mu_lambda);
        vars__.push_back(mu_tau);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ra_prospect";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_rdt_happiness_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_rdt_happiness");
    reader.add_event(143, 143, "end", "model_rdt_happiness");
    return reader;
}

class model_rdt_happiness : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > gamble;
    vector<vector<int> > type;
    vector<vector<double> > cert;
    vector<vector<double> > gain;
    vector<vector<double> > loss;
    vector<vector<double> > outcome;
    vector<vector<double> > happy;
    vector<vector<double> > RT_happy;
public:
    model_rdt_happiness(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_rdt_happiness(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_rdt_happiness_namespace::model_rdt_happiness";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            context__.validate_dims("data initialization", "gamble", "int", context__.to_vec(N,T));
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            gamble = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("gamble");
            pos__ = 0;
            size_t gamble_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gamble_limit_1__; ++i_1__) {
                size_t gamble_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gamble_limit_0__; ++i_0__) {
                    gamble[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("type", "N", N);
            validate_non_negative_index("type", "T", T);
            context__.validate_dims("data initialization", "type", "int", context__.to_vec(N,T));
            validate_non_negative_index("type", "N", N);
            validate_non_negative_index("type", "T", T);
            type = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("type");
            pos__ = 0;
            size_t type_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < type_limit_1__; ++i_1__) {
                size_t type_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < type_limit_0__; ++i_0__) {
                    type[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            context__.validate_dims("data initialization", "cert", "double", context__.to_vec(N,T));
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            cert = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("cert");
            pos__ = 0;
            size_t cert_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cert_limit_1__; ++i_1__) {
                size_t cert_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cert_limit_0__; ++i_0__) {
                    cert[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            context__.validate_dims("data initialization", "gain", "double", context__.to_vec(N,T));
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            gain = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("gain");
            pos__ = 0;
            size_t gain_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gain_limit_1__; ++i_1__) {
                size_t gain_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gain_limit_0__; ++i_0__) {
                    gain[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            context__.validate_dims("data initialization", "loss", "double", context__.to_vec(N,T));
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            loss = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("loss");
            pos__ = 0;
            size_t loss_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < loss_limit_1__; ++i_1__) {
                size_t loss_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < loss_limit_0__; ++i_0__) {
                    loss[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("happy", "N", N);
            validate_non_negative_index("happy", "T", T);
            context__.validate_dims("data initialization", "happy", "double", context__.to_vec(N,T));
            validate_non_negative_index("happy", "N", N);
            validate_non_negative_index("happy", "T", T);
            happy = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("happy");
            pos__ = 0;
            size_t happy_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < happy_limit_1__; ++i_1__) {
                size_t happy_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < happy_limit_0__; ++i_0__) {
                    happy[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("RT_happy", "N", N);
            validate_non_negative_index("RT_happy", "T", T);
            context__.validate_dims("data initialization", "RT_happy", "double", context__.to_vec(N,T));
            validate_non_negative_index("RT_happy", "N", N);
            validate_non_negative_index("RT_happy", "T", T);
            RT_happy = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("RT_happy");
            pos__ = 0;
            size_t RT_happy_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < RT_happy_limit_1__; ++i_1__) {
                size_t RT_happy_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < RT_happy_limit_0__; ++i_0__) {
                    RT_happy[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],-(1));
                    check_less_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"type[k0__][k1__]",type[k0__][k1__],-(1));
                    check_less_or_equal(function__,"type[k0__][k1__]",type[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gain[k0__][k1__]",gain[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"loss[k0__][k1__]",loss[k0__][k1__],0);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "6", 6);
            num_params_r__ += 6;
            validate_non_negative_index("sigma", "6", 6);
            num_params_r__ += 6;
            validate_non_negative_index("w0_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("w1_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("w2_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("w3_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("gam_p", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("sig_p", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_rdt_happiness() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "6", 6);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(6));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(6));
        for (int j1__ = 0U; j1__ < 6; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "6", 6);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(6));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(6));
        for (int j1__ = 0U; j1__ < 6; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("w0_p")))
            throw std::runtime_error("variable w0_p missing");
        vals_r__ = context__.vals_r("w0_p");
        pos__ = 0U;
        validate_non_negative_index("w0_p", "N", N);
        context__.validate_dims("initialization", "w0_p", "vector_d", context__.to_vec(N));
        vector_d w0_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            w0_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(w0_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable w0_p: ") + e.what());
        }

        if (!(context__.contains_r("w1_p")))
            throw std::runtime_error("variable w1_p missing");
        vals_r__ = context__.vals_r("w1_p");
        pos__ = 0U;
        validate_non_negative_index("w1_p", "N", N);
        context__.validate_dims("initialization", "w1_p", "vector_d", context__.to_vec(N));
        vector_d w1_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            w1_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(w1_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable w1_p: ") + e.what());
        }

        if (!(context__.contains_r("w2_p")))
            throw std::runtime_error("variable w2_p missing");
        vals_r__ = context__.vals_r("w2_p");
        pos__ = 0U;
        validate_non_negative_index("w2_p", "N", N);
        context__.validate_dims("initialization", "w2_p", "vector_d", context__.to_vec(N));
        vector_d w2_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            w2_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(w2_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable w2_p: ") + e.what());
        }

        if (!(context__.contains_r("w3_p")))
            throw std::runtime_error("variable w3_p missing");
        vals_r__ = context__.vals_r("w3_p");
        pos__ = 0U;
        validate_non_negative_index("w3_p", "N", N);
        context__.validate_dims("initialization", "w3_p", "vector_d", context__.to_vec(N));
        vector_d w3_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            w3_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(w3_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable w3_p: ") + e.what());
        }

        if (!(context__.contains_r("gam_p")))
            throw std::runtime_error("variable gam_p missing");
        vals_r__ = context__.vals_r("gam_p");
        pos__ = 0U;
        validate_non_negative_index("gam_p", "N", N);
        context__.validate_dims("initialization", "gam_p", "vector_d", context__.to_vec(N));
        vector_d gam_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            gam_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(gam_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable gam_p: ") + e.what());
        }

        if (!(context__.contains_r("sig_p")))
            throw std::runtime_error("variable sig_p missing");
        vals_r__ = context__.vals_r("sig_p");
        pos__ = 0U;
        validate_non_negative_index("sig_p", "N", N);
        context__.validate_dims("initialization", "sig_p", "vector_d", context__.to_vec(N));
        vector_d sig_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            sig_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(sig_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sig_p: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(6,lp__);
            else
                mu_p = in__.vector_constrain(6);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,6,lp__);
            else
                sigma = in__.vector_lb_constrain(0,6);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  w0_p;
            (void) w0_p;  // dummy to suppress unused var warning
            if (jacobian__)
                w0_p = in__.vector_constrain(N,lp__);
            else
                w0_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  w1_p;
            (void) w1_p;  // dummy to suppress unused var warning
            if (jacobian__)
                w1_p = in__.vector_constrain(N,lp__);
            else
                w1_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  w2_p;
            (void) w2_p;  // dummy to suppress unused var warning
            if (jacobian__)
                w2_p = in__.vector_constrain(N,lp__);
            else
                w2_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  w3_p;
            (void) w3_p;  // dummy to suppress unused var warning
            if (jacobian__)
                w3_p = in__.vector_constrain(N,lp__);
            else
                w3_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  gam_p;
            (void) gam_p;  // dummy to suppress unused var warning
            if (jacobian__)
                gam_p = in__.vector_constrain(N,lp__);
            else
                gam_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sig_p;
            (void) sig_p;  // dummy to suppress unused var warning
            if (jacobian__)
                sig_p = in__.vector_constrain(N,lp__);
            else
                sig_p = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("w0", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  w0(static_cast<Eigen::VectorXd::Index>(N));
            (void) w0;  // dummy to suppress unused var warning

            stan::math::initialize(w0, DUMMY_VAR__);
            stan::math::fill(w0,DUMMY_VAR__);
            validate_non_negative_index("w1", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  w1(static_cast<Eigen::VectorXd::Index>(N));
            (void) w1;  // dummy to suppress unused var warning

            stan::math::initialize(w1, DUMMY_VAR__);
            stan::math::fill(w1,DUMMY_VAR__);
            validate_non_negative_index("w2", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  w2(static_cast<Eigen::VectorXd::Index>(N));
            (void) w2;  // dummy to suppress unused var warning

            stan::math::initialize(w2, DUMMY_VAR__);
            stan::math::fill(w2,DUMMY_VAR__);
            validate_non_negative_index("w3", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  w3(static_cast<Eigen::VectorXd::Index>(N));
            (void) w3;  // dummy to suppress unused var warning

            stan::math::initialize(w3, DUMMY_VAR__);
            stan::math::fill(w3,DUMMY_VAR__);
            validate_non_negative_index("gam", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  gam(static_cast<Eigen::VectorXd::Index>(N));
            (void) gam;  // dummy to suppress unused var warning

            stan::math::initialize(gam, DUMMY_VAR__);
            stan::math::fill(gam,DUMMY_VAR__);
            validate_non_negative_index("sig", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  sig(static_cast<Eigen::VectorXd::Index>(N));
            (void) sig;  // dummy to suppress unused var warning

            stan::math::initialize(sig, DUMMY_VAR__);
            stan::math::fill(sig,DUMMY_VAR__);


            stan::math::assign(w0, add(get_base1(mu_p,1,"mu_p",1),multiply(get_base1(sigma,1,"sigma",1),w0_p)));
            stan::math::assign(w1, add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),w1_p)));
            stan::math::assign(w2, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),w2_p)));
            stan::math::assign(w3, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),w3_p)));
            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(gam,i,"gam",1), Phi_approx((get_base1(mu_p,5,"mu_p",1) + (get_base1(sigma,5,"sigma",1) * get_base1(gam_p,i,"gam_p",1)))));
            }
            stan::math::assign(sig, exp(add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),sig_p))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(w0(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: w0" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(w1(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: w1" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(w2(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: w2" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(w3(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: w3" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(gam(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: gam" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(sig(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: sig" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"gam",gam,0);
            check_less_or_equal(function__,"gam",gam,1);
            check_greater_or_equal(function__,"sig",sig,0);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(w0_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(w1_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(w2_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(w3_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(gam_p, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(sig_p, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                T__ cert_sum;
                (void) cert_sum;  // dummy to suppress unused var warning

                stan::math::initialize(cert_sum, DUMMY_VAR__);
                stan::math::fill(cert_sum,DUMMY_VAR__);
                T__ ev_sum;
                (void) ev_sum;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sum, DUMMY_VAR__);
                stan::math::fill(ev_sum,DUMMY_VAR__);
                T__ rpe_sum;
                (void) rpe_sum;  // dummy to suppress unused var warning

                stan::math::initialize(rpe_sum, DUMMY_VAR__);
                stan::math::fill(rpe_sum,DUMMY_VAR__);


                stan::math::assign(cert_sum, 0);
                stan::math::assign(ev_sum, 0);
                stan::math::assign(rpe_sum, 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    if (as_bool((primitive_value(logical_eq(t,1)) || primitive_value((primitive_value(logical_gt(t,1)) && primitive_value(logical_neq(get_base1(get_base1(RT_happy,i,"RT_happy",1),t,"RT_happy",2),get_base1(get_base1(RT_happy,i,"RT_happy",1),(t - 1),"RT_happy",2)))))))) {

                        lp_accum__.add(normal_log<propto__>(get_base1(get_base1(happy,i,"happy",1),t,"happy",2), (((get_base1(w0,i,"w0",1) + (get_base1(w1,i,"w1",1) * cert_sum)) + (get_base1(w2,i,"w2",1) * ev_sum)) + (get_base1(w3,i,"w3",1) * rpe_sum)), get_base1(sig,i,"sig",1)));
                    }
                    if (as_bool(logical_eq(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2),0))) {

                        stan::math::assign(cert_sum, (cert_sum + (get_base1(get_base1(type,i,"type",1),t,"type",2) * get_base1(get_base1(cert,i,"cert",1),t,"cert",2))));
                    } else {

                        stan::math::assign(ev_sum, (ev_sum + (0.5 * (get_base1(get_base1(gain,i,"gain",1),t,"gain",2) - get_base1(get_base1(loss,i,"loss",1),t,"loss",2)))));
                        stan::math::assign(rpe_sum, ((rpe_sum + get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - (0.5 * (get_base1(get_base1(gain,i,"gain",1),t,"gain",2) - get_base1(get_base1(loss,i,"loss",1),t,"loss",2)))));
                    }
                    stan::math::assign(cert_sum, (get_base1(gam,i,"gam",1) * cert_sum));
                    stan::math::assign(ev_sum, (get_base1(gam,i,"gam",1) * ev_sum));
                    stan::math::assign(rpe_sum, (get_base1(gam,i,"gam",1) * rpe_sum));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("w0_p");
        names__.push_back("w1_p");
        names__.push_back("w2_p");
        names__.push_back("w3_p");
        names__.push_back("gam_p");
        names__.push_back("sig_p");
        names__.push_back("w0");
        names__.push_back("w1");
        names__.push_back("w2");
        names__.push_back("w3");
        names__.push_back("gam");
        names__.push_back("sig");
        names__.push_back("mu_w0");
        names__.push_back("mu_w1");
        names__.push_back("mu_w2");
        names__.push_back("mu_w3");
        names__.push_back("mu_gam");
        names__.push_back("mu_sig");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(6);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(6);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_rdt_happiness_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(6);
        vector_d sigma = in__.vector_lb_constrain(0,6);
        vector_d w0_p = in__.vector_constrain(N);
        vector_d w1_p = in__.vector_constrain(N);
        vector_d w2_p = in__.vector_constrain(N);
        vector_d w3_p = in__.vector_constrain(N);
        vector_d gam_p = in__.vector_constrain(N);
        vector_d sig_p = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 6; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 6; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w0_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w1_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w2_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w3_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(gam_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(sig_p[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("w0", "N", N);
            vector_d w0(static_cast<Eigen::VectorXd::Index>(N));
            (void) w0;  // dummy to suppress unused var warning

            stan::math::initialize(w0, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(w0,DUMMY_VAR__);
            validate_non_negative_index("w1", "N", N);
            vector_d w1(static_cast<Eigen::VectorXd::Index>(N));
            (void) w1;  // dummy to suppress unused var warning

            stan::math::initialize(w1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(w1,DUMMY_VAR__);
            validate_non_negative_index("w2", "N", N);
            vector_d w2(static_cast<Eigen::VectorXd::Index>(N));
            (void) w2;  // dummy to suppress unused var warning

            stan::math::initialize(w2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(w2,DUMMY_VAR__);
            validate_non_negative_index("w3", "N", N);
            vector_d w3(static_cast<Eigen::VectorXd::Index>(N));
            (void) w3;  // dummy to suppress unused var warning

            stan::math::initialize(w3, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(w3,DUMMY_VAR__);
            validate_non_negative_index("gam", "N", N);
            vector_d gam(static_cast<Eigen::VectorXd::Index>(N));
            (void) gam;  // dummy to suppress unused var warning

            stan::math::initialize(gam, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(gam,DUMMY_VAR__);
            validate_non_negative_index("sig", "N", N);
            vector_d sig(static_cast<Eigen::VectorXd::Index>(N));
            (void) sig;  // dummy to suppress unused var warning

            stan::math::initialize(sig, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(sig,DUMMY_VAR__);


            stan::math::assign(w0, add(get_base1(mu_p,1,"mu_p",1),multiply(get_base1(sigma,1,"sigma",1),w0_p)));
            stan::math::assign(w1, add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),w1_p)));
            stan::math::assign(w2, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),w2_p)));
            stan::math::assign(w3, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),w3_p)));
            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(gam,i,"gam",1), Phi_approx((get_base1(mu_p,5,"mu_p",1) + (get_base1(sigma,5,"sigma",1) * get_base1(gam_p,i,"gam_p",1)))));
            }
            stan::math::assign(sig, exp(add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),sig_p))));

            // validate transformed parameters
            check_greater_or_equal(function__,"gam",gam,0);
            check_less_or_equal(function__,"gam",gam,1);
            check_greater_or_equal(function__,"sig",sig,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w0[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w1[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w2[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w3[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(gam[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(sig[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_w0(0.0);
            (void) mu_w0;  // dummy to suppress unused var warning

            stan::math::initialize(mu_w0, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_w0,DUMMY_VAR__);
            double mu_w1(0.0);
            (void) mu_w1;  // dummy to suppress unused var warning

            stan::math::initialize(mu_w1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_w1,DUMMY_VAR__);
            double mu_w2(0.0);
            (void) mu_w2;  // dummy to suppress unused var warning

            stan::math::initialize(mu_w2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_w2,DUMMY_VAR__);
            double mu_w3(0.0);
            (void) mu_w3;  // dummy to suppress unused var warning

            stan::math::initialize(mu_w3, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_w3,DUMMY_VAR__);
            double mu_gam(0.0);
            (void) mu_gam;  // dummy to suppress unused var warning

            stan::math::initialize(mu_gam, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_gam,DUMMY_VAR__);
            double mu_sig(0.0);
            (void) mu_sig;  // dummy to suppress unused var warning

            stan::math::initialize(mu_sig, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_sig,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_w0, get_base1(mu_p,1,"mu_p",1));
            stan::math::assign(mu_w1, get_base1(mu_p,2,"mu_p",1));
            stan::math::assign(mu_w2, get_base1(mu_p,3,"mu_p",1));
            stan::math::assign(mu_w3, get_base1(mu_p,4,"mu_p",1));
            stan::math::assign(mu_gam, Phi_approx(get_base1(mu_p,5,"mu_p",1)));
            stan::math::assign(mu_sig, exp(get_base1(mu_p,6,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                double cert_sum(0.0);
                (void) cert_sum;  // dummy to suppress unused var warning

                stan::math::initialize(cert_sum, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(cert_sum,DUMMY_VAR__);
                double ev_sum(0.0);
                (void) ev_sum;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sum, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_sum,DUMMY_VAR__);
                double rpe_sum(0.0);
                (void) rpe_sum;  // dummy to suppress unused var warning

                stan::math::initialize(rpe_sum, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(rpe_sum,DUMMY_VAR__);


                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                stan::math::assign(cert_sum, 0);
                stan::math::assign(ev_sum, 0);
                stan::math::assign(rpe_sum, 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    if (as_bool((primitive_value(logical_eq(t,1)) || primitive_value((primitive_value(logical_gt(t,1)) && primitive_value(logical_neq(get_base1(get_base1(RT_happy,i,"RT_happy",1),t,"RT_happy",2),get_base1(get_base1(RT_happy,i,"RT_happy",1),(t - 1),"RT_happy",2)))))))) {

                        stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + normal_log(get_base1(get_base1(happy,i,"happy",1),t,"happy",2),(((get_base1(w0,i,"w0",1) + (get_base1(w1,i,"w1",1) * cert_sum)) + (get_base1(w2,i,"w2",1) * ev_sum)) + (get_base1(w3,i,"w3",1) * rpe_sum)),get_base1(sig,i,"sig",1))));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), normal_rng((((get_base1(w0,i,"w0",1) + (get_base1(w1,i,"w1",1) * cert_sum)) + (get_base1(w2,i,"w2",1) * ev_sum)) + (get_base1(w3,i,"w3",1) * rpe_sum)),get_base1(sig,i,"sig",1), base_rng__));
                    }
                    if (as_bool(logical_eq(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2),0))) {

                        stan::math::assign(cert_sum, (cert_sum + (get_base1(get_base1(type,i,"type",1),t,"type",2) * get_base1(get_base1(cert,i,"cert",1),t,"cert",2))));
                    } else {

                        stan::math::assign(ev_sum, (ev_sum + (0.5 * (get_base1(get_base1(gain,i,"gain",1),t,"gain",2) - get_base1(get_base1(loss,i,"loss",1),t,"loss",2)))));
                        stan::math::assign(rpe_sum, ((rpe_sum + get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - (0.5 * (get_base1(get_base1(gain,i,"gain",1),t,"gain",2) - get_base1(get_base1(loss,i,"loss",1),t,"loss",2)))));
                    }
                    stan::math::assign(cert_sum, (get_base1(gam,i,"gam",1) * cert_sum));
                    stan::math::assign(ev_sum, (get_base1(gam,i,"gam",1) * ev_sum));
                    stan::math::assign(rpe_sum, (get_base1(gam,i,"gam",1) * rpe_sum));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_gam",mu_gam,0);
            check_less_or_equal(function__,"mu_gam",mu_gam,1);
            check_greater_or_equal(function__,"mu_sig",mu_sig,0);

            // write generated quantities
        vars__.push_back(mu_w0);
        vars__.push_back(mu_w1);
        vars__.push_back(mu_w2);
        vars__.push_back(mu_w3);
        vars__.push_back(mu_gam);
        vars__.push_back(mu_sig);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_rdt_happiness";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w0_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w1_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w2_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w3_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gam_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sig_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w1" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w3" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gam" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sig" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w0";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w3";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_gam";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_sig";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w0_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w1_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w2_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w3_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gam_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sig_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w1" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w3" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "gam" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sig" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w0";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w3";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_gam";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_sig";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ts_par4_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ts_par4");
    reader.add_event(201, 201, "end", "model_ts_par4");
    return reader;
}

class model_ts_par4 : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > level1_choice;
    vector<vector<int> > level2_choice;
    vector<vector<int> > reward;
    double trans_prob;
public:
    model_ts_par4(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ts_par4(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ts_par4_namespace::model_ts_par4";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("level1_choice", "N", N);
            validate_non_negative_index("level1_choice", "T", T);
            context__.validate_dims("data initialization", "level1_choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("level1_choice", "N", N);
            validate_non_negative_index("level1_choice", "T", T);
            level1_choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("level1_choice");
            pos__ = 0;
            size_t level1_choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < level1_choice_limit_1__; ++i_1__) {
                size_t level1_choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < level1_choice_limit_0__; ++i_0__) {
                    level1_choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("level2_choice", "N", N);
            validate_non_negative_index("level2_choice", "T", T);
            context__.validate_dims("data initialization", "level2_choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("level2_choice", "N", N);
            validate_non_negative_index("level2_choice", "T", T);
            level2_choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("level2_choice");
            pos__ = 0;
            size_t level2_choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < level2_choice_limit_1__; ++i_1__) {
                size_t level2_choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < level2_choice_limit_0__; ++i_0__) {
                    level2_choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("reward", "N", N);
            validate_non_negative_index("reward", "T", T);
            context__.validate_dims("data initialization", "reward", "int", context__.to_vec(N,T));
            validate_non_negative_index("reward", "N", N);
            validate_non_negative_index("reward", "T", T);
            reward = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("reward");
            pos__ = 0;
            size_t reward_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < reward_limit_1__; ++i_1__) {
                size_t reward_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < reward_limit_0__; ++i_0__) {
                    reward[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            context__.validate_dims("data initialization", "trans_prob", "double", context__.to_vec());
            trans_prob = double(0);
            vals_r__ = context__.vals_r("trans_prob");
            pos__ = 0;
            trans_prob = vals_r__[pos__++];

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"level1_choice[k0__][k1__]",level1_choice[k0__][k1__],1);
                    check_less_or_equal(function__,"level1_choice[k0__][k1__]",level1_choice[k0__][k1__],2);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"level2_choice[k0__][k1__]",level2_choice[k0__][k1__],1);
                    check_less_or_equal(function__,"level2_choice[k0__][k1__]",level2_choice[k0__][k1__],4);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"reward[k0__][k1__]",reward[k0__][k1__],0);
                    check_less_or_equal(function__,"reward[k0__][k1__]",reward[k0__][k1__],1);
                }
            }
            check_greater_or_equal(function__,"trans_prob",trans_prob,0);
            check_less_or_equal(function__,"trans_prob",trans_prob,1);
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            validate_non_negative_index("a_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("pi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("w_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ts_par4() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("a_pr")))
            throw std::runtime_error("variable a_pr missing");
        vals_r__ = context__.vals_r("a_pr");
        pos__ = 0U;
        validate_non_negative_index("a_pr", "N", N);
        context__.validate_dims("initialization", "a_pr", "vector_d", context__.to_vec(N));
        vector_d a_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            a_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(a_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable a_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        if (!(context__.contains_r("pi_pr")))
            throw std::runtime_error("variable pi_pr missing");
        vals_r__ = context__.vals_r("pi_pr");
        pos__ = 0U;
        validate_non_negative_index("pi_pr", "N", N);
        context__.validate_dims("initialization", "pi_pr", "vector_d", context__.to_vec(N));
        vector_d pi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            pi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(pi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable pi_pr: ") + e.what());
        }

        if (!(context__.contains_r("w_pr")))
            throw std::runtime_error("variable w_pr missing");
        vals_r__ = context__.vals_r("w_pr");
        pos__ = 0U;
        validate_non_negative_index("w_pr", "N", N);
        context__.validate_dims("initialization", "w_pr", "vector_d", context__.to_vec(N));
        vector_d w_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            w_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(w_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable w_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  a_pr;
            (void) a_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                a_pr = in__.vector_constrain(N,lp__);
            else
                a_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi_pr;
            (void) pi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                pi_pr = in__.vector_constrain(N,lp__);
            else
                pi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  w_pr;
            (void) w_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                w_pr = in__.vector_constrain(N,lp__);
            else
                w_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("a", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  a(static_cast<Eigen::VectorXd::Index>(N));
            (void) a;  // dummy to suppress unused var warning

            stan::math::initialize(a, DUMMY_VAR__);
            stan::math::fill(a,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, DUMMY_VAR__);
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("w", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  w(static_cast<Eigen::VectorXd::Index>(N));
            (void) w;  // dummy to suppress unused var warning

            stan::math::initialize(w, DUMMY_VAR__);
            stan::math::fill(w,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(a,i,"a",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(a_pr,i,"a_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), exp((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))));
                stan::math::assign(get_base1_lhs(pi,i,"pi",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(pi_pr,i,"pi_pr",1)))) * 5));
                stan::math::assign(get_base1_lhs(w,i,"w",1), Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(w_pr,i,"w_pr",1)))));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(a(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: a" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(w(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: w" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"a",a,0);
            check_less_or_equal(function__,"a",a,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_greater_or_equal(function__,"pi",pi,0);
            check_less_or_equal(function__,"pi",pi,5);
            check_greater_or_equal(function__,"w",w,0);
            check_less_or_equal(function__,"w",w,1);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(a_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(pi_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(w_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("v_mb", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  v_mb(static_cast<Eigen::VectorXd::Index>(2));
                (void) v_mb;  // dummy to suppress unused var warning

                stan::math::initialize(v_mb, DUMMY_VAR__);
                stan::math::fill(v_mb,DUMMY_VAR__);
                validate_non_negative_index("v_mf", "6", 6);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  v_mf(static_cast<Eigen::VectorXd::Index>(6));
                (void) v_mf;  // dummy to suppress unused var warning

                stan::math::initialize(v_mf, DUMMY_VAR__);
                stan::math::fill(v_mf,DUMMY_VAR__);
                validate_non_negative_index("v_hybrid", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  v_hybrid(static_cast<Eigen::VectorXd::Index>(2));
                (void) v_hybrid;  // dummy to suppress unused var warning

                stan::math::initialize(v_hybrid, DUMMY_VAR__);
                stan::math::fill(v_hybrid,DUMMY_VAR__);
                T__ level1_prob_choice2;
                (void) level1_prob_choice2;  // dummy to suppress unused var warning

                stan::math::initialize(level1_prob_choice2, DUMMY_VAR__);
                stan::math::fill(level1_prob_choice2,DUMMY_VAR__);
                T__ level2_prob_choice2;
                (void) level2_prob_choice2;  // dummy to suppress unused var warning

                stan::math::initialize(level2_prob_choice2, DUMMY_VAR__);
                stan::math::fill(level2_prob_choice2,DUMMY_VAR__);
                int level1_choice_01(0);
                (void) level1_choice_01;  // dummy to suppress unused var warning

                stan::math::fill(level1_choice_01, std::numeric_limits<int>::min());
                int level2_choice_01(0);
                (void) level2_choice_01;  // dummy to suppress unused var warning

                stan::math::fill(level2_choice_01, std::numeric_limits<int>::min());


                stan::math::assign(v_mb, rep_vector(0.0,2));
                stan::math::assign(v_mf, rep_vector(0.0,6));
                stan::math::assign(v_hybrid, rep_vector(0.0,2));
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(v_mb,1,"v_mb",1), ((trans_prob * stan::math::fmax(get_base1(v_mf,3,"v_mf",1),get_base1(v_mf,4,"v_mf",1))) + ((1 - trans_prob) * stan::math::fmax(get_base1(v_mf,5,"v_mf",1),get_base1(v_mf,6,"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mb,2,"v_mb",1), (((1 - trans_prob) * stan::math::fmax(get_base1(v_mf,3,"v_mf",1),get_base1(v_mf,4,"v_mf",1))) + (trans_prob * stan::math::fmax(get_base1(v_mf,5,"v_mf",1),get_base1(v_mf,6,"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_hybrid,1,"v_hybrid",1), ((get_base1(w,i,"w",1) * get_base1(v_mb,1,"v_mb",1)) + ((1 - get_base1(w,i,"w",1)) * get_base1(v_mf,1,"v_mf",1))));
                    stan::math::assign(get_base1_lhs(v_hybrid,2,"v_hybrid",1), ((get_base1(w,i,"w",1) * get_base1(v_mb,2,"v_mb",1)) + ((1 - get_base1(w,i,"w",1)) * get_base1(v_mf,2,"v_mf",1))));
                    stan::math::assign(level1_choice_01, (get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2) - 1));
                    if (as_bool(logical_eq(t,1))) {

                        stan::math::assign(level1_prob_choice2, inv_logit((get_base1(beta,i,"beta",1) * (get_base1(v_hybrid,2,"v_hybrid",1) - get_base1(v_hybrid,1,"v_hybrid",1)))));
                    } else {

                        stan::math::assign(level1_prob_choice2, inv_logit(((get_base1(beta,i,"beta",1) * (get_base1(v_hybrid,2,"v_hybrid",1) - get_base1(v_hybrid,1,"v_hybrid",1))) + (get_base1(pi,i,"pi",1) * ((2 * get_base1(get_base1(level1_choice,i,"level1_choice",1),(t - 1),"level1_choice",2)) - 3)))));
                    }
                    lp_accum__.add(bernoulli_log<propto__>(level1_choice_01, level1_prob_choice2));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + (get_base1(a,i,"a",1) * (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) - get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1)))));
                    stan::math::assign(level2_choice_01, (1 - modulus(get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2),2)));
                    if (as_bool(logical_gt(get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2),2))) {

                        stan::math::assign(level2_prob_choice2, inv_logit((get_base1(beta,i,"beta",1) * (get_base1(v_mf,6,"v_mf",1) - get_base1(v_mf,5,"v_mf",1)))));
                    } else {

                        stan::math::assign(level2_prob_choice2, inv_logit((get_base1(beta,i,"beta",1) * (get_base1(v_mf,4,"v_mf",1) - get_base1(v_mf,3,"v_mf",1)))));
                    }
                    lp_accum__.add(bernoulli_log<propto__>(level2_choice_01, level2_prob_choice2));
                    stan::math::assign(get_base1_lhs(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1), (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) + (get_base1(a,i,"a",1) * (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + (get_base1(a,i,"a",1) * (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1)))));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("a_pr");
        names__.push_back("beta_pr");
        names__.push_back("pi_pr");
        names__.push_back("w_pr");
        names__.push_back("a");
        names__.push_back("beta");
        names__.push_back("pi");
        names__.push_back("w");
        names__.push_back("mu_a");
        names__.push_back("mu_beta");
        names__.push_back("mu_pi");
        names__.push_back("mu_w");
        names__.push_back("log_lik");
        names__.push_back("y_pred_step1");
        names__.push_back("y_pred_step2");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ts_par4_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d a_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
        vector_d pi_pr = in__.vector_constrain(N);
        vector_d w_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(a_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("a", "N", N);
            vector_d a(static_cast<Eigen::VectorXd::Index>(N));
            (void) a;  // dummy to suppress unused var warning

            stan::math::initialize(a, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(a,DUMMY_VAR__);
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            vector_d pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("w", "N", N);
            vector_d w(static_cast<Eigen::VectorXd::Index>(N));
            (void) w;  // dummy to suppress unused var warning

            stan::math::initialize(w, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(w,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(a,i,"a",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(a_pr,i,"a_pr",1)))));
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), exp((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))));
                stan::math::assign(get_base1_lhs(pi,i,"pi",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(pi_pr,i,"pi_pr",1)))) * 5));
                stan::math::assign(get_base1_lhs(w,i,"w",1), Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(w_pr,i,"w_pr",1)))));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"a",a,0);
            check_less_or_equal(function__,"a",a,1);
            check_greater_or_equal(function__,"beta",beta,0);
            check_greater_or_equal(function__,"pi",pi,0);
            check_less_or_equal(function__,"pi",pi,5);
            check_greater_or_equal(function__,"w",w,0);
            check_less_or_equal(function__,"w",w,1);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(a[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_a(0.0);
            (void) mu_a;  // dummy to suppress unused var warning

            stan::math::initialize(mu_a, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_a,DUMMY_VAR__);
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            double mu_pi(0.0);
            (void) mu_pi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_pi,DUMMY_VAR__);
            double mu_w(0.0);
            (void) mu_w;  // dummy to suppress unused var warning

            stan::math::initialize(mu_w, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_w,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred_step1", "N", N);
            validate_non_negative_index("y_pred_step1", "T", T);
            vector<vector<double> > y_pred_step1(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred_step1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred_step1,DUMMY_VAR__);
            validate_non_negative_index("y_pred_step2", "N", N);
            validate_non_negative_index("y_pred_step2", "T", T);
            vector<vector<double> > y_pred_step2(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred_step2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred_step2,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred_step1,i,"y_pred_step1",1),t,"y_pred_step1",2), -(1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred_step2,i,"y_pred_step2",1),t,"y_pred_step2",2), -(1));
                }
            }
            stan::math::assign(mu_a, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_beta, exp(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_pi, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));
            stan::math::assign(mu_w, Phi_approx(get_base1(mu_p,4,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("v_mb", "2", 2);
                vector_d v_mb(static_cast<Eigen::VectorXd::Index>(2));
                (void) v_mb;  // dummy to suppress unused var warning

                stan::math::initialize(v_mb, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(v_mb,DUMMY_VAR__);
                validate_non_negative_index("v_mf", "6", 6);
                vector_d v_mf(static_cast<Eigen::VectorXd::Index>(6));
                (void) v_mf;  // dummy to suppress unused var warning

                stan::math::initialize(v_mf, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(v_mf,DUMMY_VAR__);
                validate_non_negative_index("v_hybrid", "2", 2);
                vector_d v_hybrid(static_cast<Eigen::VectorXd::Index>(2));
                (void) v_hybrid;  // dummy to suppress unused var warning

                stan::math::initialize(v_hybrid, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(v_hybrid,DUMMY_VAR__);
                double level1_prob_choice2(0.0);
                (void) level1_prob_choice2;  // dummy to suppress unused var warning

                stan::math::initialize(level1_prob_choice2, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(level1_prob_choice2,DUMMY_VAR__);
                double level2_prob_choice2(0.0);
                (void) level2_prob_choice2;  // dummy to suppress unused var warning

                stan::math::initialize(level2_prob_choice2, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(level2_prob_choice2,DUMMY_VAR__);
                int level1_choice_01(0);
                (void) level1_choice_01;  // dummy to suppress unused var warning

                stan::math::fill(level1_choice_01, std::numeric_limits<int>::min());
                int level2_choice_01(0);
                (void) level2_choice_01;  // dummy to suppress unused var warning

                stan::math::fill(level2_choice_01, std::numeric_limits<int>::min());


                stan::math::assign(v_mb, rep_vector(0.0,2));
                stan::math::assign(v_mf, rep_vector(0.0,6));
                stan::math::assign(v_hybrid, rep_vector(0.0,2));
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(v_mb,1,"v_mb",1), ((trans_prob * stan::math::fmax(get_base1(v_mf,3,"v_mf",1),get_base1(v_mf,4,"v_mf",1))) + ((1 - trans_prob) * stan::math::fmax(get_base1(v_mf,5,"v_mf",1),get_base1(v_mf,6,"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mb,2,"v_mb",1), (((1 - trans_prob) * stan::math::fmax(get_base1(v_mf,3,"v_mf",1),get_base1(v_mf,4,"v_mf",1))) + (trans_prob * stan::math::fmax(get_base1(v_mf,5,"v_mf",1),get_base1(v_mf,6,"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_hybrid,1,"v_hybrid",1), ((get_base1(w,i,"w",1) * get_base1(v_mb,1,"v_mb",1)) + ((1 - get_base1(w,i,"w",1)) * get_base1(v_mf,1,"v_mf",1))));
                    stan::math::assign(get_base1_lhs(v_hybrid,2,"v_hybrid",1), ((get_base1(w,i,"w",1) * get_base1(v_mb,2,"v_mb",1)) + ((1 - get_base1(w,i,"w",1)) * get_base1(v_mf,2,"v_mf",1))));
                    stan::math::assign(level1_choice_01, (get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2) - 1));
                    if (as_bool(logical_eq(t,1))) {

                        stan::math::assign(level1_prob_choice2, inv_logit((get_base1(beta,i,"beta",1) * (get_base1(v_hybrid,2,"v_hybrid",1) - get_base1(v_hybrid,1,"v_hybrid",1)))));
                    } else {

                        stan::math::assign(level1_prob_choice2, inv_logit(((get_base1(beta,i,"beta",1) * (get_base1(v_hybrid,2,"v_hybrid",1) - get_base1(v_hybrid,1,"v_hybrid",1))) + (get_base1(pi,i,"pi",1) * ((2 * get_base1(get_base1(level1_choice,i,"level1_choice",1),(t - 1),"level1_choice",2)) - 3)))));
                    }
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(level1_choice_01,level1_prob_choice2)));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + (get_base1(a,i,"a",1) * (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) - get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1)))));
                    stan::math::assign(level2_choice_01, (1 - modulus(get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2),2)));
                    if (as_bool(logical_gt(get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2),2))) {

                        stan::math::assign(level2_prob_choice2, inv_logit((get_base1(beta,i,"beta",1) * (get_base1(v_mf,6,"v_mf",1) - get_base1(v_mf,5,"v_mf",1)))));
                    } else {

                        stan::math::assign(level2_prob_choice2, inv_logit((get_base1(beta,i,"beta",1) * (get_base1(v_mf,4,"v_mf",1) - get_base1(v_mf,3,"v_mf",1)))));
                    }
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(level2_choice_01,level2_prob_choice2)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred_step1,i,"y_pred_step1",1),t,"y_pred_step1",2), bernoulli_rng(level1_prob_choice2, base_rng__));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred_step2,i,"y_pred_step2",1),t,"y_pred_step2",2), bernoulli_rng(level2_prob_choice2, base_rng__));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + (get_base1(a,i,"a",1) * (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) - get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1), (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) + (get_base1(a,i,"a",1) * (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + (get_base1(a,i,"a",1) * (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1)))));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_a",mu_a,0);
            check_less_or_equal(function__,"mu_a",mu_a,1);
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_greater_or_equal(function__,"mu_pi",mu_pi,0);
            check_less_or_equal(function__,"mu_pi",mu_pi,5);
            check_greater_or_equal(function__,"mu_w",mu_w,0);
            check_less_or_equal(function__,"mu_w",mu_w,1);

            // write generated quantities
        vars__.push_back(mu_a);
        vars__.push_back(mu_beta);
        vars__.push_back(mu_pi);
        vars__.push_back(mu_w);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred_step1[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred_step2[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ts_par4";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_a";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred_step1" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred_step2" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_a";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred_step1" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred_step2" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ts_par6_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ts_par6");
    reader.add_event(210, 210, "end", "model_ts_par6");
    return reader;
}

class model_ts_par6 : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > level1_choice;
    vector<vector<int> > level2_choice;
    vector<vector<int> > reward;
    double trans_prob;
public:
    model_ts_par6(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ts_par6(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ts_par6_namespace::model_ts_par6";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("level1_choice", "N", N);
            validate_non_negative_index("level1_choice", "T", T);
            context__.validate_dims("data initialization", "level1_choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("level1_choice", "N", N);
            validate_non_negative_index("level1_choice", "T", T);
            level1_choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("level1_choice");
            pos__ = 0;
            size_t level1_choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < level1_choice_limit_1__; ++i_1__) {
                size_t level1_choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < level1_choice_limit_0__; ++i_0__) {
                    level1_choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("level2_choice", "N", N);
            validate_non_negative_index("level2_choice", "T", T);
            context__.validate_dims("data initialization", "level2_choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("level2_choice", "N", N);
            validate_non_negative_index("level2_choice", "T", T);
            level2_choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("level2_choice");
            pos__ = 0;
            size_t level2_choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < level2_choice_limit_1__; ++i_1__) {
                size_t level2_choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < level2_choice_limit_0__; ++i_0__) {
                    level2_choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("reward", "N", N);
            validate_non_negative_index("reward", "T", T);
            context__.validate_dims("data initialization", "reward", "int", context__.to_vec(N,T));
            validate_non_negative_index("reward", "N", N);
            validate_non_negative_index("reward", "T", T);
            reward = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("reward");
            pos__ = 0;
            size_t reward_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < reward_limit_1__; ++i_1__) {
                size_t reward_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < reward_limit_0__; ++i_0__) {
                    reward[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            context__.validate_dims("data initialization", "trans_prob", "double", context__.to_vec());
            trans_prob = double(0);
            vals_r__ = context__.vals_r("trans_prob");
            pos__ = 0;
            trans_prob = vals_r__[pos__++];

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"level1_choice[k0__][k1__]",level1_choice[k0__][k1__],1);
                    check_less_or_equal(function__,"level1_choice[k0__][k1__]",level1_choice[k0__][k1__],2);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"level2_choice[k0__][k1__]",level2_choice[k0__][k1__],1);
                    check_less_or_equal(function__,"level2_choice[k0__][k1__]",level2_choice[k0__][k1__],4);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"reward[k0__][k1__]",reward[k0__][k1__],0);
                    check_less_or_equal(function__,"reward[k0__][k1__]",reward[k0__][k1__],1);
                }
            }
            check_greater_or_equal(function__,"trans_prob",trans_prob,0);
            check_less_or_equal(function__,"trans_prob",trans_prob,1);
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "6", 6);
            num_params_r__ += 6;
            validate_non_negative_index("sigma", "6", 6);
            num_params_r__ += 6;
            validate_non_negative_index("a1_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta1_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("a2_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta2_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("pi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("w_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ts_par6() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "6", 6);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(6));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(6));
        for (int j1__ = 0U; j1__ < 6; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "6", 6);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(6));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(6));
        for (int j1__ = 0U; j1__ < 6; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("a1_pr")))
            throw std::runtime_error("variable a1_pr missing");
        vals_r__ = context__.vals_r("a1_pr");
        pos__ = 0U;
        validate_non_negative_index("a1_pr", "N", N);
        context__.validate_dims("initialization", "a1_pr", "vector_d", context__.to_vec(N));
        vector_d a1_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            a1_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(a1_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable a1_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta1_pr")))
            throw std::runtime_error("variable beta1_pr missing");
        vals_r__ = context__.vals_r("beta1_pr");
        pos__ = 0U;
        validate_non_negative_index("beta1_pr", "N", N);
        context__.validate_dims("initialization", "beta1_pr", "vector_d", context__.to_vec(N));
        vector_d beta1_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta1_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta1_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta1_pr: ") + e.what());
        }

        if (!(context__.contains_r("a2_pr")))
            throw std::runtime_error("variable a2_pr missing");
        vals_r__ = context__.vals_r("a2_pr");
        pos__ = 0U;
        validate_non_negative_index("a2_pr", "N", N);
        context__.validate_dims("initialization", "a2_pr", "vector_d", context__.to_vec(N));
        vector_d a2_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            a2_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(a2_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable a2_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta2_pr")))
            throw std::runtime_error("variable beta2_pr missing");
        vals_r__ = context__.vals_r("beta2_pr");
        pos__ = 0U;
        validate_non_negative_index("beta2_pr", "N", N);
        context__.validate_dims("initialization", "beta2_pr", "vector_d", context__.to_vec(N));
        vector_d beta2_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta2_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta2_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta2_pr: ") + e.what());
        }

        if (!(context__.contains_r("pi_pr")))
            throw std::runtime_error("variable pi_pr missing");
        vals_r__ = context__.vals_r("pi_pr");
        pos__ = 0U;
        validate_non_negative_index("pi_pr", "N", N);
        context__.validate_dims("initialization", "pi_pr", "vector_d", context__.to_vec(N));
        vector_d pi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            pi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(pi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable pi_pr: ") + e.what());
        }

        if (!(context__.contains_r("w_pr")))
            throw std::runtime_error("variable w_pr missing");
        vals_r__ = context__.vals_r("w_pr");
        pos__ = 0U;
        validate_non_negative_index("w_pr", "N", N);
        context__.validate_dims("initialization", "w_pr", "vector_d", context__.to_vec(N));
        vector_d w_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            w_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(w_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable w_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(6,lp__);
            else
                mu_p = in__.vector_constrain(6);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,6,lp__);
            else
                sigma = in__.vector_lb_constrain(0,6);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  a1_pr;
            (void) a1_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                a1_pr = in__.vector_constrain(N,lp__);
            else
                a1_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta1_pr;
            (void) beta1_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta1_pr = in__.vector_constrain(N,lp__);
            else
                beta1_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  a2_pr;
            (void) a2_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                a2_pr = in__.vector_constrain(N,lp__);
            else
                a2_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta2_pr;
            (void) beta2_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta2_pr = in__.vector_constrain(N,lp__);
            else
                beta2_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi_pr;
            (void) pi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                pi_pr = in__.vector_constrain(N,lp__);
            else
                pi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  w_pr;
            (void) w_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                w_pr = in__.vector_constrain(N,lp__);
            else
                w_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("a1", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  a1(static_cast<Eigen::VectorXd::Index>(N));
            (void) a1;  // dummy to suppress unused var warning

            stan::math::initialize(a1, DUMMY_VAR__);
            stan::math::fill(a1,DUMMY_VAR__);
            validate_non_negative_index("beta1", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta1(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta1;  // dummy to suppress unused var warning

            stan::math::initialize(beta1, DUMMY_VAR__);
            stan::math::fill(beta1,DUMMY_VAR__);
            validate_non_negative_index("a2", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  a2(static_cast<Eigen::VectorXd::Index>(N));
            (void) a2;  // dummy to suppress unused var warning

            stan::math::initialize(a2, DUMMY_VAR__);
            stan::math::fill(a2,DUMMY_VAR__);
            validate_non_negative_index("beta2", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta2(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta2;  // dummy to suppress unused var warning

            stan::math::initialize(beta2, DUMMY_VAR__);
            stan::math::fill(beta2,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, DUMMY_VAR__);
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("w", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  w(static_cast<Eigen::VectorXd::Index>(N));
            (void) w;  // dummy to suppress unused var warning

            stan::math::initialize(w, DUMMY_VAR__);
            stan::math::fill(w,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(a1,i,"a1",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(a1_pr,i,"a1_pr",1)))));
                stan::math::assign(get_base1_lhs(beta1,i,"beta1",1), exp((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta1_pr,i,"beta1_pr",1)))));
                stan::math::assign(get_base1_lhs(a2,i,"a2",1), Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(a2_pr,i,"a2_pr",1)))));
                stan::math::assign(get_base1_lhs(beta2,i,"beta2",1), exp((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(beta2_pr,i,"beta2_pr",1)))));
                stan::math::assign(get_base1_lhs(pi,i,"pi",1), (Phi_approx((get_base1(mu_p,5,"mu_p",1) + (get_base1(sigma,5,"sigma",1) * get_base1(pi_pr,i,"pi_pr",1)))) * 5));
                stan::math::assign(get_base1_lhs(w,i,"w",1), Phi_approx((get_base1(mu_p,6,"mu_p",1) + (get_base1(sigma,6,"sigma",1) * get_base1(w_pr,i,"w_pr",1)))));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(a1(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: a1" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta1(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta1" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(a2(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: a2" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta2(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta2" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(w(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: w" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"a1",a1,0);
            check_less_or_equal(function__,"a1",a1,1);
            check_greater_or_equal(function__,"beta1",beta1,0);
            check_greater_or_equal(function__,"a2",a2,0);
            check_less_or_equal(function__,"a2",a2,1);
            check_greater_or_equal(function__,"beta2",beta2,0);
            check_greater_or_equal(function__,"pi",pi,0);
            check_less_or_equal(function__,"pi",pi,5);
            check_greater_or_equal(function__,"w",w,0);
            check_less_or_equal(function__,"w",w,1);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(a1_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta1_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(a2_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta2_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(pi_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(w_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("v_mb", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  v_mb(static_cast<Eigen::VectorXd::Index>(2));
                (void) v_mb;  // dummy to suppress unused var warning

                stan::math::initialize(v_mb, DUMMY_VAR__);
                stan::math::fill(v_mb,DUMMY_VAR__);
                validate_non_negative_index("v_mf", "6", 6);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  v_mf(static_cast<Eigen::VectorXd::Index>(6));
                (void) v_mf;  // dummy to suppress unused var warning

                stan::math::initialize(v_mf, DUMMY_VAR__);
                stan::math::fill(v_mf,DUMMY_VAR__);
                validate_non_negative_index("v_hybrid", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  v_hybrid(static_cast<Eigen::VectorXd::Index>(2));
                (void) v_hybrid;  // dummy to suppress unused var warning

                stan::math::initialize(v_hybrid, DUMMY_VAR__);
                stan::math::fill(v_hybrid,DUMMY_VAR__);
                T__ level1_prob_choice2;
                (void) level1_prob_choice2;  // dummy to suppress unused var warning

                stan::math::initialize(level1_prob_choice2, DUMMY_VAR__);
                stan::math::fill(level1_prob_choice2,DUMMY_VAR__);
                T__ level2_prob_choice2;
                (void) level2_prob_choice2;  // dummy to suppress unused var warning

                stan::math::initialize(level2_prob_choice2, DUMMY_VAR__);
                stan::math::fill(level2_prob_choice2,DUMMY_VAR__);
                int level1_choice_01(0);
                (void) level1_choice_01;  // dummy to suppress unused var warning

                stan::math::fill(level1_choice_01, std::numeric_limits<int>::min());
                int level2_choice_01(0);
                (void) level2_choice_01;  // dummy to suppress unused var warning

                stan::math::fill(level2_choice_01, std::numeric_limits<int>::min());


                stan::math::assign(v_mb, rep_vector(0.0,2));
                stan::math::assign(v_mf, rep_vector(0.0,6));
                stan::math::assign(v_hybrid, rep_vector(0.0,2));
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(v_mb,1,"v_mb",1), ((trans_prob * stan::math::fmax(get_base1(v_mf,3,"v_mf",1),get_base1(v_mf,4,"v_mf",1))) + ((1 - trans_prob) * stan::math::fmax(get_base1(v_mf,5,"v_mf",1),get_base1(v_mf,6,"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mb,2,"v_mb",1), (((1 - trans_prob) * stan::math::fmax(get_base1(v_mf,3,"v_mf",1),get_base1(v_mf,4,"v_mf",1))) + (trans_prob * stan::math::fmax(get_base1(v_mf,5,"v_mf",1),get_base1(v_mf,6,"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_hybrid,1,"v_hybrid",1), ((get_base1(w,i,"w",1) * get_base1(v_mb,1,"v_mb",1)) + ((1 - get_base1(w,i,"w",1)) * get_base1(v_mf,1,"v_mf",1))));
                    stan::math::assign(get_base1_lhs(v_hybrid,2,"v_hybrid",1), ((get_base1(w,i,"w",1) * get_base1(v_mb,2,"v_mb",1)) + ((1 - get_base1(w,i,"w",1)) * get_base1(v_mf,2,"v_mf",1))));
                    stan::math::assign(level1_choice_01, (get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2) - 1));
                    if (as_bool(logical_eq(t,1))) {

                        stan::math::assign(level1_prob_choice2, inv_logit((get_base1(beta1,i,"beta1",1) * (get_base1(v_hybrid,2,"v_hybrid",1) - get_base1(v_hybrid,1,"v_hybrid",1)))));
                    } else {

                        stan::math::assign(level1_prob_choice2, inv_logit(((get_base1(beta1,i,"beta1",1) * (get_base1(v_hybrid,2,"v_hybrid",1) - get_base1(v_hybrid,1,"v_hybrid",1))) + (get_base1(pi,i,"pi",1) * ((2 * get_base1(get_base1(level1_choice,i,"level1_choice",1),(t - 1),"level1_choice",2)) - 3)))));
                    }
                    lp_accum__.add(bernoulli_log<propto__>(level1_choice_01, level1_prob_choice2));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + (get_base1(a1,i,"a1",1) * (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) - get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1)))));
                    stan::math::assign(level2_choice_01, (1 - modulus(get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2),2)));
                    if (as_bool(logical_gt(get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2),2))) {

                        stan::math::assign(level2_prob_choice2, inv_logit((get_base1(beta2,i,"beta2",1) * (get_base1(v_mf,6,"v_mf",1) - get_base1(v_mf,5,"v_mf",1)))));
                    } else {

                        stan::math::assign(level2_prob_choice2, inv_logit((get_base1(beta2,i,"beta2",1) * (get_base1(v_mf,4,"v_mf",1) - get_base1(v_mf,3,"v_mf",1)))));
                    }
                    lp_accum__.add(bernoulli_log<propto__>(level2_choice_01, level2_prob_choice2));
                    stan::math::assign(get_base1_lhs(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1), (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) + (get_base1(a2,i,"a2",1) * (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + (get_base1(a1,i,"a1",1) * (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1)))));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("a1_pr");
        names__.push_back("beta1_pr");
        names__.push_back("a2_pr");
        names__.push_back("beta2_pr");
        names__.push_back("pi_pr");
        names__.push_back("w_pr");
        names__.push_back("a1");
        names__.push_back("beta1");
        names__.push_back("a2");
        names__.push_back("beta2");
        names__.push_back("pi");
        names__.push_back("w");
        names__.push_back("mu_a1");
        names__.push_back("mu_beta1");
        names__.push_back("mu_a2");
        names__.push_back("mu_beta2");
        names__.push_back("mu_pi");
        names__.push_back("mu_w");
        names__.push_back("log_lik");
        names__.push_back("y_pred_step1");
        names__.push_back("y_pred_step2");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(6);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(6);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ts_par6_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(6);
        vector_d sigma = in__.vector_lb_constrain(0,6);
        vector_d a1_pr = in__.vector_constrain(N);
        vector_d beta1_pr = in__.vector_constrain(N);
        vector_d a2_pr = in__.vector_constrain(N);
        vector_d beta2_pr = in__.vector_constrain(N);
        vector_d pi_pr = in__.vector_constrain(N);
        vector_d w_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 6; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 6; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(a1_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta1_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(a2_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta2_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("a1", "N", N);
            vector_d a1(static_cast<Eigen::VectorXd::Index>(N));
            (void) a1;  // dummy to suppress unused var warning

            stan::math::initialize(a1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(a1,DUMMY_VAR__);
            validate_non_negative_index("beta1", "N", N);
            vector_d beta1(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta1;  // dummy to suppress unused var warning

            stan::math::initialize(beta1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta1,DUMMY_VAR__);
            validate_non_negative_index("a2", "N", N);
            vector_d a2(static_cast<Eigen::VectorXd::Index>(N));
            (void) a2;  // dummy to suppress unused var warning

            stan::math::initialize(a2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(a2,DUMMY_VAR__);
            validate_non_negative_index("beta2", "N", N);
            vector_d beta2(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta2;  // dummy to suppress unused var warning

            stan::math::initialize(beta2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta2,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            vector_d pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("w", "N", N);
            vector_d w(static_cast<Eigen::VectorXd::Index>(N));
            (void) w;  // dummy to suppress unused var warning

            stan::math::initialize(w, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(w,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(a1,i,"a1",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(a1_pr,i,"a1_pr",1)))));
                stan::math::assign(get_base1_lhs(beta1,i,"beta1",1), exp((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta1_pr,i,"beta1_pr",1)))));
                stan::math::assign(get_base1_lhs(a2,i,"a2",1), Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(a2_pr,i,"a2_pr",1)))));
                stan::math::assign(get_base1_lhs(beta2,i,"beta2",1), exp((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(beta2_pr,i,"beta2_pr",1)))));
                stan::math::assign(get_base1_lhs(pi,i,"pi",1), (Phi_approx((get_base1(mu_p,5,"mu_p",1) + (get_base1(sigma,5,"sigma",1) * get_base1(pi_pr,i,"pi_pr",1)))) * 5));
                stan::math::assign(get_base1_lhs(w,i,"w",1), Phi_approx((get_base1(mu_p,6,"mu_p",1) + (get_base1(sigma,6,"sigma",1) * get_base1(w_pr,i,"w_pr",1)))));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"a1",a1,0);
            check_less_or_equal(function__,"a1",a1,1);
            check_greater_or_equal(function__,"beta1",beta1,0);
            check_greater_or_equal(function__,"a2",a2,0);
            check_less_or_equal(function__,"a2",a2,1);
            check_greater_or_equal(function__,"beta2",beta2,0);
            check_greater_or_equal(function__,"pi",pi,0);
            check_less_or_equal(function__,"pi",pi,5);
            check_greater_or_equal(function__,"w",w,0);
            check_less_or_equal(function__,"w",w,1);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(a1[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta1[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(a2[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta2[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_a1(0.0);
            (void) mu_a1;  // dummy to suppress unused var warning

            stan::math::initialize(mu_a1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_a1,DUMMY_VAR__);
            double mu_beta1(0.0);
            (void) mu_beta1;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta1,DUMMY_VAR__);
            double mu_a2(0.0);
            (void) mu_a2;  // dummy to suppress unused var warning

            stan::math::initialize(mu_a2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_a2,DUMMY_VAR__);
            double mu_beta2(0.0);
            (void) mu_beta2;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta2,DUMMY_VAR__);
            double mu_pi(0.0);
            (void) mu_pi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_pi,DUMMY_VAR__);
            double mu_w(0.0);
            (void) mu_w;  // dummy to suppress unused var warning

            stan::math::initialize(mu_w, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_w,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred_step1", "N", N);
            validate_non_negative_index("y_pred_step1", "T", T);
            vector<vector<double> > y_pred_step1(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred_step1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred_step1,DUMMY_VAR__);
            validate_non_negative_index("y_pred_step2", "N", N);
            validate_non_negative_index("y_pred_step2", "T", T);
            vector<vector<double> > y_pred_step2(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred_step2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred_step2,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred_step1,i,"y_pred_step1",1),t,"y_pred_step1",2), -(1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred_step2,i,"y_pred_step2",1),t,"y_pred_step2",2), -(1));
                }
            }
            stan::math::assign(mu_a1, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_beta1, exp(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_a2, Phi_approx(get_base1(mu_p,3,"mu_p",1)));
            stan::math::assign(mu_beta2, exp(get_base1(mu_p,4,"mu_p",1)));
            stan::math::assign(mu_pi, (Phi_approx(get_base1(mu_p,5,"mu_p",1)) * 5));
            stan::math::assign(mu_w, Phi_approx(get_base1(mu_p,6,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("v_mb", "2", 2);
                vector_d v_mb(static_cast<Eigen::VectorXd::Index>(2));
                (void) v_mb;  // dummy to suppress unused var warning

                stan::math::initialize(v_mb, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(v_mb,DUMMY_VAR__);
                validate_non_negative_index("v_mf", "6", 6);
                vector_d v_mf(static_cast<Eigen::VectorXd::Index>(6));
                (void) v_mf;  // dummy to suppress unused var warning

                stan::math::initialize(v_mf, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(v_mf,DUMMY_VAR__);
                validate_non_negative_index("v_hybrid", "2", 2);
                vector_d v_hybrid(static_cast<Eigen::VectorXd::Index>(2));
                (void) v_hybrid;  // dummy to suppress unused var warning

                stan::math::initialize(v_hybrid, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(v_hybrid,DUMMY_VAR__);
                double level1_prob_choice2(0.0);
                (void) level1_prob_choice2;  // dummy to suppress unused var warning

                stan::math::initialize(level1_prob_choice2, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(level1_prob_choice2,DUMMY_VAR__);
                double level2_prob_choice2(0.0);
                (void) level2_prob_choice2;  // dummy to suppress unused var warning

                stan::math::initialize(level2_prob_choice2, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(level2_prob_choice2,DUMMY_VAR__);
                int level1_choice_01(0);
                (void) level1_choice_01;  // dummy to suppress unused var warning

                stan::math::fill(level1_choice_01, std::numeric_limits<int>::min());
                int level2_choice_01(0);
                (void) level2_choice_01;  // dummy to suppress unused var warning

                stan::math::fill(level2_choice_01, std::numeric_limits<int>::min());


                stan::math::assign(v_mb, rep_vector(0.0,2));
                stan::math::assign(v_mf, rep_vector(0.0,6));
                stan::math::assign(v_hybrid, rep_vector(0.0,2));
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(v_mb,1,"v_mb",1), ((trans_prob * stan::math::fmax(get_base1(v_mf,3,"v_mf",1),get_base1(v_mf,4,"v_mf",1))) + ((1 - trans_prob) * stan::math::fmax(get_base1(v_mf,5,"v_mf",1),get_base1(v_mf,6,"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mb,2,"v_mb",1), (((1 - trans_prob) * stan::math::fmax(get_base1(v_mf,3,"v_mf",1),get_base1(v_mf,4,"v_mf",1))) + (trans_prob * stan::math::fmax(get_base1(v_mf,5,"v_mf",1),get_base1(v_mf,6,"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_hybrid,1,"v_hybrid",1), ((get_base1(w,i,"w",1) * get_base1(v_mb,1,"v_mb",1)) + ((1 - get_base1(w,i,"w",1)) * get_base1(v_mf,1,"v_mf",1))));
                    stan::math::assign(get_base1_lhs(v_hybrid,2,"v_hybrid",1), ((get_base1(w,i,"w",1) * get_base1(v_mb,2,"v_mb",1)) + ((1 - get_base1(w,i,"w",1)) * get_base1(v_mf,2,"v_mf",1))));
                    stan::math::assign(level1_choice_01, (get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2) - 1));
                    if (as_bool(logical_eq(t,1))) {

                        stan::math::assign(level1_prob_choice2, inv_logit((get_base1(beta1,i,"beta1",1) * (get_base1(v_hybrid,2,"v_hybrid",1) - get_base1(v_hybrid,1,"v_hybrid",1)))));
                    } else {

                        stan::math::assign(level1_prob_choice2, inv_logit(((get_base1(beta1,i,"beta1",1) * (get_base1(v_hybrid,2,"v_hybrid",1) - get_base1(v_hybrid,1,"v_hybrid",1))) + (get_base1(pi,i,"pi",1) * ((2 * get_base1(get_base1(level1_choice,i,"level1_choice",1),(t - 1),"level1_choice",2)) - 3)))));
                    }
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(level1_choice_01,level1_prob_choice2)));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + (get_base1(a1,i,"a1",1) * (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) - get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1)))));
                    stan::math::assign(level2_choice_01, (1 - modulus(get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2),2)));
                    if (as_bool(logical_gt(get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2),2))) {

                        stan::math::assign(level2_prob_choice2, inv_logit((get_base1(beta2,i,"beta2",1) * (get_base1(v_mf,6,"v_mf",1) - get_base1(v_mf,5,"v_mf",1)))));
                    } else {

                        stan::math::assign(level2_prob_choice2, inv_logit((get_base1(beta2,i,"beta2",1) * (get_base1(v_mf,4,"v_mf",1) - get_base1(v_mf,3,"v_mf",1)))));
                    }
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(level2_choice_01,level2_prob_choice2)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred_step1,i,"y_pred_step1",1),t,"y_pred_step1",2), bernoulli_rng(level1_prob_choice2, base_rng__));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred_step2,i,"y_pred_step2",1),t,"y_pred_step2",2), bernoulli_rng(level2_prob_choice2, base_rng__));
                    stan::math::assign(get_base1_lhs(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1), (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) + (get_base1(a2,i,"a2",1) * (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + (get_base1(a1,i,"a1",1) * (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1)))));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_a1",mu_a1,0);
            check_less_or_equal(function__,"mu_a1",mu_a1,1);
            check_greater_or_equal(function__,"mu_beta1",mu_beta1,0);
            check_greater_or_equal(function__,"mu_a2",mu_a2,0);
            check_less_or_equal(function__,"mu_a2",mu_a2,1);
            check_greater_or_equal(function__,"mu_beta2",mu_beta2,0);
            check_greater_or_equal(function__,"mu_pi",mu_pi,0);
            check_less_or_equal(function__,"mu_pi",mu_pi,5);
            check_greater_or_equal(function__,"mu_w",mu_w,0);
            check_less_or_equal(function__,"mu_w",mu_w,1);

            // write generated quantities
        vars__.push_back(mu_a1);
        vars__.push_back(mu_beta1);
        vars__.push_back(mu_a2);
        vars__.push_back(mu_beta2);
        vars__.push_back(mu_pi);
        vars__.push_back(mu_w);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred_step1[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred_step2[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ts_par6";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a1_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta1_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a2_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta2_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a1" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta1" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_a1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_a2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred_step1" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred_step2" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a1_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta1_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a2_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta2_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a1" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta1" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_a1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_a2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred_step1" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred_step2" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ts_par7_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ts_par7");
    reader.add_event(214, 214, "end", "model_ts_par7");
    return reader;
}

class model_ts_par7 : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > level1_choice;
    vector<vector<int> > level2_choice;
    vector<vector<int> > reward;
    double trans_prob;
public:
    model_ts_par7(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ts_par7(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ts_par7_namespace::model_ts_par7";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("level1_choice", "N", N);
            validate_non_negative_index("level1_choice", "T", T);
            context__.validate_dims("data initialization", "level1_choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("level1_choice", "N", N);
            validate_non_negative_index("level1_choice", "T", T);
            level1_choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("level1_choice");
            pos__ = 0;
            size_t level1_choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < level1_choice_limit_1__; ++i_1__) {
                size_t level1_choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < level1_choice_limit_0__; ++i_0__) {
                    level1_choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("level2_choice", "N", N);
            validate_non_negative_index("level2_choice", "T", T);
            context__.validate_dims("data initialization", "level2_choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("level2_choice", "N", N);
            validate_non_negative_index("level2_choice", "T", T);
            level2_choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("level2_choice");
            pos__ = 0;
            size_t level2_choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < level2_choice_limit_1__; ++i_1__) {
                size_t level2_choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < level2_choice_limit_0__; ++i_0__) {
                    level2_choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("reward", "N", N);
            validate_non_negative_index("reward", "T", T);
            context__.validate_dims("data initialization", "reward", "int", context__.to_vec(N,T));
            validate_non_negative_index("reward", "N", N);
            validate_non_negative_index("reward", "T", T);
            reward = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("reward");
            pos__ = 0;
            size_t reward_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < reward_limit_1__; ++i_1__) {
                size_t reward_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < reward_limit_0__; ++i_0__) {
                    reward[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            context__.validate_dims("data initialization", "trans_prob", "double", context__.to_vec());
            trans_prob = double(0);
            vals_r__ = context__.vals_r("trans_prob");
            pos__ = 0;
            trans_prob = vals_r__[pos__++];

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"level1_choice[k0__][k1__]",level1_choice[k0__][k1__],1);
                    check_less_or_equal(function__,"level1_choice[k0__][k1__]",level1_choice[k0__][k1__],2);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"level2_choice[k0__][k1__]",level2_choice[k0__][k1__],1);
                    check_less_or_equal(function__,"level2_choice[k0__][k1__]",level2_choice[k0__][k1__],4);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"reward[k0__][k1__]",reward[k0__][k1__],0);
                    check_less_or_equal(function__,"reward[k0__][k1__]",reward[k0__][k1__],1);
                }
            }
            check_greater_or_equal(function__,"trans_prob",trans_prob,0);
            check_less_or_equal(function__,"trans_prob",trans_prob,1);
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "7", 7);
            num_params_r__ += 7;
            validate_non_negative_index("sigma", "7", 7);
            num_params_r__ += 7;
            validate_non_negative_index("a1_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta1_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("a2_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("beta2_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("pi_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("w_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("lambda_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ts_par7() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "7", 7);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(7));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(7));
        for (int j1__ = 0U; j1__ < 7; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "7", 7);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(7));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(7));
        for (int j1__ = 0U; j1__ < 7; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("a1_pr")))
            throw std::runtime_error("variable a1_pr missing");
        vals_r__ = context__.vals_r("a1_pr");
        pos__ = 0U;
        validate_non_negative_index("a1_pr", "N", N);
        context__.validate_dims("initialization", "a1_pr", "vector_d", context__.to_vec(N));
        vector_d a1_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            a1_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(a1_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable a1_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta1_pr")))
            throw std::runtime_error("variable beta1_pr missing");
        vals_r__ = context__.vals_r("beta1_pr");
        pos__ = 0U;
        validate_non_negative_index("beta1_pr", "N", N);
        context__.validate_dims("initialization", "beta1_pr", "vector_d", context__.to_vec(N));
        vector_d beta1_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta1_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta1_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta1_pr: ") + e.what());
        }

        if (!(context__.contains_r("a2_pr")))
            throw std::runtime_error("variable a2_pr missing");
        vals_r__ = context__.vals_r("a2_pr");
        pos__ = 0U;
        validate_non_negative_index("a2_pr", "N", N);
        context__.validate_dims("initialization", "a2_pr", "vector_d", context__.to_vec(N));
        vector_d a2_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            a2_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(a2_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable a2_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta2_pr")))
            throw std::runtime_error("variable beta2_pr missing");
        vals_r__ = context__.vals_r("beta2_pr");
        pos__ = 0U;
        validate_non_negative_index("beta2_pr", "N", N);
        context__.validate_dims("initialization", "beta2_pr", "vector_d", context__.to_vec(N));
        vector_d beta2_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta2_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta2_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta2_pr: ") + e.what());
        }

        if (!(context__.contains_r("pi_pr")))
            throw std::runtime_error("variable pi_pr missing");
        vals_r__ = context__.vals_r("pi_pr");
        pos__ = 0U;
        validate_non_negative_index("pi_pr", "N", N);
        context__.validate_dims("initialization", "pi_pr", "vector_d", context__.to_vec(N));
        vector_d pi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            pi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(pi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable pi_pr: ") + e.what());
        }

        if (!(context__.contains_r("w_pr")))
            throw std::runtime_error("variable w_pr missing");
        vals_r__ = context__.vals_r("w_pr");
        pos__ = 0U;
        validate_non_negative_index("w_pr", "N", N);
        context__.validate_dims("initialization", "w_pr", "vector_d", context__.to_vec(N));
        vector_d w_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            w_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(w_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable w_pr: ") + e.what());
        }

        if (!(context__.contains_r("lambda_pr")))
            throw std::runtime_error("variable lambda_pr missing");
        vals_r__ = context__.vals_r("lambda_pr");
        pos__ = 0U;
        validate_non_negative_index("lambda_pr", "N", N);
        context__.validate_dims("initialization", "lambda_pr", "vector_d", context__.to_vec(N));
        vector_d lambda_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            lambda_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(lambda_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(7,lp__);
            else
                mu_p = in__.vector_constrain(7);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,7,lp__);
            else
                sigma = in__.vector_lb_constrain(0,7);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  a1_pr;
            (void) a1_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                a1_pr = in__.vector_constrain(N,lp__);
            else
                a1_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta1_pr;
            (void) beta1_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta1_pr = in__.vector_constrain(N,lp__);
            else
                beta1_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  a2_pr;
            (void) a2_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                a2_pr = in__.vector_constrain(N,lp__);
            else
                a2_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta2_pr;
            (void) beta2_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta2_pr = in__.vector_constrain(N,lp__);
            else
                beta2_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi_pr;
            (void) pi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                pi_pr = in__.vector_constrain(N,lp__);
            else
                pi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  w_pr;
            (void) w_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                w_pr = in__.vector_constrain(N,lp__);
            else
                w_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda_pr;
            (void) lambda_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_pr = in__.vector_constrain(N,lp__);
            else
                lambda_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("a1", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  a1(static_cast<Eigen::VectorXd::Index>(N));
            (void) a1;  // dummy to suppress unused var warning

            stan::math::initialize(a1, DUMMY_VAR__);
            stan::math::fill(a1,DUMMY_VAR__);
            validate_non_negative_index("beta1", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta1(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta1;  // dummy to suppress unused var warning

            stan::math::initialize(beta1, DUMMY_VAR__);
            stan::math::fill(beta1,DUMMY_VAR__);
            validate_non_negative_index("a2", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  a2(static_cast<Eigen::VectorXd::Index>(N));
            (void) a2;  // dummy to suppress unused var warning

            stan::math::initialize(a2, DUMMY_VAR__);
            stan::math::fill(a2,DUMMY_VAR__);
            validate_non_negative_index("beta2", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta2(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta2;  // dummy to suppress unused var warning

            stan::math::initialize(beta2, DUMMY_VAR__);
            stan::math::fill(beta2,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, DUMMY_VAR__);
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("w", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  w(static_cast<Eigen::VectorXd::Index>(N));
            (void) w;  // dummy to suppress unused var warning

            stan::math::initialize(w, DUMMY_VAR__);
            stan::math::fill(w,DUMMY_VAR__);
            validate_non_negative_index("lambda", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, DUMMY_VAR__);
            stan::math::fill(lambda,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(a1,i,"a1",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(a1_pr,i,"a1_pr",1)))));
                stan::math::assign(get_base1_lhs(beta1,i,"beta1",1), exp((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta1_pr,i,"beta1_pr",1)))));
                stan::math::assign(get_base1_lhs(a2,i,"a2",1), Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(a2_pr,i,"a2_pr",1)))));
                stan::math::assign(get_base1_lhs(beta2,i,"beta2",1), exp((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(beta2_pr,i,"beta2_pr",1)))));
                stan::math::assign(get_base1_lhs(pi,i,"pi",1), (Phi_approx((get_base1(mu_p,5,"mu_p",1) + (get_base1(sigma,5,"sigma",1) * get_base1(pi_pr,i,"pi_pr",1)))) * 5));
                stan::math::assign(get_base1_lhs(w,i,"w",1), Phi_approx((get_base1(mu_p,6,"mu_p",1) + (get_base1(sigma,6,"sigma",1) * get_base1(w_pr,i,"w_pr",1)))));
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), Phi_approx((get_base1(mu_p,7,"mu_p",1) + (get_base1(sigma,7,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(a1(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: a1" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta1(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta1" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(a2(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: a2" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta2(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta2" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(w(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: w" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(lambda(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: lambda" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"a1",a1,0);
            check_less_or_equal(function__,"a1",a1,1);
            check_greater_or_equal(function__,"beta1",beta1,0);
            check_greater_or_equal(function__,"a2",a2,0);
            check_less_or_equal(function__,"a2",a2,1);
            check_greater_or_equal(function__,"beta2",beta2,0);
            check_greater_or_equal(function__,"pi",pi,0);
            check_less_or_equal(function__,"pi",pi,5);
            check_greater_or_equal(function__,"w",w,0);
            check_less_or_equal(function__,"w",w,1);
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,1);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(a1_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta1_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(a2_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(beta2_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(pi_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(w_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(lambda_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("v_mb", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  v_mb(static_cast<Eigen::VectorXd::Index>(2));
                (void) v_mb;  // dummy to suppress unused var warning

                stan::math::initialize(v_mb, DUMMY_VAR__);
                stan::math::fill(v_mb,DUMMY_VAR__);
                validate_non_negative_index("v_mf", "6", 6);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  v_mf(static_cast<Eigen::VectorXd::Index>(6));
                (void) v_mf;  // dummy to suppress unused var warning

                stan::math::initialize(v_mf, DUMMY_VAR__);
                stan::math::fill(v_mf,DUMMY_VAR__);
                validate_non_negative_index("v_hybrid", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  v_hybrid(static_cast<Eigen::VectorXd::Index>(2));
                (void) v_hybrid;  // dummy to suppress unused var warning

                stan::math::initialize(v_hybrid, DUMMY_VAR__);
                stan::math::fill(v_hybrid,DUMMY_VAR__);
                T__ level1_prob_choice2;
                (void) level1_prob_choice2;  // dummy to suppress unused var warning

                stan::math::initialize(level1_prob_choice2, DUMMY_VAR__);
                stan::math::fill(level1_prob_choice2,DUMMY_VAR__);
                T__ level2_prob_choice2;
                (void) level2_prob_choice2;  // dummy to suppress unused var warning

                stan::math::initialize(level2_prob_choice2, DUMMY_VAR__);
                stan::math::fill(level2_prob_choice2,DUMMY_VAR__);
                int level1_choice_01(0);
                (void) level1_choice_01;  // dummy to suppress unused var warning

                stan::math::fill(level1_choice_01, std::numeric_limits<int>::min());
                int level2_choice_01(0);
                (void) level2_choice_01;  // dummy to suppress unused var warning

                stan::math::fill(level2_choice_01, std::numeric_limits<int>::min());


                stan::math::assign(v_mb, rep_vector(0.0,2));
                stan::math::assign(v_mf, rep_vector(0.0,6));
                stan::math::assign(v_hybrid, rep_vector(0.0,2));
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(v_mb,1,"v_mb",1), ((trans_prob * stan::math::fmax(get_base1(v_mf,3,"v_mf",1),get_base1(v_mf,4,"v_mf",1))) + ((1 - trans_prob) * stan::math::fmax(get_base1(v_mf,5,"v_mf",1),get_base1(v_mf,6,"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mb,2,"v_mb",1), (((1 - trans_prob) * stan::math::fmax(get_base1(v_mf,3,"v_mf",1),get_base1(v_mf,4,"v_mf",1))) + (trans_prob * stan::math::fmax(get_base1(v_mf,5,"v_mf",1),get_base1(v_mf,6,"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_hybrid,1,"v_hybrid",1), ((get_base1(w,i,"w",1) * get_base1(v_mb,1,"v_mb",1)) + ((1 - get_base1(w,i,"w",1)) * get_base1(v_mf,1,"v_mf",1))));
                    stan::math::assign(get_base1_lhs(v_hybrid,2,"v_hybrid",1), ((get_base1(w,i,"w",1) * get_base1(v_mb,2,"v_mb",1)) + ((1 - get_base1(w,i,"w",1)) * get_base1(v_mf,2,"v_mf",1))));
                    stan::math::assign(level1_choice_01, (get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2) - 1));
                    if (as_bool(logical_eq(t,1))) {

                        stan::math::assign(level1_prob_choice2, inv_logit((get_base1(beta1,i,"beta1",1) * (get_base1(v_hybrid,2,"v_hybrid",1) - get_base1(v_hybrid,1,"v_hybrid",1)))));
                    } else {

                        stan::math::assign(level1_prob_choice2, inv_logit(((get_base1(beta1,i,"beta1",1) * (get_base1(v_hybrid,2,"v_hybrid",1) - get_base1(v_hybrid,1,"v_hybrid",1))) + (get_base1(pi,i,"pi",1) * ((2 * get_base1(get_base1(level1_choice,i,"level1_choice",1),(t - 1),"level1_choice",2)) - 3)))));
                    }
                    lp_accum__.add(bernoulli_log<propto__>(level1_choice_01, level1_prob_choice2));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + (get_base1(a1,i,"a1",1) * (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) - get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1)))));
                    stan::math::assign(level2_choice_01, (1 - modulus(get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2),2)));
                    if (as_bool(logical_gt(get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2),2))) {

                        stan::math::assign(level2_prob_choice2, inv_logit((get_base1(beta2,i,"beta2",1) * (get_base1(v_mf,6,"v_mf",1) - get_base1(v_mf,5,"v_mf",1)))));
                    } else {

                        stan::math::assign(level2_prob_choice2, inv_logit((get_base1(beta2,i,"beta2",1) * (get_base1(v_mf,4,"v_mf",1) - get_base1(v_mf,3,"v_mf",1)))));
                    }
                    lp_accum__.add(bernoulli_log<propto__>(level2_choice_01, level2_prob_choice2));
                    stan::math::assign(get_base1_lhs(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1), (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) + (get_base1(a2,i,"a2",1) * (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + ((get_base1(lambda,i,"lambda",1) * get_base1(a1,i,"a1",1)) * (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1)))));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("a1_pr");
        names__.push_back("beta1_pr");
        names__.push_back("a2_pr");
        names__.push_back("beta2_pr");
        names__.push_back("pi_pr");
        names__.push_back("w_pr");
        names__.push_back("lambda_pr");
        names__.push_back("a1");
        names__.push_back("beta1");
        names__.push_back("a2");
        names__.push_back("beta2");
        names__.push_back("pi");
        names__.push_back("w");
        names__.push_back("lambda");
        names__.push_back("mu_a1");
        names__.push_back("mu_beta1");
        names__.push_back("mu_a2");
        names__.push_back("mu_beta2");
        names__.push_back("mu_pi");
        names__.push_back("mu_w");
        names__.push_back("mu_lambda");
        names__.push_back("log_lik");
        names__.push_back("y_pred_step1");
        names__.push_back("y_pred_step2");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(7);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(7);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ts_par7_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(7);
        vector_d sigma = in__.vector_lb_constrain(0,7);
        vector_d a1_pr = in__.vector_constrain(N);
        vector_d beta1_pr = in__.vector_constrain(N);
        vector_d a2_pr = in__.vector_constrain(N);
        vector_d beta2_pr = in__.vector_constrain(N);
        vector_d pi_pr = in__.vector_constrain(N);
        vector_d w_pr = in__.vector_constrain(N);
        vector_d lambda_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 7; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 7; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(a1_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta1_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(a2_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta2_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("a1", "N", N);
            vector_d a1(static_cast<Eigen::VectorXd::Index>(N));
            (void) a1;  // dummy to suppress unused var warning

            stan::math::initialize(a1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(a1,DUMMY_VAR__);
            validate_non_negative_index("beta1", "N", N);
            vector_d beta1(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta1;  // dummy to suppress unused var warning

            stan::math::initialize(beta1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta1,DUMMY_VAR__);
            validate_non_negative_index("a2", "N", N);
            vector_d a2(static_cast<Eigen::VectorXd::Index>(N));
            (void) a2;  // dummy to suppress unused var warning

            stan::math::initialize(a2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(a2,DUMMY_VAR__);
            validate_non_negative_index("beta2", "N", N);
            vector_d beta2(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta2;  // dummy to suppress unused var warning

            stan::math::initialize(beta2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta2,DUMMY_VAR__);
            validate_non_negative_index("pi", "N", N);
            vector_d pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pi,DUMMY_VAR__);
            validate_non_negative_index("w", "N", N);
            vector_d w(static_cast<Eigen::VectorXd::Index>(N));
            (void) w;  // dummy to suppress unused var warning

            stan::math::initialize(w, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(w,DUMMY_VAR__);
            validate_non_negative_index("lambda", "N", N);
            vector_d lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(lambda,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(a1,i,"a1",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(a1_pr,i,"a1_pr",1)))));
                stan::math::assign(get_base1_lhs(beta1,i,"beta1",1), exp((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta1_pr,i,"beta1_pr",1)))));
                stan::math::assign(get_base1_lhs(a2,i,"a2",1), Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(a2_pr,i,"a2_pr",1)))));
                stan::math::assign(get_base1_lhs(beta2,i,"beta2",1), exp((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(beta2_pr,i,"beta2_pr",1)))));
                stan::math::assign(get_base1_lhs(pi,i,"pi",1), (Phi_approx((get_base1(mu_p,5,"mu_p",1) + (get_base1(sigma,5,"sigma",1) * get_base1(pi_pr,i,"pi_pr",1)))) * 5));
                stan::math::assign(get_base1_lhs(w,i,"w",1), Phi_approx((get_base1(mu_p,6,"mu_p",1) + (get_base1(sigma,6,"sigma",1) * get_base1(w_pr,i,"w_pr",1)))));
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), Phi_approx((get_base1(mu_p,7,"mu_p",1) + (get_base1(sigma,7,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"a1",a1,0);
            check_less_or_equal(function__,"a1",a1,1);
            check_greater_or_equal(function__,"beta1",beta1,0);
            check_greater_or_equal(function__,"a2",a2,0);
            check_less_or_equal(function__,"a2",a2,1);
            check_greater_or_equal(function__,"beta2",beta2,0);
            check_greater_or_equal(function__,"pi",pi,0);
            check_less_or_equal(function__,"pi",pi,5);
            check_greater_or_equal(function__,"w",w,0);
            check_less_or_equal(function__,"w",w,1);
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,1);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(a1[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta1[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(a2[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta2[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_a1(0.0);
            (void) mu_a1;  // dummy to suppress unused var warning

            stan::math::initialize(mu_a1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_a1,DUMMY_VAR__);
            double mu_beta1(0.0);
            (void) mu_beta1;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta1,DUMMY_VAR__);
            double mu_a2(0.0);
            (void) mu_a2;  // dummy to suppress unused var warning

            stan::math::initialize(mu_a2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_a2,DUMMY_VAR__);
            double mu_beta2(0.0);
            (void) mu_beta2;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta2,DUMMY_VAR__);
            double mu_pi(0.0);
            (void) mu_pi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_pi,DUMMY_VAR__);
            double mu_w(0.0);
            (void) mu_w;  // dummy to suppress unused var warning

            stan::math::initialize(mu_w, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_w,DUMMY_VAR__);
            double mu_lambda(0.0);
            (void) mu_lambda;  // dummy to suppress unused var warning

            stan::math::initialize(mu_lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_lambda,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred_step1", "N", N);
            validate_non_negative_index("y_pred_step1", "T", T);
            vector<vector<double> > y_pred_step1(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred_step1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred_step1,DUMMY_VAR__);
            validate_non_negative_index("y_pred_step2", "N", N);
            validate_non_negative_index("y_pred_step2", "T", T);
            vector<vector<double> > y_pred_step2(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred_step2, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred_step2,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred_step1,i,"y_pred_step1",1),t,"y_pred_step1",2), -(1));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred_step2,i,"y_pred_step2",1),t,"y_pred_step2",2), -(1));
                }
            }
            stan::math::assign(mu_a1, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_beta1, exp(get_base1(mu_p,2,"mu_p",1)));
            stan::math::assign(mu_a2, Phi_approx(get_base1(mu_p,3,"mu_p",1)));
            stan::math::assign(mu_beta2, exp(get_base1(mu_p,4,"mu_p",1)));
            stan::math::assign(mu_pi, (Phi_approx(get_base1(mu_p,5,"mu_p",1)) * 5));
            stan::math::assign(mu_w, Phi_approx(get_base1(mu_p,6,"mu_p",1)));
            stan::math::assign(mu_lambda, Phi_approx(get_base1(mu_p,7,"mu_p",1)));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("v_mb", "2", 2);
                vector_d v_mb(static_cast<Eigen::VectorXd::Index>(2));
                (void) v_mb;  // dummy to suppress unused var warning

                stan::math::initialize(v_mb, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(v_mb,DUMMY_VAR__);
                validate_non_negative_index("v_mf", "6", 6);
                vector_d v_mf(static_cast<Eigen::VectorXd::Index>(6));
                (void) v_mf;  // dummy to suppress unused var warning

                stan::math::initialize(v_mf, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(v_mf,DUMMY_VAR__);
                validate_non_negative_index("v_hybrid", "2", 2);
                vector_d v_hybrid(static_cast<Eigen::VectorXd::Index>(2));
                (void) v_hybrid;  // dummy to suppress unused var warning

                stan::math::initialize(v_hybrid, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(v_hybrid,DUMMY_VAR__);
                double level1_prob_choice2(0.0);
                (void) level1_prob_choice2;  // dummy to suppress unused var warning

                stan::math::initialize(level1_prob_choice2, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(level1_prob_choice2,DUMMY_VAR__);
                double level2_prob_choice2(0.0);
                (void) level2_prob_choice2;  // dummy to suppress unused var warning

                stan::math::initialize(level2_prob_choice2, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(level2_prob_choice2,DUMMY_VAR__);
                int level1_choice_01(0);
                (void) level1_choice_01;  // dummy to suppress unused var warning

                stan::math::fill(level1_choice_01, std::numeric_limits<int>::min());
                int level2_choice_01(0);
                (void) level2_choice_01;  // dummy to suppress unused var warning

                stan::math::fill(level2_choice_01, std::numeric_limits<int>::min());


                stan::math::assign(v_mb, rep_vector(0.0,2));
                stan::math::assign(v_mf, rep_vector(0.0,6));
                stan::math::assign(v_hybrid, rep_vector(0.0,2));
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(v_mb,1,"v_mb",1), ((trans_prob * stan::math::fmax(get_base1(v_mf,3,"v_mf",1),get_base1(v_mf,4,"v_mf",1))) + ((1 - trans_prob) * stan::math::fmax(get_base1(v_mf,5,"v_mf",1),get_base1(v_mf,6,"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mb,2,"v_mb",1), (((1 - trans_prob) * stan::math::fmax(get_base1(v_mf,3,"v_mf",1),get_base1(v_mf,4,"v_mf",1))) + (trans_prob * stan::math::fmax(get_base1(v_mf,5,"v_mf",1),get_base1(v_mf,6,"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_hybrid,1,"v_hybrid",1), ((get_base1(w,i,"w",1) * get_base1(v_mb,1,"v_mb",1)) + ((1 - get_base1(w,i,"w",1)) * get_base1(v_mf,1,"v_mf",1))));
                    stan::math::assign(get_base1_lhs(v_hybrid,2,"v_hybrid",1), ((get_base1(w,i,"w",1) * get_base1(v_mb,2,"v_mb",1)) + ((1 - get_base1(w,i,"w",1)) * get_base1(v_mf,2,"v_mf",1))));
                    stan::math::assign(level1_choice_01, (get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2) - 1));
                    if (as_bool(logical_eq(t,1))) {

                        stan::math::assign(level1_prob_choice2, inv_logit((get_base1(beta1,i,"beta1",1) * (get_base1(v_hybrid,2,"v_hybrid",1) - get_base1(v_hybrid,1,"v_hybrid",1)))));
                    } else {

                        stan::math::assign(level1_prob_choice2, inv_logit(((get_base1(beta1,i,"beta1",1) * (get_base1(v_hybrid,2,"v_hybrid",1) - get_base1(v_hybrid,1,"v_hybrid",1))) + (get_base1(pi,i,"pi",1) * ((2 * get_base1(get_base1(level1_choice,i,"level1_choice",1),(t - 1),"level1_choice",2)) - 3)))));
                    }
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(level1_choice_01,level1_prob_choice2)));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + (get_base1(a1,i,"a1",1) * (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) - get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1)))));
                    stan::math::assign(level2_choice_01, (1 - modulus(get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2),2)));
                    if (as_bool(logical_gt(get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2),2))) {

                        stan::math::assign(level2_prob_choice2, inv_logit((get_base1(beta2,i,"beta2",1) * (get_base1(v_mf,6,"v_mf",1) - get_base1(v_mf,5,"v_mf",1)))));
                    } else {

                        stan::math::assign(level2_prob_choice2, inv_logit((get_base1(beta2,i,"beta2",1) * (get_base1(v_mf,4,"v_mf",1) - get_base1(v_mf,3,"v_mf",1)))));
                    }
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(level2_choice_01,level2_prob_choice2)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred_step1,i,"y_pred_step1",1),t,"y_pred_step1",2), bernoulli_rng(level1_prob_choice2, base_rng__));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred_step2,i,"y_pred_step2",1),t,"y_pred_step2",2), bernoulli_rng(level2_prob_choice2, base_rng__));
                    stan::math::assign(get_base1_lhs(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1), (get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1) + (get_base1(a2,i,"a2",1) * (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1)))));
                    stan::math::assign(get_base1_lhs(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1), (get_base1(v_mf,get_base1(get_base1(level1_choice,i,"level1_choice",1),t,"level1_choice",2),"v_mf",1) + ((get_base1(lambda,i,"lambda",1) * get_base1(a1,i,"a1",1)) * (get_base1(get_base1(reward,i,"reward",1),t,"reward",2) - get_base1(v_mf,(2 + get_base1(get_base1(level2_choice,i,"level2_choice",1),t,"level2_choice",2)),"v_mf",1)))));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_a1",mu_a1,0);
            check_less_or_equal(function__,"mu_a1",mu_a1,1);
            check_greater_or_equal(function__,"mu_beta1",mu_beta1,0);
            check_greater_or_equal(function__,"mu_a2",mu_a2,0);
            check_less_or_equal(function__,"mu_a2",mu_a2,1);
            check_greater_or_equal(function__,"mu_beta2",mu_beta2,0);
            check_greater_or_equal(function__,"mu_pi",mu_pi,0);
            check_less_or_equal(function__,"mu_pi",mu_pi,5);
            check_greater_or_equal(function__,"mu_w",mu_w,0);
            check_less_or_equal(function__,"mu_w",mu_w,1);
            check_greater_or_equal(function__,"mu_lambda",mu_lambda,0);
            check_less_or_equal(function__,"mu_lambda",mu_lambda,1);

            // write generated quantities
        vars__.push_back(mu_a1);
        vars__.push_back(mu_beta1);
        vars__.push_back(mu_a2);
        vars__.push_back(mu_beta2);
        vars__.push_back(mu_pi);
        vars__.push_back(mu_w);
        vars__.push_back(mu_lambda);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred_step1[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred_step2[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ts_par7";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 7; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 7; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a1_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta1_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a2_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta2_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a1" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta1" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_a1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_a2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred_step1" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred_step2" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 7; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 7; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a1_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta1_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a2_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta2_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a1" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta1" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_a1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_a2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred_step1" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred_step2" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ug_bayes_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ug_bayes");
    reader.add_event(164, 164, "end", "model_ug_bayes");
    return reader;
}

class model_ug_bayes : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > offer;
    vector<vector<int> > accept;
    double initV;
    double mu0;
    double k0;
    double sig20;
    double nu0;
public:
    model_ug_bayes(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ug_bayes(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ug_bayes_namespace::model_ug_bayes";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("offer", "N", N);
            validate_non_negative_index("offer", "T", T);
            context__.validate_dims("data initialization", "offer", "double", context__.to_vec(N,T));
            validate_non_negative_index("offer", "N", N);
            validate_non_negative_index("offer", "T", T);
            offer = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("offer");
            pos__ = 0;
            size_t offer_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < offer_limit_1__; ++i_1__) {
                size_t offer_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < offer_limit_0__; ++i_0__) {
                    offer[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("accept", "N", N);
            validate_non_negative_index("accept", "T", T);
            context__.validate_dims("data initialization", "accept", "int", context__.to_vec(N,T));
            validate_non_negative_index("accept", "N", N);
            validate_non_negative_index("accept", "T", T);
            accept = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("accept");
            pos__ = 0;
            size_t accept_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < accept_limit_1__; ++i_1__) {
                size_t accept_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < accept_limit_0__; ++i_0__) {
                    accept[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"accept[k0__][k1__]",accept[k0__][k1__],-(1));
                    check_less_or_equal(function__,"accept[k0__][k1__]",accept[k0__][k1__],1);
                }
            }
            // initialize data variables
            initV = double(0);
            stan::math::fill(initV,DUMMY_VAR__);
            mu0 = double(0);
            stan::math::fill(mu0,DUMMY_VAR__);
            k0 = double(0);
            stan::math::fill(k0,DUMMY_VAR__);
            sig20 = double(0);
            stan::math::fill(sig20,DUMMY_VAR__);
            nu0 = double(0);
            stan::math::fill(nu0,DUMMY_VAR__);

            stan::math::assign(initV, 0.0);
            stan::math::assign(mu0, 10.0);
            stan::math::assign(k0, 4.0);
            stan::math::assign(sig20, 4.0);
            stan::math::assign(nu0, 10.0);

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("Beta_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("tau_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ug_bayes() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("Beta_pr")))
            throw std::runtime_error("variable Beta_pr missing");
        vals_r__ = context__.vals_r("Beta_pr");
        pos__ = 0U;
        validate_non_negative_index("Beta_pr", "N", N);
        context__.validate_dims("initialization", "Beta_pr", "vector_d", context__.to_vec(N));
        vector_d Beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Beta_pr: ") + e.what());
        }

        if (!(context__.contains_r("tau_pr")))
            throw std::runtime_error("variable tau_pr missing");
        vals_r__ = context__.vals_r("tau_pr");
        pos__ = 0U;
        validate_non_negative_index("tau_pr", "N", N);
        context__.validate_dims("initialization", "tau_pr", "vector_d", context__.to_vec(N));
        vector_d tau_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Beta_pr;
            (void) Beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Beta_pr = in__.vector_constrain(N,lp__);
            else
                Beta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_pr;
            (void) tau_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_pr = in__.vector_constrain(N,lp__);
            else
                tau_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("alpha", "N", N);
            vector<T__> alpha(N);
            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("Beta", "N", N);
            vector<T__> Beta(N);
            stan::math::initialize(Beta, DUMMY_VAR__);
            stan::math::fill(Beta,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            vector<T__> tau(N);
            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 20));
                stan::math::assign(get_base1_lhs(Beta,i,"Beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Beta_pr,i,"Beta_pr",1)))) * 10));
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Beta[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"alpha[k0__]",alpha[k0__],0);
                check_less_or_equal(function__,"alpha[k0__]",alpha[k0__],20);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Beta[k0__]",Beta[k0__],0);
                check_less_or_equal(function__,"Beta[k0__]",Beta[k0__],10);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"tau[k0__]",tau[k0__],0);
                check_less_or_equal(function__,"tau[k0__]",tau[k0__],10);
            }

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(Beta_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(tau_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                T__ util;
                (void) util;  // dummy to suppress unused var warning

                stan::math::initialize(util, DUMMY_VAR__);
                stan::math::fill(util,DUMMY_VAR__);
                T__ mu_old;
                (void) mu_old;  // dummy to suppress unused var warning

                stan::math::initialize(mu_old, DUMMY_VAR__);
                stan::math::fill(mu_old,DUMMY_VAR__);
                T__ mu_new;
                (void) mu_new;  // dummy to suppress unused var warning

                stan::math::initialize(mu_new, DUMMY_VAR__);
                stan::math::fill(mu_new,DUMMY_VAR__);
                T__ k_old;
                (void) k_old;  // dummy to suppress unused var warning

                stan::math::initialize(k_old, DUMMY_VAR__);
                stan::math::fill(k_old,DUMMY_VAR__);
                T__ k_new;
                (void) k_new;  // dummy to suppress unused var warning

                stan::math::initialize(k_new, DUMMY_VAR__);
                stan::math::fill(k_new,DUMMY_VAR__);
                T__ sig2_old;
                (void) sig2_old;  // dummy to suppress unused var warning

                stan::math::initialize(sig2_old, DUMMY_VAR__);
                stan::math::fill(sig2_old,DUMMY_VAR__);
                T__ sig2_new;
                (void) sig2_new;  // dummy to suppress unused var warning

                stan::math::initialize(sig2_new, DUMMY_VAR__);
                stan::math::fill(sig2_new,DUMMY_VAR__);
                T__ nu_old;
                (void) nu_old;  // dummy to suppress unused var warning

                stan::math::initialize(nu_old, DUMMY_VAR__);
                stan::math::fill(nu_old,DUMMY_VAR__);
                T__ nu_new;
                (void) nu_new;  // dummy to suppress unused var warning

                stan::math::initialize(nu_new, DUMMY_VAR__);
                stan::math::fill(nu_new,DUMMY_VAR__);
                T__ PE;
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, DUMMY_VAR__);
                stan::math::fill(PE,DUMMY_VAR__);


                stan::math::assign(mu_old, mu0);
                stan::math::assign(k_old, k0);
                stan::math::assign(sig2_old, sig20);
                stan::math::assign(nu_old, nu0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(k_new, (k_old + 1));
                    stan::math::assign(nu_new, (nu_old + 1));
                    stan::math::assign(mu_new, (((k_old / k_new) * mu_old) + ((1 / k_new) * get_base1(get_base1(offer,i,"offer",1),t,"offer",2))));
                    stan::math::assign(sig2_new, (((nu_old / nu_new) * sig2_old) + (((1 / nu_new) * (k_old / k_new)) * pow((get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - mu_old),2))));
                    stan::math::assign(PE, (get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - mu_old));
                    stan::math::assign(util, ((get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - (get_base1(alpha,i,"alpha",1) * stan::math::fmax((mu_new - get_base1(get_base1(offer,i,"offer",1),t,"offer",2)),0.0))) - (get_base1(Beta,i,"Beta",1) * stan::math::fmax((get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - mu_new),0.0))));
                    lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(accept,i,"accept",1),t,"accept",2), (util * get_base1(tau,i,"tau",1))));
                    stan::math::assign(mu_old, mu_new);
                    stan::math::assign(sig2_old, sig2_new);
                    stan::math::assign(k_old, k_new);
                    stan::math::assign(nu_old, nu_new);
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("alpha_pr");
        names__.push_back("Beta_pr");
        names__.push_back("tau_pr");
        names__.push_back("alpha");
        names__.push_back("Beta");
        names__.push_back("tau");
        names__.push_back("mu_alpha");
        names__.push_back("mu_Beta");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ug_bayes_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d Beta_pr = in__.vector_constrain(N);
        vector_d tau_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Beta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("alpha", "N", N);
            vector<double> alpha(N, 0.0);
            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("Beta", "N", N);
            vector<double> Beta(N, 0.0);
            stan::math::initialize(Beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Beta,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            vector<double> tau(N, 0.0);
            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 20));
                stan::math::assign(get_base1_lhs(Beta,i,"Beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Beta_pr,i,"Beta_pr",1)))) * 10));
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"alpha[k0__]",alpha[k0__],0);
                check_less_or_equal(function__,"alpha[k0__]",alpha[k0__],20);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Beta[k0__]",Beta[k0__],0);
                check_less_or_equal(function__,"Beta[k0__]",Beta[k0__],10);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"tau[k0__]",tau[k0__],0);
                check_less_or_equal(function__,"tau[k0__]",tau[k0__],10);
            }

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Beta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            double mu_Beta(0.0);
            (void) mu_Beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Beta,DUMMY_VAR__);
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_alpha, (Phi_approx(get_base1(mu_p,1,"mu_p",1)) * 20));
            stan::math::assign(mu_Beta, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 10));
            stan::math::assign(mu_tau, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 10));

            for (int i = 1; i <= N; ++i) {
                {
                double util(0.0);
                (void) util;  // dummy to suppress unused var warning

                stan::math::initialize(util, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(util,DUMMY_VAR__);
                double mu_old(0.0);
                (void) mu_old;  // dummy to suppress unused var warning

                stan::math::initialize(mu_old, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(mu_old,DUMMY_VAR__);
                double mu_new(0.0);
                (void) mu_new;  // dummy to suppress unused var warning

                stan::math::initialize(mu_new, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(mu_new,DUMMY_VAR__);
                double k_old(0.0);
                (void) k_old;  // dummy to suppress unused var warning

                stan::math::initialize(k_old, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(k_old,DUMMY_VAR__);
                double k_new(0.0);
                (void) k_new;  // dummy to suppress unused var warning

                stan::math::initialize(k_new, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(k_new,DUMMY_VAR__);
                double sig2_old(0.0);
                (void) sig2_old;  // dummy to suppress unused var warning

                stan::math::initialize(sig2_old, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sig2_old,DUMMY_VAR__);
                double sig2_new(0.0);
                (void) sig2_new;  // dummy to suppress unused var warning

                stan::math::initialize(sig2_new, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sig2_new,DUMMY_VAR__);
                double nu_old(0.0);
                (void) nu_old;  // dummy to suppress unused var warning

                stan::math::initialize(nu_old, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(nu_old,DUMMY_VAR__);
                double nu_new(0.0);
                (void) nu_new;  // dummy to suppress unused var warning

                stan::math::initialize(nu_new, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(nu_new,DUMMY_VAR__);
                double PE(0.0);
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PE,DUMMY_VAR__);


                stan::math::assign(mu_old, mu0);
                stan::math::assign(k_old, k0);
                stan::math::assign(sig2_old, sig20);
                stan::math::assign(nu_old, nu0);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(k_new, (k_old + 1));
                    stan::math::assign(nu_new, (nu_old + 1));
                    stan::math::assign(mu_new, (((k_old / k_new) * mu_old) + ((1 / k_new) * get_base1(get_base1(offer,i,"offer",1),t,"offer",2))));
                    stan::math::assign(sig2_new, (((nu_old / nu_new) * sig2_old) + (((1 / nu_new) * (k_old / k_new)) * pow((get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - mu_old),2))));
                    stan::math::assign(PE, (get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - mu_old));
                    stan::math::assign(util, ((get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - (get_base1(alpha,i,"alpha",1) * stan::math::fmax((mu_new - get_base1(get_base1(offer,i,"offer",1),t,"offer",2)),0.0))) - (get_base1(Beta,i,"Beta",1) * stan::math::fmax((get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - mu_new),0.0))));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(accept,i,"accept",1),t,"accept",2),(util * get_base1(tau,i,"tau",1)))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(inv_logit((util * get_base1(tau,i,"tau",1))), base_rng__));
                    stan::math::assign(mu_old, mu_new);
                    stan::math::assign(sig2_old, sig2_new);
                    stan::math::assign(k_old, k_new);
                    stan::math::assign(nu_old, nu_new);
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_less_or_equal(function__,"mu_alpha",mu_alpha,20);
            check_greater_or_equal(function__,"mu_Beta",mu_Beta,0);
            check_less_or_equal(function__,"mu_Beta",mu_Beta,10);
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);
            check_less_or_equal(function__,"mu_tau",mu_tau,10);

            // write generated quantities
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_Beta);
        vars__.push_back(mu_tau);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ug_bayes";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ug_delta_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ug_delta");
    reader.add_event(126, 126, "end", "model_ug_delta");
    return reader;
}

class model_ug_delta : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > offer;
    vector<vector<int> > accept;
public:
    model_ug_delta(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ug_delta(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ug_delta_namespace::model_ug_delta";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("offer", "N", N);
            validate_non_negative_index("offer", "T", T);
            context__.validate_dims("data initialization", "offer", "double", context__.to_vec(N,T));
            validate_non_negative_index("offer", "N", N);
            validate_non_negative_index("offer", "T", T);
            offer = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("offer");
            pos__ = 0;
            size_t offer_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < offer_limit_1__; ++i_1__) {
                size_t offer_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < offer_limit_0__; ++i_0__) {
                    offer[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("accept", "N", N);
            validate_non_negative_index("accept", "T", T);
            context__.validate_dims("data initialization", "accept", "int", context__.to_vec(N,T));
            validate_non_negative_index("accept", "N", N);
            validate_non_negative_index("accept", "T", T);
            accept = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("accept");
            pos__ = 0;
            size_t accept_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < accept_limit_1__; ++i_1__) {
                size_t accept_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < accept_limit_0__; ++i_0__) {
                    accept[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"accept[k0__][k1__]",accept[k0__][k1__],-(1));
                    check_less_or_equal(function__,"accept[k0__][k1__]",accept[k0__][k1__],1);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("tau_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ug_delta() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("tau_pr")))
            throw std::runtime_error("variable tau_pr missing");
        vals_r__ = context__.vals_r("tau_pr");
        pos__ = 0U;
        validate_non_negative_index("tau_pr", "N", N);
        context__.validate_dims("initialization", "tau_pr", "vector_d", context__.to_vec(N));
        vector_d tau_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_pr;
            (void) tau_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_pr = in__.vector_constrain(N,lp__);
            else
                tau_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("ep", "N", N);
            vector<T__> ep(N);
            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            vector<T__> alpha(N);
            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            vector<T__> tau(N);
            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * 10));
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 20));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"ep[k0__]",ep[k0__],0);
                check_less_or_equal(function__,"ep[k0__]",ep[k0__],1);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"alpha[k0__]",alpha[k0__],0);
                check_less_or_equal(function__,"alpha[k0__]",alpha[k0__],20);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"tau[k0__]",tau[k0__],0);
                check_less_or_equal(function__,"tau[k0__]",tau[k0__],10);
            }

            // model body

            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1.0));
            lp_accum__.add(normal_log<propto__>(tau_pr, 0, 1.0));
            for (int i = 1; i <= N; ++i) {
                {
                T__ f;
                (void) f;  // dummy to suppress unused var warning

                stan::math::initialize(f, DUMMY_VAR__);
                stan::math::fill(f,DUMMY_VAR__);
                T__ PE;
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, DUMMY_VAR__);
                stan::math::fill(PE,DUMMY_VAR__);
                T__ util;
                (void) util;  // dummy to suppress unused var warning

                stan::math::initialize(util, DUMMY_VAR__);
                stan::math::fill(util,DUMMY_VAR__);


                stan::math::assign(f, 10.0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(PE, (get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - f));
                    stan::math::assign(util, (get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - (get_base1(alpha,i,"alpha",1) * stan::math::fmax((f - get_base1(get_base1(offer,i,"offer",1),t,"offer",2)),0.0))));
                    lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(accept,i,"accept",1),t,"accept",2), (util * get_base1(tau,i,"tau",1))));
                    stan::math::assign(f, (f + (get_base1(ep,i,"ep",1) * PE)));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("ep_pr");
        names__.push_back("alpha_pr");
        names__.push_back("tau_pr");
        names__.push_back("ep");
        names__.push_back("alpha");
        names__.push_back("tau");
        names__.push_back("mu_ep");
        names__.push_back("mu_tau");
        names__.push_back("mu_alpha");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ug_delta_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d tau_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("ep", "N", N);
            vector<double> ep(N, 0.0);
            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            validate_non_negative_index("alpha", "N", N);
            vector<double> alpha(N, 0.0);
            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            validate_non_negative_index("tau", "N", N);
            vector<double> tau(N, 0.0);
            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * 10));
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 20));
            }

            // validate transformed parameters
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"ep[k0__]",ep[k0__],0);
                check_less_or_equal(function__,"ep[k0__]",ep[k0__],1);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"alpha[k0__]",alpha[k0__],0);
                check_less_or_equal(function__,"alpha[k0__]",alpha[k0__],20);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"tau[k0__]",tau[k0__],0);
                check_less_or_equal(function__,"tau[k0__]",tau[k0__],10);
            }

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            stan::math::assign(mu_tau, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 10));
            stan::math::assign(mu_alpha, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 20));

            for (int i = 1; i <= N; ++i) {
                {
                double f(0.0);
                (void) f;  // dummy to suppress unused var warning

                stan::math::initialize(f, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(f,DUMMY_VAR__);
                double PE(0.0);
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PE,DUMMY_VAR__);
                double util(0.0);
                (void) util;  // dummy to suppress unused var warning

                stan::math::initialize(util, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(util,DUMMY_VAR__);


                stan::math::assign(f, 10.0);
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0.0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(PE, (get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - f));
                    stan::math::assign(util, (get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - (get_base1(alpha,i,"alpha",1) * stan::math::fmax((f - get_base1(get_base1(offer,i,"offer",1),t,"offer",2)),0.0))));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(accept,i,"accept",1),t,"accept",2),(util * get_base1(tau,i,"tau",1)))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(inv_logit((util * get_base1(tau,i,"tau",1))), base_rng__));
                    stan::math::assign(f, (f + (get_base1(ep,i,"ep",1) * PE)));
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);
            check_less_or_equal(function__,"mu_tau",mu_tau,10);
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_less_or_equal(function__,"mu_alpha",mu_alpha,20);

            // write generated quantities
        vars__.push_back(mu_ep);
        vars__.push_back(mu_tau);
        vars__.push_back(mu_alpha);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ug_delta";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_wcs_sql_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_wcs_sql");
    reader.add_event(166, 166, "end", "model_wcs_sql");
    return reader;
}

class model_wcs_sql : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<vector<int> > > choice;
    vector<vector<int> > outcome;
    vector<vector<matrix_d> > choice_match_att;
    vector<matrix_d> deck_match_rule;
    matrix_d initAtt;
    matrix_d unit;
public:
    model_wcs_sql(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_wcs_sql(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_wcs_sql_namespace::model_wcs_sql";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "4", 4);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,4,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "4", 4);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<std::vector<int> > >(N,std::vector<std::vector<int> >(4,std::vector<int>(T,int(0))));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_2__ = T;
            for (size_t i_2__ = 0; i_2__ < choice_limit_2__; ++i_2__) {
                size_t choice_limit_1__ = 4;
                for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                    size_t choice_limit_0__ = N;
                    for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                        choice[i_0__][i_1__][i_2__] = vals_i__[pos__++];
                    }
                }
            }
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "int", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            validate_non_negative_index("choice_match_att", "N", N);
            validate_non_negative_index("choice_match_att", "T", T);
            validate_non_negative_index("choice_match_att", "1", 1);
            validate_non_negative_index("choice_match_att", "3", 3);
            context__.validate_dims("data initialization", "choice_match_att", "matrix_d", context__.to_vec(N,T,1,3));
            validate_non_negative_index("choice_match_att", "N", N);
            validate_non_negative_index("choice_match_att", "T", T);
            validate_non_negative_index("choice_match_att", "1", 1);
            validate_non_negative_index("choice_match_att", "3", 3);
            choice_match_att = std::vector<std::vector<matrix_d> >(N,std::vector<matrix_d>(T,matrix_d(static_cast<Eigen::VectorXd::Index>(1),static_cast<Eigen::VectorXd::Index>(3))));
            vals_r__ = context__.vals_r("choice_match_att");
            pos__ = 0;
            size_t choice_match_att_m_mat_lim__ = 1;
            size_t choice_match_att_n_mat_lim__ = 3;
            for (size_t n_mat__ = 0; n_mat__ < choice_match_att_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < choice_match_att_m_mat_lim__; ++m_mat__) {
                    size_t choice_match_att_limit_1__ = T;
                    for (size_t i_1__ = 0; i_1__ < choice_match_att_limit_1__; ++i_1__) {
                        size_t choice_match_att_limit_0__ = N;
                        for (size_t i_0__ = 0; i_0__ < choice_match_att_limit_0__; ++i_0__) {
                            choice_match_att[i_0__][i_1__](m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
                }
            }
            validate_non_negative_index("deck_match_rule", "T", T);
            validate_non_negative_index("deck_match_rule", "3", 3);
            validate_non_negative_index("deck_match_rule", "4", 4);
            context__.validate_dims("data initialization", "deck_match_rule", "matrix_d", context__.to_vec(T,3,4));
            validate_non_negative_index("deck_match_rule", "T", T);
            validate_non_negative_index("deck_match_rule", "3", 3);
            validate_non_negative_index("deck_match_rule", "4", 4);
            deck_match_rule = std::vector<matrix_d>(T,matrix_d(static_cast<Eigen::VectorXd::Index>(3),static_cast<Eigen::VectorXd::Index>(4)));
            vals_r__ = context__.vals_r("deck_match_rule");
            pos__ = 0;
            size_t deck_match_rule_m_mat_lim__ = 3;
            size_t deck_match_rule_n_mat_lim__ = 4;
            for (size_t n_mat__ = 0; n_mat__ < deck_match_rule_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < deck_match_rule_m_mat_lim__; ++m_mat__) {
                    size_t deck_match_rule_limit_0__ = T;
                    for (size_t i_0__ = 0; i_0__ < deck_match_rule_limit_0__; ++i_0__) {
                        deck_match_rule[i_0__](m_mat__,n_mat__) = vals_r__[pos__++];
            }
                }
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],40);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < 4; ++k1__) {
                    for (int k2__ = 0; k2__ < T; ++k2__) {
                        check_greater_or_equal(function__,"choice[k0__][k1__][k2__]",choice[k0__][k1__][k2__],0);
                        check_less_or_equal(function__,"choice[k0__][k1__][k2__]",choice[k0__][k1__][k2__],4);
                    }
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"outcome[k0__][k1__]",outcome[k0__][k1__],-(1));
                    check_less_or_equal(function__,"outcome[k0__][k1__]",outcome[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice_match_att[k0__][k1__]",choice_match_att[k0__][k1__],0);
                    check_less_or_equal(function__,"choice_match_att[k0__][k1__]",choice_match_att[k0__][k1__],1);
                }
            }
            for (int k0__ = 0; k0__ < T; ++k0__) {
                check_greater_or_equal(function__,"deck_match_rule[k0__]",deck_match_rule[k0__],0);
                check_less_or_equal(function__,"deck_match_rule[k0__]",deck_match_rule[k0__],1);
            }
            // initialize data variables
            validate_non_negative_index("initAtt", "1", 1);
            validate_non_negative_index("initAtt", "3", 3);
            initAtt = matrix_d(static_cast<Eigen::VectorXd::Index>(1),static_cast<Eigen::VectorXd::Index>(3));
            stan::math::fill(initAtt,DUMMY_VAR__);
            validate_non_negative_index("unit", "1", 1);
            validate_non_negative_index("unit", "3", 3);
            unit = matrix_d(static_cast<Eigen::VectorXd::Index>(1),static_cast<Eigen::VectorXd::Index>(3));
            stan::math::fill(unit,DUMMY_VAR__);

            stan::math::assign(initAtt, rep_matrix((1.0 / 3.0),1,3));
            stan::math::assign(unit, rep_matrix(1.0,1,3));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu_pr", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            validate_non_negative_index("r_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("p_pr", "N", N);
            num_params_r__ += N;
            validate_non_negative_index("d_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_wcs_sql() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_pr")))
            throw std::runtime_error("variable mu_pr missing");
        vals_r__ = context__.vals_r("mu_pr");
        pos__ = 0U;
        validate_non_negative_index("mu_pr", "3", 3);
        context__.validate_dims("initialization", "mu_pr", "vector_d", context__.to_vec(3));
        vector_d mu_pr(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_pr: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("r_pr")))
            throw std::runtime_error("variable r_pr missing");
        vals_r__ = context__.vals_r("r_pr");
        pos__ = 0U;
        validate_non_negative_index("r_pr", "N", N);
        context__.validate_dims("initialization", "r_pr", "vector_d", context__.to_vec(N));
        vector_d r_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            r_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(r_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable r_pr: ") + e.what());
        }

        if (!(context__.contains_r("p_pr")))
            throw std::runtime_error("variable p_pr missing");
        vals_r__ = context__.vals_r("p_pr");
        pos__ = 0U;
        validate_non_negative_index("p_pr", "N", N);
        context__.validate_dims("initialization", "p_pr", "vector_d", context__.to_vec(N));
        vector_d p_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            p_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(p_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable p_pr: ") + e.what());
        }

        if (!(context__.contains_r("d_pr")))
            throw std::runtime_error("variable d_pr missing");
        vals_r__ = context__.vals_r("d_pr");
        pos__ = 0U;
        validate_non_negative_index("d_pr", "N", N);
        context__.validate_dims("initialization", "d_pr", "vector_d", context__.to_vec(N));
        vector_d d_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            d_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(d_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable d_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_pr;
            (void) mu_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_pr = in__.vector_constrain(3,lp__);
            else
                mu_pr = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  r_pr;
            (void) r_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                r_pr = in__.vector_constrain(N,lp__);
            else
                r_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  p_pr;
            (void) p_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                p_pr = in__.vector_constrain(N,lp__);
            else
                p_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  d_pr;
            (void) d_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                d_pr = in__.vector_constrain(N,lp__);
            else
                d_pr = in__.vector_constrain(N);


            // transformed parameters
            validate_non_negative_index("r", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  r(static_cast<Eigen::VectorXd::Index>(N));
            (void) r;  // dummy to suppress unused var warning

            stan::math::initialize(r, DUMMY_VAR__);
            stan::math::fill(r,DUMMY_VAR__);
            validate_non_negative_index("p", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  p(static_cast<Eigen::VectorXd::Index>(N));
            (void) p;  // dummy to suppress unused var warning

            stan::math::initialize(p, DUMMY_VAR__);
            stan::math::fill(p,DUMMY_VAR__);
            validate_non_negative_index("d", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  d(static_cast<Eigen::VectorXd::Index>(N));
            (void) d;  // dummy to suppress unused var warning

            stan::math::initialize(d, DUMMY_VAR__);
            stan::math::fill(d,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(r,i,"r",1), Phi_approx((get_base1(mu_pr,1,"mu_pr",1) + (get_base1(sigma,1,"sigma",1) * get_base1(r_pr,i,"r_pr",1)))));
                stan::math::assign(get_base1_lhs(p,i,"p",1), Phi_approx((get_base1(mu_pr,2,"mu_pr",1) + (get_base1(sigma,2,"sigma",1) * get_base1(p_pr,i,"p_pr",1)))));
                stan::math::assign(get_base1_lhs(d,i,"d",1), (Phi_approx((get_base1(mu_pr,3,"mu_pr",1) + (get_base1(sigma,3,"sigma",1) * get_base1(d_pr,i,"d_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(r(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: r" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(p(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: p" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(d(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: d" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"r",r,0);
            check_less_or_equal(function__,"r",r,1);
            check_greater_or_equal(function__,"p",p,0);
            check_less_or_equal(function__,"p",p,1);
            check_greater_or_equal(function__,"d",d,0);

            // model body

            lp_accum__.add(normal_log<propto__>(mu_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(sigma, 0, 0.20000000000000001));
            lp_accum__.add(normal_log<propto__>(r_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(p_pr, 0, 1));
            lp_accum__.add(normal_log<propto__>(d_pr, 0, 1));
            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("pred_prob_mat", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pred_prob_mat(static_cast<Eigen::VectorXd::Index>(4));
                (void) pred_prob_mat;  // dummy to suppress unused var warning

                stan::math::initialize(pred_prob_mat, DUMMY_VAR__);
                stan::math::fill(pred_prob_mat,DUMMY_VAR__);
                validate_non_negative_index("subj_att", "1", 1);
                validate_non_negative_index("subj_att", "3", 3);
                Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  subj_att(static_cast<Eigen::VectorXd::Index>(1),static_cast<Eigen::VectorXd::Index>(3));
                (void) subj_att;  // dummy to suppress unused var warning

                stan::math::initialize(subj_att, DUMMY_VAR__);
                stan::math::fill(subj_att,DUMMY_VAR__);
                validate_non_negative_index("att_signal", "1", 1);
                validate_non_negative_index("att_signal", "3", 3);
                Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  att_signal(static_cast<Eigen::VectorXd::Index>(1),static_cast<Eigen::VectorXd::Index>(3));
                (void) att_signal;  // dummy to suppress unused var warning

                stan::math::initialize(att_signal, DUMMY_VAR__);
                stan::math::fill(att_signal,DUMMY_VAR__);
                validate_non_negative_index("tmpatt", "1", 1);
                validate_non_negative_index("tmpatt", "3", 3);
                Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  tmpatt(static_cast<Eigen::VectorXd::Index>(1),static_cast<Eigen::VectorXd::Index>(3));
                (void) tmpatt;  // dummy to suppress unused var warning

                stan::math::initialize(tmpatt, DUMMY_VAR__);
                stan::math::fill(tmpatt,DUMMY_VAR__);
                validate_non_negative_index("tmpp", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  tmpp(static_cast<Eigen::VectorXd::Index>(4));
                (void) tmpp;  // dummy to suppress unused var warning

                stan::math::initialize(tmpp, DUMMY_VAR__);
                stan::math::fill(tmpp,DUMMY_VAR__);


                stan::math::assign(subj_att, initAtt);
                stan::math::assign(pred_prob_mat, to_vector(multiply(subj_att,stan::model::rvalue(deck_match_rule, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "deck_match_rule"))));
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    lp_accum__.add(multinomial_log<propto__>(stan::model::rvalue(choice, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()))), "choice"), pred_prob_mat));
                    if (as_bool(logical_eq(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),1))) {

                        stan::math::assign(att_signal, elt_multiply(subj_att,get_base1(get_base1(choice_match_att,i,"choice_match_att",1),t,"choice_match_att",2)));
                        stan::math::assign(att_signal, divide(att_signal,sum(att_signal)));
                        stan::math::assign(tmpatt, add(multiply((1.0 - get_base1(r,i,"r",1)),subj_att),multiply(get_base1(r,i,"r",1),att_signal)));
                    } else {

                        stan::math::assign(att_signal, elt_multiply(subj_att,subtract(unit,get_base1(get_base1(choice_match_att,i,"choice_match_att",1),t,"choice_match_att",2))));
                        stan::math::assign(att_signal, divide(att_signal,sum(att_signal)));
                        stan::math::assign(tmpatt, add(multiply((1.0 - get_base1(p,i,"p",1)),subj_att),multiply(get_base1(p,i,"p",1),att_signal)));
                    }
                    stan::math::assign(subj_att, add(multiply(divide(tmpatt,sum(tmpatt)),0.99980000000000002),0.0001));
                    stan::math::assign(get_base1_lhs(tmpatt,1,1,"tmpatt",1), pow(get_base1(subj_att,1,1,"subj_att",1),get_base1(d,i,"d",1)));
                    stan::math::assign(get_base1_lhs(tmpatt,1,2,"tmpatt",1), pow(get_base1(subj_att,1,2,"subj_att",1),get_base1(d,i,"d",1)));
                    stan::math::assign(get_base1_lhs(tmpatt,1,3,"tmpatt",1), pow(get_base1(subj_att,1,3,"subj_att",1),get_base1(d,i,"d",1)));
                    if (as_bool(logical_lt(t,get_base1(Tsubj,i,"Tsubj",1)))) {

                        stan::math::assign(tmpp, add(multiply(to_vector(multiply(tmpatt,stan::model::rvalue(deck_match_rule, stan::model::cons_list(stan::model::index_uni((t + 1)), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "deck_match_rule"))),0.99980000000000002),0.0001));
                        stan::math::assign(pred_prob_mat, divide(tmpp,sum(tmpp)));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_pr");
        names__.push_back("sigma");
        names__.push_back("r_pr");
        names__.push_back("p_pr");
        names__.push_back("d_pr");
        names__.push_back("r");
        names__.push_back("p");
        names__.push_back("d");
        names__.push_back("mu_r");
        names__.push_back("mu_p");
        names__.push_back("mu_d");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(4);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_wcs_sql_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_pr = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d r_pr = in__.vector_constrain(N);
        vector_d p_pr = in__.vector_constrain(N);
        vector_d d_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(r_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(p_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(d_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("r", "N", N);
            vector_d r(static_cast<Eigen::VectorXd::Index>(N));
            (void) r;  // dummy to suppress unused var warning

            stan::math::initialize(r, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(r,DUMMY_VAR__);
            validate_non_negative_index("p", "N", N);
            vector_d p(static_cast<Eigen::VectorXd::Index>(N));
            (void) p;  // dummy to suppress unused var warning

            stan::math::initialize(p, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(p,DUMMY_VAR__);
            validate_non_negative_index("d", "N", N);
            vector_d d(static_cast<Eigen::VectorXd::Index>(N));
            (void) d;  // dummy to suppress unused var warning

            stan::math::initialize(d, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(d,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(r,i,"r",1), Phi_approx((get_base1(mu_pr,1,"mu_pr",1) + (get_base1(sigma,1,"sigma",1) * get_base1(r_pr,i,"r_pr",1)))));
                stan::math::assign(get_base1_lhs(p,i,"p",1), Phi_approx((get_base1(mu_pr,2,"mu_pr",1) + (get_base1(sigma,2,"sigma",1) * get_base1(p_pr,i,"p_pr",1)))));
                stan::math::assign(get_base1_lhs(d,i,"d",1), (Phi_approx((get_base1(mu_pr,3,"mu_pr",1) + (get_base1(sigma,3,"sigma",1) * get_base1(d_pr,i,"d_pr",1)))) * 5));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"r",r,0);
            check_less_or_equal(function__,"r",r,1);
            check_greater_or_equal(function__,"p",p,0);
            check_less_or_equal(function__,"p",p,1);
            check_greater_or_equal(function__,"d",d,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(r[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(d[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            double mu_r(0.0);
            (void) mu_r;  // dummy to suppress unused var warning

            stan::math::initialize(mu_r, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_r,DUMMY_VAR__);
            double mu_p(0.0);
            (void) mu_p;  // dummy to suppress unused var warning

            stan::math::initialize(mu_p, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_p,DUMMY_VAR__);
            double mu_d(0.0);
            (void) mu_d;  // dummy to suppress unused var warning

            stan::math::initialize(mu_d, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_d,DUMMY_VAR__);
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "4", 4);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<vector<int> > > y_pred(N, (vector<vector<int> >(4, (vector<int>(T, 0)))));
            stan::math::fill(y_pred, std::numeric_limits<int>::min());


            for (int i = 1; i <= N; ++i) {

                for (int t = 1; t <= T; ++t) {

                    for (int deck = 1; deck <= 4; ++deck) {

                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),deck,"y_pred",2),t,"y_pred",3), -(1));
                    }
                }
            }
            stan::math::assign(mu_r, Phi_approx(get_base1(mu_pr,1,"mu_pr",1)));
            stan::math::assign(mu_p, Phi_approx(get_base1(mu_pr,2,"mu_pr",1)));
            stan::math::assign(mu_d, (Phi_approx(get_base1(mu_pr,3,"mu_pr",1)) * 5));

            for (int i = 1; i <= N; ++i) {
                {
                validate_non_negative_index("subj_att", "1", 1);
                validate_non_negative_index("subj_att", "3", 3);
                matrix_d subj_att(static_cast<Eigen::VectorXd::Index>(1),static_cast<Eigen::VectorXd::Index>(3));
                (void) subj_att;  // dummy to suppress unused var warning

                stan::math::initialize(subj_att, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(subj_att,DUMMY_VAR__);
                validate_non_negative_index("att_signal", "1", 1);
                validate_non_negative_index("att_signal", "3", 3);
                matrix_d att_signal(static_cast<Eigen::VectorXd::Index>(1),static_cast<Eigen::VectorXd::Index>(3));
                (void) att_signal;  // dummy to suppress unused var warning

                stan::math::initialize(att_signal, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(att_signal,DUMMY_VAR__);
                validate_non_negative_index("pred_prob_mat", "4", 4);
                vector_d pred_prob_mat(static_cast<Eigen::VectorXd::Index>(4));
                (void) pred_prob_mat;  // dummy to suppress unused var warning

                stan::math::initialize(pred_prob_mat, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pred_prob_mat,DUMMY_VAR__);
                validate_non_negative_index("tmpatt", "1", 1);
                validate_non_negative_index("tmpatt", "3", 3);
                matrix_d tmpatt(static_cast<Eigen::VectorXd::Index>(1),static_cast<Eigen::VectorXd::Index>(3));
                (void) tmpatt;  // dummy to suppress unused var warning

                stan::math::initialize(tmpatt, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(tmpatt,DUMMY_VAR__);
                validate_non_negative_index("tmpp", "4", 4);
                vector_d tmpp(static_cast<Eigen::VectorXd::Index>(4));
                (void) tmpp;  // dummy to suppress unused var warning

                stan::math::initialize(tmpp, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(tmpp,DUMMY_VAR__);


                stan::math::assign(subj_att, initAtt);
                stan::math::assign(pred_prob_mat, to_vector(multiply(subj_att,stan::model::rvalue(deck_match_rule, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "deck_match_rule"))));
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + multinomial_log(stan::model::rvalue(choice, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()))), "choice"),pred_prob_mat)));
                    stan::model::assign(y_pred, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()))), 
                                multinomial_rng(pred_prob_mat,1, base_rng__), 
                                "assigning variable y_pred");
                    if (as_bool(logical_eq(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),1))) {

                        stan::math::assign(att_signal, elt_multiply(subj_att,get_base1(get_base1(choice_match_att,i,"choice_match_att",1),t,"choice_match_att",2)));
                        stan::math::assign(att_signal, divide(att_signal,sum(att_signal)));
                        stan::math::assign(tmpatt, add(multiply((1.0 - get_base1(r,i,"r",1)),subj_att),multiply(get_base1(r,i,"r",1),att_signal)));
                    } else {

                        stan::math::assign(att_signal, elt_multiply(subj_att,subtract(unit,get_base1(get_base1(choice_match_att,i,"choice_match_att",1),t,"choice_match_att",2))));
                        stan::math::assign(att_signal, divide(att_signal,sum(att_signal)));
                        stan::math::assign(tmpatt, add(multiply((1.0 - get_base1(p,i,"p",1)),subj_att),multiply(get_base1(p,i,"p",1),att_signal)));
                    }
                    stan::math::assign(subj_att, add(multiply(divide(tmpatt,sum(tmpatt)),0.99980000000000002),0.0001));
                    stan::math::assign(get_base1_lhs(tmpatt,1,1,"tmpatt",1), pow(get_base1(subj_att,1,1,"subj_att",1),get_base1(d,i,"d",1)));
                    stan::math::assign(get_base1_lhs(tmpatt,1,2,"tmpatt",1), pow(get_base1(subj_att,1,2,"subj_att",1),get_base1(d,i,"d",1)));
                    stan::math::assign(get_base1_lhs(tmpatt,1,3,"tmpatt",1), pow(get_base1(subj_att,1,3,"subj_att",1),get_base1(d,i,"d",1)));
                    if (as_bool(logical_lt(t,get_base1(Tsubj,i,"Tsubj",1)))) {

                        stan::math::assign(tmpp, add(multiply(to_vector(multiply(tmpatt,stan::model::rvalue(deck_match_rule, stan::model::cons_list(stan::model::index_uni((t + 1)), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "deck_match_rule"))),0.99980000000000002),0.0001));
                        stan::math::assign(pred_prob_mat, divide(tmpp,sum(tmpp)));
                    }
                }
                }
            }

            // validate generated quantities
            check_greater_or_equal(function__,"mu_r",mu_r,0);
            check_less_or_equal(function__,"mu_r",mu_r,1);
            check_greater_or_equal(function__,"mu_p",mu_p,0);
            check_less_or_equal(function__,"mu_p",mu_p,5);
            check_greater_or_equal(function__,"mu_d",mu_d,0);
            check_less_or_equal(function__,"mu_d",mu_d,5);

            // write generated quantities
        vars__.push_back(mu_r);
        vars__.push_back(mu_p);
        vars__.push_back(mu_d);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < 4; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(y_pred[k_0__][k_1__][k_2__]);
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_wcs_sql";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "p_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "d_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "d" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_p";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_d";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= 4; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "p_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "d_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "d" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_p";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_d";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= 4; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }

}; // model

}




#endif
