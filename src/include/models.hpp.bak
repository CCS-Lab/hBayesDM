/*
    hBayesDM is distributed under the terms of the GNU General Public 
    License but without any warranty. See the GNU General Public 
    License for more details.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_bandit2arm_delta_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_bandit2arm_delta");
    reader.add_event(106, 106, "end", "model_bandit2arm_delta");
    return reader;
}

class model_bandit2arm_delta : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > outcome;
    vector_d initV;
public:
    model_bandit2arm_delta(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_bandit2arm_delta(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_bandit2arm_delta_namespace::model_bandit2arm_delta";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],2);
                }
            }
            current_statement_begin__ = 6;
            // initialize data variables
            current_statement_begin__ = 9;
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 10;
            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data
            current_statement_begin__ = 9;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 15;
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 16;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 19;
            validate_non_negative_index("A_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 20;
            validate_non_negative_index("tau_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_bandit2arm_delta() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("A_pr")))
            throw std::runtime_error("variable A_pr missing");
        vals_r__ = context__.vals_r("A_pr");
        pos__ = 0U;
        validate_non_negative_index("A_pr", "N", N);
        context__.validate_dims("initialization", "A_pr", "vector_d", context__.to_vec(N));
        vector_d A_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            A_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(A_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable A_pr: ") + e.what());
        }

        if (!(context__.contains_r("tau_pr")))
            throw std::runtime_error("variable tau_pr missing");
        vals_r__ = context__.vals_r("tau_pr");
        pos__ = 0U;
        validate_non_negative_index("tau_pr", "N", N);
        context__.validate_dims("initialization", "tau_pr", "vector_d", context__.to_vec(N));
        vector_d tau_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  A_pr;
            (void) A_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                A_pr = in__.vector_constrain(N,lp__);
            else
                A_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_pr;
            (void) tau_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_pr = in__.vector_constrain(N,lp__);
            else
                tau_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 24;
            validate_non_negative_index("A", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, DUMMY_VAR__);
            stan::math::fill(A,DUMMY_VAR__);
            current_statement_begin__ = 25;
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 27;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 28;
                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                current_statement_begin__ = 29;
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(A(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: A" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 24;
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            current_statement_begin__ = 25;
            check_greater_or_equal(function__,"tau",tau,0);
            check_less_or_equal(function__,"tau",tau,5);

            // model body

            current_statement_begin__ = 34;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 35;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 38;
            lp_accum__.add(normal_log<propto__>(A_pr, 0, 1));
            current_statement_begin__ = 39;
            lp_accum__.add(normal_log<propto__>(tau_pr, 0, 1));
            current_statement_begin__ = 42;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 43;
                validate_non_negative_index("ev", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 44;
                T__ PE;
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, DUMMY_VAR__);
                stan::math::fill(PE,DUMMY_VAR__);


                current_statement_begin__ = 46;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 48;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 50;
                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), multiply(get_base1(tau,i,"tau",1),ev)));
                    current_statement_begin__ = 53;
                    stan::math::assign(PE, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    current_statement_begin__ = 56;
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(A,i,"A",1) * PE)));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("A_pr");
        names__.push_back("tau_pr");
        names__.push_back("A");
        names__.push_back("tau");
        names__.push_back("mu_A");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_bandit2arm_delta_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d A_pr = in__.vector_constrain(N);
        vector_d tau_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 24;
            validate_non_negative_index("A", "N", N);
            vector_d A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(A,DUMMY_VAR__);
            current_statement_begin__ = 25;
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 27;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 28;
                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                current_statement_begin__ = 29;
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * 5));
            }

            // validate transformed parameters
            current_statement_begin__ = 24;
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            current_statement_begin__ = 25;
            check_greater_or_equal(function__,"tau",tau,0);
            check_less_or_equal(function__,"tau",tau,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 62;
            double mu_A(0.0);
            (void) mu_A;  // dummy to suppress unused var warning

            stan::math::initialize(mu_A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_A,DUMMY_VAR__);
            current_statement_begin__ = 63;
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            current_statement_begin__ = 66;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 69;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 72;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 73;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 74;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 78;
            stan::math::assign(mu_A, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 79;
            stan::math::assign(mu_tau, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 5));

            current_statement_begin__ = 82;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 83;
                validate_non_negative_index("ev", "2", 2);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 84;
                double PE(0.0);
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PE,DUMMY_VAR__);


                current_statement_begin__ = 87;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 89;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 91;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 93;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),multiply(get_base1(tau,i,"tau",1),ev))));
                    current_statement_begin__ = 96;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(multiply(get_base1(tau,i,"tau",1),ev)), base_rng__));
                    current_statement_begin__ = 99;
                    stan::math::assign(PE, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    current_statement_begin__ = 102;
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(A,i,"A",1) * PE)));
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 62;
            check_greater_or_equal(function__,"mu_A",mu_A,0);
            check_less_or_equal(function__,"mu_A",mu_A,1);
            current_statement_begin__ = 63;
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);
            check_less_or_equal(function__,"mu_tau",mu_tau,5);
            current_statement_begin__ = 66;
            current_statement_begin__ = 69;

            // write generated quantities
        vars__.push_back(mu_A);
        vars__.push_back(mu_tau);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_bandit2arm_delta";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_bandit4arm_4par_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_bandit4arm_4par");
    reader.add_event(173, 173, "end", "model_bandit4arm_4par");
    return reader;
}

class model_bandit4arm_4par : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > rew;
    vector<vector<double> > los;
    vector<vector<int> > choice;
    vector_d initV;
public:
    model_bandit4arm_4par(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_bandit4arm_4par(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_bandit4arm_4par_namespace::model_bandit4arm_4par";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 4;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 5;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("rew", "N", N);
            validate_non_negative_index("rew", "T", T);
            context__.validate_dims("data initialization", "rew", "double", context__.to_vec(N,T));
            validate_non_negative_index("rew", "N", N);
            validate_non_negative_index("rew", "T", T);
            rew = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("rew");
            pos__ = 0;
            size_t rew_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < rew_limit_1__; ++i_1__) {
                size_t rew_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < rew_limit_0__; ++i_0__) {
                    rew[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("los", "N", N);
            validate_non_negative_index("los", "T", T);
            context__.validate_dims("data initialization", "los", "double", context__.to_vec(N,T));
            validate_non_negative_index("los", "N", N);
            validate_non_negative_index("los", "T", T);
            los = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("los");
            pos__ = 0;
            size_t los_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < los_limit_1__; ++i_1__) {
                size_t los_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < los_limit_0__; ++i_0__) {
                    los[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 4;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 6;
            current_statement_begin__ = 7;
            current_statement_begin__ = 8;
            // initialize data variables
            current_statement_begin__ = 12;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 13;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 12;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 19;
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            current_statement_begin__ = 20;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            current_statement_begin__ = 23;
            validate_non_negative_index("Arew_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 24;
            validate_non_negative_index("Apun_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 25;
            validate_non_negative_index("R_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 26;
            validate_non_negative_index("P_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_bandit4arm_4par() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("Arew_pr")))
            throw std::runtime_error("variable Arew_pr missing");
        vals_r__ = context__.vals_r("Arew_pr");
        pos__ = 0U;
        validate_non_negative_index("Arew_pr", "N", N);
        context__.validate_dims("initialization", "Arew_pr", "vector_d", context__.to_vec(N));
        vector_d Arew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Arew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Arew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Arew_pr: ") + e.what());
        }

        if (!(context__.contains_r("Apun_pr")))
            throw std::runtime_error("variable Apun_pr missing");
        vals_r__ = context__.vals_r("Apun_pr");
        pos__ = 0U;
        validate_non_negative_index("Apun_pr", "N", N);
        context__.validate_dims("initialization", "Apun_pr", "vector_d", context__.to_vec(N));
        vector_d Apun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Apun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Apun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Apun_pr: ") + e.what());
        }

        if (!(context__.contains_r("R_pr")))
            throw std::runtime_error("variable R_pr missing");
        vals_r__ = context__.vals_r("R_pr");
        pos__ = 0U;
        validate_non_negative_index("R_pr", "N", N);
        context__.validate_dims("initialization", "R_pr", "vector_d", context__.to_vec(N));
        vector_d R_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            R_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(R_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable R_pr: ") + e.what());
        }

        if (!(context__.contains_r("P_pr")))
            throw std::runtime_error("variable P_pr missing");
        vals_r__ = context__.vals_r("P_pr");
        pos__ = 0U;
        validate_non_negative_index("P_pr", "N", N);
        context__.validate_dims("initialization", "P_pr", "vector_d", context__.to_vec(N));
        vector_d P_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            P_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(P_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable P_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew_pr;
            (void) Arew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Arew_pr = in__.vector_constrain(N,lp__);
            else
                Arew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun_pr;
            (void) Apun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Apun_pr = in__.vector_constrain(N,lp__);
            else
                Apun_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  R_pr;
            (void) R_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                R_pr = in__.vector_constrain(N,lp__);
            else
                R_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  P_pr;
            (void) P_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                P_pr = in__.vector_constrain(N,lp__);
            else
                P_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 31;
            validate_non_negative_index("Arew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, DUMMY_VAR__);
            stan::math::fill(Arew,DUMMY_VAR__);
            current_statement_begin__ = 32;
            validate_non_negative_index("Apun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, DUMMY_VAR__);
            stan::math::fill(Apun,DUMMY_VAR__);
            current_statement_begin__ = 33;
            validate_non_negative_index("R", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  R(static_cast<Eigen::VectorXd::Index>(N));
            (void) R;  // dummy to suppress unused var warning

            stan::math::initialize(R, DUMMY_VAR__);
            stan::math::fill(R,DUMMY_VAR__);
            current_statement_begin__ = 34;
            validate_non_negative_index("P", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  P(static_cast<Eigen::VectorXd::Index>(N));
            (void) P;  // dummy to suppress unused var warning

            stan::math::initialize(P, DUMMY_VAR__);
            stan::math::fill(P,DUMMY_VAR__);


            current_statement_begin__ = 36;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 37;
                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                current_statement_begin__ = 38;
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                current_statement_begin__ = 39;
                stan::math::assign(get_base1_lhs(R,i,"R",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(R_pr,i,"R_pr",1)))) * 30));
                current_statement_begin__ = 40;
                stan::math::assign(get_base1_lhs(P,i,"P",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(P_pr,i,"P_pr",1)))) * 30));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Arew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Arew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Apun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Apun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(R(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: R" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(P(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: P" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 31;
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            current_statement_begin__ = 32;
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            current_statement_begin__ = 33;
            check_greater_or_equal(function__,"R",R,0);
            current_statement_begin__ = 34;
            check_greater_or_equal(function__,"P",P,0);

            // model body

            current_statement_begin__ = 46;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 47;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 50;
            lp_accum__.add(normal_log<propto__>(Arew_pr, 0, 1.0));
            current_statement_begin__ = 51;
            lp_accum__.add(normal_log<propto__>(Apun_pr, 0, 1.0));
            current_statement_begin__ = 52;
            lp_accum__.add(normal_log<propto__>(R_pr, 0, 1.0));
            current_statement_begin__ = 53;
            lp_accum__.add(normal_log<propto__>(P_pr, 0, 1.0));
            current_statement_begin__ = 55;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 57;
                validate_non_negative_index("Qr", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  Qr(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qr;  // dummy to suppress unused var warning

                stan::math::initialize(Qr, DUMMY_VAR__);
                stan::math::fill(Qr,DUMMY_VAR__);
                current_statement_begin__ = 58;
                validate_non_negative_index("Qp", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  Qp(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qp;  // dummy to suppress unused var warning

                stan::math::initialize(Qp, DUMMY_VAR__);
                stan::math::fill(Qp,DUMMY_VAR__);
                current_statement_begin__ = 59;
                validate_non_negative_index("PEr_fic", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  PEr_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEr_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEr_fic, DUMMY_VAR__);
                stan::math::fill(PEr_fic,DUMMY_VAR__);
                current_statement_begin__ = 60;
                validate_non_negative_index("PEp_fic", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  PEp_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEp_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEp_fic, DUMMY_VAR__);
                stan::math::fill(PEp_fic,DUMMY_VAR__);
                current_statement_begin__ = 61;
                validate_non_negative_index("Qsum", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  Qsum(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qsum;  // dummy to suppress unused var warning

                stan::math::initialize(Qsum, DUMMY_VAR__);
                stan::math::fill(Qsum,DUMMY_VAR__);
                current_statement_begin__ = 63;
                T__ Qr_chosen;
                (void) Qr_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qr_chosen, DUMMY_VAR__);
                stan::math::fill(Qr_chosen,DUMMY_VAR__);
                current_statement_begin__ = 64;
                T__ Qp_chosen;
                (void) Qp_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qp_chosen, DUMMY_VAR__);
                stan::math::fill(Qp_chosen,DUMMY_VAR__);
                current_statement_begin__ = 65;
                T__ PEr;
                (void) PEr;  // dummy to suppress unused var warning

                stan::math::initialize(PEr, DUMMY_VAR__);
                stan::math::fill(PEr,DUMMY_VAR__);
                current_statement_begin__ = 66;
                T__ PEp;
                (void) PEp;  // dummy to suppress unused var warning

                stan::math::initialize(PEp, DUMMY_VAR__);
                stan::math::fill(PEp,DUMMY_VAR__);


                current_statement_begin__ = 69;
                stan::math::assign(Qr, initV);
                current_statement_begin__ = 70;
                stan::math::assign(Qp, initV);
                current_statement_begin__ = 71;
                stan::math::assign(Qsum, initV);
                current_statement_begin__ = 73;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 75;
                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), Qsum));
                    current_statement_begin__ = 78;
                    stan::math::assign(PEr, ((get_base1(R,i,"R",1) * get_base1(get_base1(rew,i,"rew",1),t,"rew",2)) - get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1)));
                    current_statement_begin__ = 79;
                    stan::math::assign(PEp, ((get_base1(P,i,"P",1) * get_base1(get_base1(los,i,"los",1),t,"los",2)) - get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1)));
                    current_statement_begin__ = 80;
                    stan::math::assign(PEr_fic, minus(Qr));
                    current_statement_begin__ = 81;
                    stan::math::assign(PEp_fic, minus(Qp));
                    current_statement_begin__ = 84;
                    stan::math::assign(Qr_chosen, get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1));
                    current_statement_begin__ = 85;
                    stan::math::assign(Qp_chosen, get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1));
                    current_statement_begin__ = 88;
                    stan::math::assign(Qr, add(Qr,multiply(get_base1(Arew,i,"Arew",1),PEr_fic)));
                    current_statement_begin__ = 89;
                    stan::math::assign(Qp, add(Qp,multiply(get_base1(Apun,i,"Apun",1),PEp_fic)));
                    current_statement_begin__ = 91;
                    stan::math::assign(get_base1_lhs(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1), (Qr_chosen + (get_base1(Arew,i,"Arew",1) * PEr)));
                    current_statement_begin__ = 92;
                    stan::math::assign(get_base1_lhs(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1), (Qp_chosen + (get_base1(Apun,i,"Apun",1) * PEp)));
                    current_statement_begin__ = 95;
                    stan::math::assign(Qsum, add(Qr,Qp));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("Arew_pr");
        names__.push_back("Apun_pr");
        names__.push_back("R_pr");
        names__.push_back("P_pr");
        names__.push_back("Arew");
        names__.push_back("Apun");
        names__.push_back("R");
        names__.push_back("P");
        names__.push_back("mu_Arew");
        names__.push_back("mu_Apun");
        names__.push_back("mu_R");
        names__.push_back("mu_P");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_bandit4arm_4par_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d Arew_pr = in__.vector_constrain(N);
        vector_d Apun_pr = in__.vector_constrain(N);
        vector_d R_pr = in__.vector_constrain(N);
        vector_d P_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(R_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(P_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 31;
            validate_non_negative_index("Arew", "N", N);
            vector_d Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Arew,DUMMY_VAR__);
            current_statement_begin__ = 32;
            validate_non_negative_index("Apun", "N", N);
            vector_d Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Apun,DUMMY_VAR__);
            current_statement_begin__ = 33;
            validate_non_negative_index("R", "N", N);
            vector_d R(static_cast<Eigen::VectorXd::Index>(N));
            (void) R;  // dummy to suppress unused var warning

            stan::math::initialize(R, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(R,DUMMY_VAR__);
            current_statement_begin__ = 34;
            validate_non_negative_index("P", "N", N);
            vector_d P(static_cast<Eigen::VectorXd::Index>(N));
            (void) P;  // dummy to suppress unused var warning

            stan::math::initialize(P, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(P,DUMMY_VAR__);


            current_statement_begin__ = 36;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 37;
                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                current_statement_begin__ = 38;
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                current_statement_begin__ = 39;
                stan::math::assign(get_base1_lhs(R,i,"R",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(R_pr,i,"R_pr",1)))) * 30));
                current_statement_begin__ = 40;
                stan::math::assign(get_base1_lhs(P,i,"P",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(P_pr,i,"P_pr",1)))) * 30));
            }

            // validate transformed parameters
            current_statement_begin__ = 31;
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            current_statement_begin__ = 32;
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            current_statement_begin__ = 33;
            check_greater_or_equal(function__,"R",R,0);
            current_statement_begin__ = 34;
            check_greater_or_equal(function__,"P",P,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(R[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(P[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 101;
            double mu_Arew(0.0);
            (void) mu_Arew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Arew,DUMMY_VAR__);
            current_statement_begin__ = 102;
            double mu_Apun(0.0);
            (void) mu_Apun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Apun,DUMMY_VAR__);
            current_statement_begin__ = 103;
            double mu_R(0.0);
            (void) mu_R;  // dummy to suppress unused var warning

            stan::math::initialize(mu_R, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_R,DUMMY_VAR__);
            current_statement_begin__ = 104;
            double mu_P(0.0);
            (void) mu_P;  // dummy to suppress unused var warning

            stan::math::initialize(mu_P, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_P,DUMMY_VAR__);
            current_statement_begin__ = 107;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 110;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 113;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 114;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 115;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 119;
            stan::math::assign(mu_Arew, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 120;
            stan::math::assign(mu_Apun, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 121;
            stan::math::assign(mu_R, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 30));
            current_statement_begin__ = 122;
            stan::math::assign(mu_P, (Phi_approx(get_base1(mu_p,4,"mu_p",1)) * 30));

            current_statement_begin__ = 125;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 127;
                validate_non_negative_index("Qr", "4", 4);
                vector_d Qr(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qr;  // dummy to suppress unused var warning

                stan::math::initialize(Qr, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qr,DUMMY_VAR__);
                current_statement_begin__ = 128;
                validate_non_negative_index("Qp", "4", 4);
                vector_d Qp(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qp;  // dummy to suppress unused var warning

                stan::math::initialize(Qp, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qp,DUMMY_VAR__);
                current_statement_begin__ = 129;
                validate_non_negative_index("PEr_fic", "4", 4);
                vector_d PEr_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEr_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEr_fic, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEr_fic,DUMMY_VAR__);
                current_statement_begin__ = 130;
                validate_non_negative_index("PEp_fic", "4", 4);
                vector_d PEp_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEp_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEp_fic, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEp_fic,DUMMY_VAR__);
                current_statement_begin__ = 131;
                validate_non_negative_index("Qsum", "4", 4);
                vector_d Qsum(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qsum;  // dummy to suppress unused var warning

                stan::math::initialize(Qsum, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qsum,DUMMY_VAR__);
                current_statement_begin__ = 133;
                double Qr_chosen(0.0);
                (void) Qr_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qr_chosen, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qr_chosen,DUMMY_VAR__);
                current_statement_begin__ = 134;
                double Qp_chosen(0.0);
                (void) Qp_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qp_chosen, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qp_chosen,DUMMY_VAR__);
                current_statement_begin__ = 135;
                double PEr(0.0);
                (void) PEr;  // dummy to suppress unused var warning

                stan::math::initialize(PEr, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEr,DUMMY_VAR__);
                current_statement_begin__ = 136;
                double PEp(0.0);
                (void) PEp;  // dummy to suppress unused var warning

                stan::math::initialize(PEp, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEp,DUMMY_VAR__);


                current_statement_begin__ = 139;
                stan::math::assign(Qr, initV);
                current_statement_begin__ = 140;
                stan::math::assign(Qp, initV);
                current_statement_begin__ = 141;
                stan::math::assign(Qsum, initV);
                current_statement_begin__ = 142;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0.0);
                current_statement_begin__ = 144;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 146;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),Qsum)));
                    current_statement_begin__ = 149;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(Qsum), base_rng__));
                    current_statement_begin__ = 152;
                    stan::math::assign(PEr, ((get_base1(R,i,"R",1) * get_base1(get_base1(rew,i,"rew",1),t,"rew",2)) - get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1)));
                    current_statement_begin__ = 153;
                    stan::math::assign(PEp, ((get_base1(P,i,"P",1) * get_base1(get_base1(los,i,"los",1),t,"los",2)) - get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1)));
                    current_statement_begin__ = 154;
                    stan::math::assign(PEr_fic, minus(Qr));
                    current_statement_begin__ = 155;
                    stan::math::assign(PEp_fic, minus(Qp));
                    current_statement_begin__ = 158;
                    stan::math::assign(Qr_chosen, get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1));
                    current_statement_begin__ = 159;
                    stan::math::assign(Qp_chosen, get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1));
                    current_statement_begin__ = 162;
                    stan::math::assign(Qr, add(Qr,multiply(get_base1(Arew,i,"Arew",1),PEr_fic)));
                    current_statement_begin__ = 163;
                    stan::math::assign(Qp, add(Qp,multiply(get_base1(Apun,i,"Apun",1),PEp_fic)));
                    current_statement_begin__ = 165;
                    stan::math::assign(get_base1_lhs(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1), (Qr_chosen + (get_base1(Arew,i,"Arew",1) * PEr)));
                    current_statement_begin__ = 166;
                    stan::math::assign(get_base1_lhs(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1), (Qp_chosen + (get_base1(Apun,i,"Apun",1) * PEp)));
                    current_statement_begin__ = 169;
                    stan::math::assign(Qsum, add(Qr,Qp));
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 101;
            check_greater_or_equal(function__,"mu_Arew",mu_Arew,0);
            check_less_or_equal(function__,"mu_Arew",mu_Arew,1);
            current_statement_begin__ = 102;
            check_greater_or_equal(function__,"mu_Apun",mu_Apun,0);
            check_less_or_equal(function__,"mu_Apun",mu_Apun,1);
            current_statement_begin__ = 103;
            check_greater_or_equal(function__,"mu_R",mu_R,0);
            current_statement_begin__ = 104;
            check_greater_or_equal(function__,"mu_P",mu_P,0);
            current_statement_begin__ = 107;
            current_statement_begin__ = 110;

            // write generated quantities
        vars__.push_back(mu_Arew);
        vars__.push_back(mu_Apun);
        vars__.push_back(mu_R);
        vars__.push_back(mu_P);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_bandit4arm_4par";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_R";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_P";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_R";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_P";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_bandit4arm_lapse_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_bandit4arm_lapse");
    reader.add_event(179, 179, "end", "model_bandit4arm_lapse");
    return reader;
}

class model_bandit4arm_lapse : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > rew;
    vector<vector<double> > los;
    vector<vector<int> > choice;
    vector_d initV;
public:
    model_bandit4arm_lapse(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_bandit4arm_lapse(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_bandit4arm_lapse_namespace::model_bandit4arm_lapse";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 4;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 5;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("rew", "N", N);
            validate_non_negative_index("rew", "T", T);
            context__.validate_dims("data initialization", "rew", "double", context__.to_vec(N,T));
            validate_non_negative_index("rew", "N", N);
            validate_non_negative_index("rew", "T", T);
            rew = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("rew");
            pos__ = 0;
            size_t rew_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < rew_limit_1__; ++i_1__) {
                size_t rew_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < rew_limit_0__; ++i_0__) {
                    rew[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("los", "N", N);
            validate_non_negative_index("los", "T", T);
            context__.validate_dims("data initialization", "los", "double", context__.to_vec(N,T));
            validate_non_negative_index("los", "N", N);
            validate_non_negative_index("los", "T", T);
            los = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("los");
            pos__ = 0;
            size_t los_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < los_limit_1__; ++i_1__) {
                size_t los_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < los_limit_0__; ++i_0__) {
                    los[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 4;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 6;
            current_statement_begin__ = 7;
            current_statement_begin__ = 8;
            // initialize data variables
            current_statement_begin__ = 12;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 13;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 12;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 19;
            validate_non_negative_index("mu_p", "5", 5);
            num_params_r__ += 5;
            current_statement_begin__ = 20;
            validate_non_negative_index("sigma", "5", 5);
            num_params_r__ += 5;
            current_statement_begin__ = 23;
            validate_non_negative_index("Arew_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 24;
            validate_non_negative_index("Apun_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 25;
            validate_non_negative_index("R_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 26;
            validate_non_negative_index("P_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 27;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_bandit4arm_lapse() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "5", 5);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(5));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "5", 5);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(5));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("Arew_pr")))
            throw std::runtime_error("variable Arew_pr missing");
        vals_r__ = context__.vals_r("Arew_pr");
        pos__ = 0U;
        validate_non_negative_index("Arew_pr", "N", N);
        context__.validate_dims("initialization", "Arew_pr", "vector_d", context__.to_vec(N));
        vector_d Arew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Arew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Arew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Arew_pr: ") + e.what());
        }

        if (!(context__.contains_r("Apun_pr")))
            throw std::runtime_error("variable Apun_pr missing");
        vals_r__ = context__.vals_r("Apun_pr");
        pos__ = 0U;
        validate_non_negative_index("Apun_pr", "N", N);
        context__.validate_dims("initialization", "Apun_pr", "vector_d", context__.to_vec(N));
        vector_d Apun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Apun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Apun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Apun_pr: ") + e.what());
        }

        if (!(context__.contains_r("R_pr")))
            throw std::runtime_error("variable R_pr missing");
        vals_r__ = context__.vals_r("R_pr");
        pos__ = 0U;
        validate_non_negative_index("R_pr", "N", N);
        context__.validate_dims("initialization", "R_pr", "vector_d", context__.to_vec(N));
        vector_d R_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            R_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(R_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable R_pr: ") + e.what());
        }

        if (!(context__.contains_r("P_pr")))
            throw std::runtime_error("variable P_pr missing");
        vals_r__ = context__.vals_r("P_pr");
        pos__ = 0U;
        validate_non_negative_index("P_pr", "N", N);
        context__.validate_dims("initialization", "P_pr", "vector_d", context__.to_vec(N));
        vector_d P_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            P_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(P_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable P_pr: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(5,lp__);
            else
                mu_p = in__.vector_constrain(5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,5,lp__);
            else
                sigma = in__.vector_lb_constrain(0,5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew_pr;
            (void) Arew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Arew_pr = in__.vector_constrain(N,lp__);
            else
                Arew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun_pr;
            (void) Apun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Apun_pr = in__.vector_constrain(N,lp__);
            else
                Apun_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  R_pr;
            (void) R_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                R_pr = in__.vector_constrain(N,lp__);
            else
                R_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  P_pr;
            (void) P_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                P_pr = in__.vector_constrain(N,lp__);
            else
                P_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 32;
            validate_non_negative_index("Arew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, DUMMY_VAR__);
            stan::math::fill(Arew,DUMMY_VAR__);
            current_statement_begin__ = 33;
            validate_non_negative_index("Apun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, DUMMY_VAR__);
            stan::math::fill(Apun,DUMMY_VAR__);
            current_statement_begin__ = 34;
            validate_non_negative_index("R", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  R(static_cast<Eigen::VectorXd::Index>(N));
            (void) R;  // dummy to suppress unused var warning

            stan::math::initialize(R, DUMMY_VAR__);
            stan::math::fill(R,DUMMY_VAR__);
            current_statement_begin__ = 35;
            validate_non_negative_index("P", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  P(static_cast<Eigen::VectorXd::Index>(N));
            (void) P;  // dummy to suppress unused var warning

            stan::math::initialize(P, DUMMY_VAR__);
            stan::math::fill(P,DUMMY_VAR__);
            current_statement_begin__ = 36;
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);


            current_statement_begin__ = 38;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 39;
                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                current_statement_begin__ = 40;
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                current_statement_begin__ = 41;
                stan::math::assign(get_base1_lhs(R,i,"R",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(R_pr,i,"R_pr",1)))) * 30));
                current_statement_begin__ = 42;
                stan::math::assign(get_base1_lhs(P,i,"P",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(P_pr,i,"P_pr",1)))) * 30));
                current_statement_begin__ = 43;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,5,"mu_p",1) + (get_base1(sigma,5,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Arew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Arew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Apun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Apun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(R(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: R" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(P(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: P" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 32;
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            current_statement_begin__ = 33;
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            current_statement_begin__ = 34;
            check_greater_or_equal(function__,"R",R,0);
            current_statement_begin__ = 35;
            check_greater_or_equal(function__,"P",P,0);
            current_statement_begin__ = 36;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);

            // model body

            current_statement_begin__ = 49;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 50;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 53;
            lp_accum__.add(normal_log<propto__>(Arew_pr, 0, 1.0));
            current_statement_begin__ = 54;
            lp_accum__.add(normal_log<propto__>(Apun_pr, 0, 1.0));
            current_statement_begin__ = 55;
            lp_accum__.add(normal_log<propto__>(R_pr, 0, 1.0));
            current_statement_begin__ = 56;
            lp_accum__.add(normal_log<propto__>(P_pr, 0, 1.0));
            current_statement_begin__ = 57;
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            current_statement_begin__ = 59;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 61;
                validate_non_negative_index("Qr", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  Qr(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qr;  // dummy to suppress unused var warning

                stan::math::initialize(Qr, DUMMY_VAR__);
                stan::math::fill(Qr,DUMMY_VAR__);
                current_statement_begin__ = 62;
                validate_non_negative_index("Qp", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  Qp(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qp;  // dummy to suppress unused var warning

                stan::math::initialize(Qp, DUMMY_VAR__);
                stan::math::fill(Qp,DUMMY_VAR__);
                current_statement_begin__ = 63;
                validate_non_negative_index("PEr_fic", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  PEr_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEr_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEr_fic, DUMMY_VAR__);
                stan::math::fill(PEr_fic,DUMMY_VAR__);
                current_statement_begin__ = 64;
                validate_non_negative_index("PEp_fic", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  PEp_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEp_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEp_fic, DUMMY_VAR__);
                stan::math::fill(PEp_fic,DUMMY_VAR__);
                current_statement_begin__ = 65;
                validate_non_negative_index("Qsum", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  Qsum(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qsum;  // dummy to suppress unused var warning

                stan::math::initialize(Qsum, DUMMY_VAR__);
                stan::math::fill(Qsum,DUMMY_VAR__);
                current_statement_begin__ = 67;
                T__ Qr_chosen;
                (void) Qr_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qr_chosen, DUMMY_VAR__);
                stan::math::fill(Qr_chosen,DUMMY_VAR__);
                current_statement_begin__ = 68;
                T__ Qp_chosen;
                (void) Qp_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qp_chosen, DUMMY_VAR__);
                stan::math::fill(Qp_chosen,DUMMY_VAR__);
                current_statement_begin__ = 69;
                T__ PEr;
                (void) PEr;  // dummy to suppress unused var warning

                stan::math::initialize(PEr, DUMMY_VAR__);
                stan::math::fill(PEr,DUMMY_VAR__);
                current_statement_begin__ = 70;
                T__ PEp;
                (void) PEp;  // dummy to suppress unused var warning

                stan::math::initialize(PEp, DUMMY_VAR__);
                stan::math::fill(PEp,DUMMY_VAR__);


                current_statement_begin__ = 73;
                stan::math::assign(Qr, initV);
                current_statement_begin__ = 74;
                stan::math::assign(Qp, initV);
                current_statement_begin__ = 75;
                stan::math::assign(Qsum, initV);
                current_statement_begin__ = 77;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 79;
                    lp_accum__.add(categorical_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), add(multiply(softmax(Qsum),(1 - get_base1(xi,i,"xi",1))),(get_base1(xi,i,"xi",1) / 4))));
                    current_statement_begin__ = 82;
                    stan::math::assign(PEr, ((get_base1(R,i,"R",1) * get_base1(get_base1(rew,i,"rew",1),t,"rew",2)) - get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1)));
                    current_statement_begin__ = 83;
                    stan::math::assign(PEp, ((get_base1(P,i,"P",1) * get_base1(get_base1(los,i,"los",1),t,"los",2)) - get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1)));
                    current_statement_begin__ = 84;
                    stan::math::assign(PEr_fic, minus(Qr));
                    current_statement_begin__ = 85;
                    stan::math::assign(PEp_fic, minus(Qp));
                    current_statement_begin__ = 88;
                    stan::math::assign(Qr_chosen, get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1));
                    current_statement_begin__ = 89;
                    stan::math::assign(Qp_chosen, get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1));
                    current_statement_begin__ = 92;
                    stan::math::assign(Qr, add(Qr,multiply(get_base1(Arew,i,"Arew",1),PEr_fic)));
                    current_statement_begin__ = 93;
                    stan::math::assign(Qp, add(Qp,multiply(get_base1(Apun,i,"Apun",1),PEp_fic)));
                    current_statement_begin__ = 95;
                    stan::math::assign(get_base1_lhs(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1), (Qr_chosen + (get_base1(Arew,i,"Arew",1) * PEr)));
                    current_statement_begin__ = 96;
                    stan::math::assign(get_base1_lhs(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1), (Qp_chosen + (get_base1(Apun,i,"Apun",1) * PEp)));
                    current_statement_begin__ = 99;
                    stan::math::assign(Qsum, add(Qr,Qp));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("Arew_pr");
        names__.push_back("Apun_pr");
        names__.push_back("R_pr");
        names__.push_back("P_pr");
        names__.push_back("xi_pr");
        names__.push_back("Arew");
        names__.push_back("Apun");
        names__.push_back("R");
        names__.push_back("P");
        names__.push_back("xi");
        names__.push_back("mu_Arew");
        names__.push_back("mu_Apun");
        names__.push_back("mu_R");
        names__.push_back("mu_P");
        names__.push_back("mu_xi");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_bandit4arm_lapse_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(5);
        vector_d sigma = in__.vector_lb_constrain(0,5);
        vector_d Arew_pr = in__.vector_constrain(N);
        vector_d Apun_pr = in__.vector_constrain(N);
        vector_d R_pr = in__.vector_constrain(N);
        vector_d P_pr = in__.vector_constrain(N);
        vector_d xi_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(R_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(P_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 32;
            validate_non_negative_index("Arew", "N", N);
            vector_d Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Arew,DUMMY_VAR__);
            current_statement_begin__ = 33;
            validate_non_negative_index("Apun", "N", N);
            vector_d Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Apun,DUMMY_VAR__);
            current_statement_begin__ = 34;
            validate_non_negative_index("R", "N", N);
            vector_d R(static_cast<Eigen::VectorXd::Index>(N));
            (void) R;  // dummy to suppress unused var warning

            stan::math::initialize(R, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(R,DUMMY_VAR__);
            current_statement_begin__ = 35;
            validate_non_negative_index("P", "N", N);
            vector_d P(static_cast<Eigen::VectorXd::Index>(N));
            (void) P;  // dummy to suppress unused var warning

            stan::math::initialize(P, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(P,DUMMY_VAR__);
            current_statement_begin__ = 36;
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);


            current_statement_begin__ = 38;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 39;
                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                current_statement_begin__ = 40;
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                current_statement_begin__ = 41;
                stan::math::assign(get_base1_lhs(R,i,"R",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(R_pr,i,"R_pr",1)))) * 30));
                current_statement_begin__ = 42;
                stan::math::assign(get_base1_lhs(P,i,"P",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(P_pr,i,"P_pr",1)))) * 30));
                current_statement_begin__ = 43;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,5,"mu_p",1) + (get_base1(sigma,5,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
            }

            // validate transformed parameters
            current_statement_begin__ = 32;
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            current_statement_begin__ = 33;
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            current_statement_begin__ = 34;
            check_greater_or_equal(function__,"R",R,0);
            current_statement_begin__ = 35;
            check_greater_or_equal(function__,"P",P,0);
            current_statement_begin__ = 36;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(R[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(P[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 105;
            double mu_Arew(0.0);
            (void) mu_Arew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Arew,DUMMY_VAR__);
            current_statement_begin__ = 106;
            double mu_Apun(0.0);
            (void) mu_Apun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Apun,DUMMY_VAR__);
            current_statement_begin__ = 107;
            double mu_R(0.0);
            (void) mu_R;  // dummy to suppress unused var warning

            stan::math::initialize(mu_R, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_R,DUMMY_VAR__);
            current_statement_begin__ = 108;
            double mu_P(0.0);
            (void) mu_P;  // dummy to suppress unused var warning

            stan::math::initialize(mu_P, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_P,DUMMY_VAR__);
            current_statement_begin__ = 109;
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            current_statement_begin__ = 112;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 115;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 118;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 119;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 120;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 124;
            stan::math::assign(mu_Arew, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 125;
            stan::math::assign(mu_Apun, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 126;
            stan::math::assign(mu_R, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 30));
            current_statement_begin__ = 127;
            stan::math::assign(mu_P, (Phi_approx(get_base1(mu_p,4,"mu_p",1)) * 30));
            current_statement_begin__ = 128;
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,5,"mu_p",1)));

            current_statement_begin__ = 131;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 133;
                validate_non_negative_index("Qr", "4", 4);
                vector_d Qr(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qr;  // dummy to suppress unused var warning

                stan::math::initialize(Qr, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qr,DUMMY_VAR__);
                current_statement_begin__ = 134;
                validate_non_negative_index("Qp", "4", 4);
                vector_d Qp(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qp;  // dummy to suppress unused var warning

                stan::math::initialize(Qp, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qp,DUMMY_VAR__);
                current_statement_begin__ = 135;
                validate_non_negative_index("PEr_fic", "4", 4);
                vector_d PEr_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEr_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEr_fic, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEr_fic,DUMMY_VAR__);
                current_statement_begin__ = 136;
                validate_non_negative_index("PEp_fic", "4", 4);
                vector_d PEp_fic(static_cast<Eigen::VectorXd::Index>(4));
                (void) PEp_fic;  // dummy to suppress unused var warning

                stan::math::initialize(PEp_fic, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEp_fic,DUMMY_VAR__);
                current_statement_begin__ = 137;
                validate_non_negative_index("Qsum", "4", 4);
                vector_d Qsum(static_cast<Eigen::VectorXd::Index>(4));
                (void) Qsum;  // dummy to suppress unused var warning

                stan::math::initialize(Qsum, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qsum,DUMMY_VAR__);
                current_statement_begin__ = 139;
                double Qr_chosen(0.0);
                (void) Qr_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qr_chosen, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qr_chosen,DUMMY_VAR__);
                current_statement_begin__ = 140;
                double Qp_chosen(0.0);
                (void) Qp_chosen;  // dummy to suppress unused var warning

                stan::math::initialize(Qp_chosen, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(Qp_chosen,DUMMY_VAR__);
                current_statement_begin__ = 141;
                double PEr(0.0);
                (void) PEr;  // dummy to suppress unused var warning

                stan::math::initialize(PEr, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEr,DUMMY_VAR__);
                current_statement_begin__ = 142;
                double PEp(0.0);
                (void) PEp;  // dummy to suppress unused var warning

                stan::math::initialize(PEp, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEp,DUMMY_VAR__);


                current_statement_begin__ = 145;
                stan::math::assign(Qr, initV);
                current_statement_begin__ = 146;
                stan::math::assign(Qp, initV);
                current_statement_begin__ = 147;
                stan::math::assign(Qsum, initV);
                current_statement_begin__ = 148;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0.0);
                current_statement_begin__ = 150;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 152;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),add(multiply(softmax(Qsum),(1 - get_base1(xi,i,"xi",1))),(get_base1(xi,i,"xi",1) / 4)))));
                    current_statement_begin__ = 155;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(add(multiply(softmax(Qsum),(1 - get_base1(xi,i,"xi",1))),(get_base1(xi,i,"xi",1) / 4)), base_rng__));
                    current_statement_begin__ = 158;
                    stan::math::assign(PEr, ((get_base1(R,i,"R",1) * get_base1(get_base1(rew,i,"rew",1),t,"rew",2)) - get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1)));
                    current_statement_begin__ = 159;
                    stan::math::assign(PEp, ((get_base1(P,i,"P",1) * get_base1(get_base1(los,i,"los",1),t,"los",2)) - get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1)));
                    current_statement_begin__ = 160;
                    stan::math::assign(PEr_fic, minus(Qr));
                    current_statement_begin__ = 161;
                    stan::math::assign(PEp_fic, minus(Qp));
                    current_statement_begin__ = 164;
                    stan::math::assign(Qr_chosen, get_base1(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1));
                    current_statement_begin__ = 165;
                    stan::math::assign(Qp_chosen, get_base1(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1));
                    current_statement_begin__ = 168;
                    stan::math::assign(Qr, add(Qr,multiply(get_base1(Arew,i,"Arew",1),PEr_fic)));
                    current_statement_begin__ = 169;
                    stan::math::assign(Qp, add(Qp,multiply(get_base1(Apun,i,"Apun",1),PEp_fic)));
                    current_statement_begin__ = 171;
                    stan::math::assign(get_base1_lhs(Qr,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qr",1), (Qr_chosen + (get_base1(Arew,i,"Arew",1) * PEr)));
                    current_statement_begin__ = 172;
                    stan::math::assign(get_base1_lhs(Qp,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"Qp",1), (Qp_chosen + (get_base1(Apun,i,"Apun",1) * PEp)));
                    current_statement_begin__ = 175;
                    stan::math::assign(Qsum, add(Qr,Qp));
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 105;
            check_greater_or_equal(function__,"mu_Arew",mu_Arew,0);
            check_less_or_equal(function__,"mu_Arew",mu_Arew,1);
            current_statement_begin__ = 106;
            check_greater_or_equal(function__,"mu_Apun",mu_Apun,0);
            check_less_or_equal(function__,"mu_Apun",mu_Apun,1);
            current_statement_begin__ = 107;
            check_greater_or_equal(function__,"mu_R",mu_R,0);
            current_statement_begin__ = 108;
            check_greater_or_equal(function__,"mu_P",mu_P,0);
            current_statement_begin__ = 109;
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            current_statement_begin__ = 112;
            current_statement_begin__ = 115;

            // write generated quantities
        vars__.push_back(mu_Arew);
        vars__.push_back(mu_Apun);
        vars__.push_back(mu_R);
        vars__.push_back(mu_P);
        vars__.push_back(mu_xi);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_bandit4arm_lapse";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_R";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_P";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "P" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_R";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_P";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_choiceRT_ddm_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_choiceRT_ddm");
    reader.add_event(95, 95, "end", "model_choiceRT_ddm");
    return reader;
}

class model_choiceRT_ddm : public prob_grad {
private:
    int N;
    int Nu_max;
    int Nl_max;
    vector<int> Nu;
    vector<int> Nl;
    vector<vector<double> > RTu;
    vector<vector<double> > RTl;
    vector<double> minRT;
    double RTbound;
public:
    model_choiceRT_ddm(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_choiceRT_ddm(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_choiceRT_ddm_namespace::model_choiceRT_ddm";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 4;
            context__.validate_dims("data initialization", "Nu_max", "int", context__.to_vec());
            Nu_max = int(0);
            vals_i__ = context__.vals_i("Nu_max");
            pos__ = 0;
            Nu_max = vals_i__[pos__++];
            current_statement_begin__ = 5;
            context__.validate_dims("data initialization", "Nl_max", "int", context__.to_vec());
            Nl_max = int(0);
            vals_i__ = context__.vals_i("Nl_max");
            pos__ = 0;
            Nl_max = vals_i__[pos__++];
            current_statement_begin__ = 6;
            validate_non_negative_index("Nu", "N", N);
            context__.validate_dims("data initialization", "Nu", "int", context__.to_vec(N));
            validate_non_negative_index("Nu", "N", N);
            Nu = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Nu");
            pos__ = 0;
            size_t Nu_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Nu_limit_0__; ++i_0__) {
                Nu[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("Nl", "N", N);
            context__.validate_dims("data initialization", "Nl", "int", context__.to_vec(N));
            validate_non_negative_index("Nl", "N", N);
            Nl = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Nl");
            pos__ = 0;
            size_t Nl_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Nl_limit_0__; ++i_0__) {
                Nl[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("RTu", "N", N);
            validate_non_negative_index("RTu", "Nu_max", Nu_max);
            context__.validate_dims("data initialization", "RTu", "double", context__.to_vec(N,Nu_max));
            validate_non_negative_index("RTu", "N", N);
            validate_non_negative_index("RTu", "Nu_max", Nu_max);
            RTu = std::vector<std::vector<double> >(N,std::vector<double>(Nu_max,double(0)));
            vals_r__ = context__.vals_r("RTu");
            pos__ = 0;
            size_t RTu_limit_1__ = Nu_max;
            for (size_t i_1__ = 0; i_1__ < RTu_limit_1__; ++i_1__) {
                size_t RTu_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < RTu_limit_0__; ++i_0__) {
                    RTu[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 9;
            validate_non_negative_index("RTl", "N", N);
            validate_non_negative_index("RTl", "Nl_max", Nl_max);
            context__.validate_dims("data initialization", "RTl", "double", context__.to_vec(N,Nl_max));
            validate_non_negative_index("RTl", "N", N);
            validate_non_negative_index("RTl", "Nl_max", Nl_max);
            RTl = std::vector<std::vector<double> >(N,std::vector<double>(Nl_max,double(0)));
            vals_r__ = context__.vals_r("RTl");
            pos__ = 0;
            size_t RTl_limit_1__ = Nl_max;
            for (size_t i_1__ = 0; i_1__ < RTl_limit_1__; ++i_1__) {
                size_t RTl_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < RTl_limit_0__; ++i_0__) {
                    RTl[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 10;
            validate_non_negative_index("minRT", "N", N);
            context__.validate_dims("data initialization", "minRT", "double", context__.to_vec(N));
            validate_non_negative_index("minRT", "N", N);
            minRT = std::vector<double>(N,double(0));
            vals_r__ = context__.vals_r("minRT");
            pos__ = 0;
            size_t minRT_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < minRT_limit_0__; ++i_0__) {
                minRT[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 11;
            context__.validate_dims("data initialization", "RTbound", "double", context__.to_vec());
            RTbound = double(0);
            vals_r__ = context__.vals_r("RTbound");
            pos__ = 0;
            RTbound = vals_r__[pos__++];

            // validate, data variables
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 4;
            check_greater_or_equal(function__,"Nu_max",Nu_max,0);
            current_statement_begin__ = 5;
            check_greater_or_equal(function__,"Nl_max",Nl_max,0);
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Nu[k0__]",Nu[k0__],0);
            }
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Nl[k0__]",Nl[k0__],0);
            }
            current_statement_begin__ = 8;
            current_statement_begin__ = 9;
            current_statement_begin__ = 10;
            current_statement_begin__ = 11;
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 27;
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            current_statement_begin__ = 28;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            current_statement_begin__ = 31;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 32;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 33;
            validate_non_negative_index("delta_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 34;
            validate_non_negative_index("tau_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_choiceRT_ddm() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        if (!(context__.contains_r("delta_pr")))
            throw std::runtime_error("variable delta_pr missing");
        vals_r__ = context__.vals_r("delta_pr");
        pos__ = 0U;
        validate_non_negative_index("delta_pr", "N", N);
        context__.validate_dims("initialization", "delta_pr", "vector_d", context__.to_vec(N));
        vector_d delta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            delta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(delta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable delta_pr: ") + e.what());
        }

        if (!(context__.contains_r("tau_pr")))
            throw std::runtime_error("variable tau_pr missing");
        vals_r__ = context__.vals_r("tau_pr");
        pos__ = 0U;
        validate_non_negative_index("tau_pr", "N", N);
        context__.validate_dims("initialization", "tau_pr", "vector_d", context__.to_vec(N));
        vector_d tau_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  delta_pr;
            (void) delta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                delta_pr = in__.vector_constrain(N,lp__);
            else
                delta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_pr;
            (void) tau_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_pr = in__.vector_constrain(N,lp__);
            else
                tau_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 39;
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            current_statement_begin__ = 40;
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);
            current_statement_begin__ = 41;
            validate_non_negative_index("delta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  delta(static_cast<Eigen::VectorXd::Index>(N));
            (void) delta;  // dummy to suppress unused var warning

            stan::math::initialize(delta, DUMMY_VAR__);
            stan::math::fill(delta,DUMMY_VAR__);
            current_statement_begin__ = 42;
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 44;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 45;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))));
                current_statement_begin__ = 46;
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), ((Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * (get_base1(minRT,N,"minRT",1) - RTbound)) + RTbound));
            }
            current_statement_begin__ = 48;
            stan::math::assign(alpha, exp(add(get_base1(mu_p,1,"mu_p",1),multiply(get_base1(sigma,1,"sigma",1),alpha_pr))));
            current_statement_begin__ = 49;
            stan::math::assign(delta, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),delta_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(delta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: delta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 39;
            check_greater_or_equal(function__,"alpha",alpha,0);
            current_statement_begin__ = 40;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,1);
            current_statement_begin__ = 41;
            check_greater_or_equal(function__,"delta",delta,0);
            current_statement_begin__ = 42;
            check_greater_or_equal(function__,"tau",tau,RTbound);
            check_less_or_equal(function__,"tau",tau,max(minRT));

            // model body

            current_statement_begin__ = 54;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 55;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 58;
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1));
            current_statement_begin__ = 59;
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            current_statement_begin__ = 60;
            lp_accum__.add(normal_log<propto__>(delta_pr, 0, 1));
            current_statement_begin__ = 61;
            lp_accum__.add(normal_log<propto__>(tau_pr, 0, 1));
            current_statement_begin__ = 64;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 66;
                lp_accum__.add(wiener_log<propto__>(stan::model::rvalue(RTu, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_max(get_base1(Nu,i,"Nu",1)), stan::model::nil_index_list())), "RTu"), get_base1(alpha,i,"alpha",1), get_base1(tau,i,"tau",1), get_base1(beta,i,"beta",1), get_base1(delta,i,"delta",1)));
                current_statement_begin__ = 67;
                lp_accum__.add(wiener_log<propto__>(stan::model::rvalue(RTl, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_max(get_base1(Nl,i,"Nl",1)), stan::model::nil_index_list())), "RTl"), get_base1(alpha,i,"alpha",1), get_base1(tau,i,"tau",1), (1 - get_base1(beta,i,"beta",1)), -(get_base1(delta,i,"delta",1))));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("alpha_pr");
        names__.push_back("beta_pr");
        names__.push_back("delta_pr");
        names__.push_back("tau_pr");
        names__.push_back("alpha");
        names__.push_back("beta");
        names__.push_back("delta");
        names__.push_back("tau");
        names__.push_back("mu_alpha");
        names__.push_back("mu_beta");
        names__.push_back("mu_delta");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_choiceRT_ddm_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
        vector_d delta_pr = in__.vector_constrain(N);
        vector_d tau_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(delta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 39;
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            current_statement_begin__ = 40;
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);
            current_statement_begin__ = 41;
            validate_non_negative_index("delta", "N", N);
            vector_d delta(static_cast<Eigen::VectorXd::Index>(N));
            (void) delta;  // dummy to suppress unused var warning

            stan::math::initialize(delta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(delta,DUMMY_VAR__);
            current_statement_begin__ = 42;
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 44;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 45;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))));
                current_statement_begin__ = 46;
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), ((Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * (get_base1(minRT,N,"minRT",1) - RTbound)) + RTbound));
            }
            current_statement_begin__ = 48;
            stan::math::assign(alpha, exp(add(get_base1(mu_p,1,"mu_p",1),multiply(get_base1(sigma,1,"sigma",1),alpha_pr))));
            current_statement_begin__ = 49;
            stan::math::assign(delta, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),delta_pr))));

            // validate transformed parameters
            current_statement_begin__ = 39;
            check_greater_or_equal(function__,"alpha",alpha,0);
            current_statement_begin__ = 40;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,1);
            current_statement_begin__ = 41;
            check_greater_or_equal(function__,"delta",delta,0);
            current_statement_begin__ = 42;
            check_greater_or_equal(function__,"tau",tau,RTbound);
            check_less_or_equal(function__,"tau",tau,max(minRT));

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(delta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 74;
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            current_statement_begin__ = 75;
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            current_statement_begin__ = 76;
            double mu_delta(0.0);
            (void) mu_delta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_delta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_delta,DUMMY_VAR__);
            current_statement_begin__ = 77;
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            current_statement_begin__ = 80;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);


            current_statement_begin__ = 83;
            stan::math::assign(mu_alpha, exp(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 84;
            stan::math::assign(mu_beta, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 85;
            stan::math::assign(mu_delta, exp(get_base1(mu_p,3,"mu_p",1)));
            current_statement_begin__ = 86;
            stan::math::assign(mu_tau, ((Phi_approx(get_base1(mu_p,4,"mu_p",1)) * (mean(minRT) - RTbound)) + RTbound));

            current_statement_begin__ = 90;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 91;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), wiener_log(stan::model::rvalue(RTu, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_max(get_base1(Nu,i,"Nu",1)), stan::model::nil_index_list())), "RTu"),get_base1(alpha,i,"alpha",1),get_base1(tau,i,"tau",1),get_base1(beta,i,"beta",1),get_base1(delta,i,"delta",1)));
                current_statement_begin__ = 92;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + wiener_log(stan::model::rvalue(RTl, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_max(get_base1(Nl,i,"Nl",1)), stan::model::nil_index_list())), "RTl"),get_base1(alpha,i,"alpha",1),get_base1(tau,i,"tau",1),(1 - get_base1(beta,i,"beta",1)),-(get_base1(delta,i,"delta",1)))));
            }

            // validate generated quantities
            current_statement_begin__ = 74;
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            current_statement_begin__ = 75;
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,1);
            current_statement_begin__ = 76;
            check_greater_or_equal(function__,"mu_delta",mu_delta,0);
            current_statement_begin__ = 77;
            check_greater_or_equal(function__,"mu_tau",mu_tau,RTbound);
            check_less_or_equal(function__,"mu_tau",mu_tau,max(minRT));
            current_statement_begin__ = 80;

            // write generated quantities
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_beta);
        vars__.push_back(mu_delta);
        vars__.push_back(mu_tau);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_choiceRT_ddm";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "delta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "delta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_delta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "delta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "delta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_delta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_choiceRT_ddm_single_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_choiceRT_ddm_single");
    reader.add_event(55, 55, "end", "model_choiceRT_ddm_single");
    return reader;
}

class model_choiceRT_ddm_single : public prob_grad {
private:
    int Nu;
    int Nl;
    vector<double> RTu;
    vector<double> RTl;
    double minRT;
    double RTbound;
public:
    model_choiceRT_ddm_single(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_choiceRT_ddm_single(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_choiceRT_ddm_single_namespace::model_choiceRT_ddm_single";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "Nu", "int", context__.to_vec());
            Nu = int(0);
            vals_i__ = context__.vals_i("Nu");
            pos__ = 0;
            Nu = vals_i__[pos__++];
            current_statement_begin__ = 4;
            context__.validate_dims("data initialization", "Nl", "int", context__.to_vec());
            Nl = int(0);
            vals_i__ = context__.vals_i("Nl");
            pos__ = 0;
            Nl = vals_i__[pos__++];
            current_statement_begin__ = 5;
            validate_non_negative_index("RTu", "Nu", Nu);
            context__.validate_dims("data initialization", "RTu", "double", context__.to_vec(Nu));
            validate_non_negative_index("RTu", "Nu", Nu);
            RTu = std::vector<double>(Nu,double(0));
            vals_r__ = context__.vals_r("RTu");
            pos__ = 0;
            size_t RTu_limit_0__ = Nu;
            for (size_t i_0__ = 0; i_0__ < RTu_limit_0__; ++i_0__) {
                RTu[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("RTl", "Nl", Nl);
            context__.validate_dims("data initialization", "RTl", "double", context__.to_vec(Nl));
            validate_non_negative_index("RTl", "Nl", Nl);
            RTl = std::vector<double>(Nl,double(0));
            vals_r__ = context__.vals_r("RTl");
            pos__ = 0;
            size_t RTl_limit_0__ = Nl;
            for (size_t i_0__ = 0; i_0__ < RTl_limit_0__; ++i_0__) {
                RTl[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 7;
            context__.validate_dims("data initialization", "minRT", "double", context__.to_vec());
            minRT = double(0);
            vals_r__ = context__.vals_r("minRT");
            pos__ = 0;
            minRT = vals_r__[pos__++];
            current_statement_begin__ = 8;
            context__.validate_dims("data initialization", "RTbound", "double", context__.to_vec());
            RTbound = double(0);
            vals_r__ = context__.vals_r("RTbound");
            pos__ = 0;
            RTbound = vals_r__[pos__++];

            // validate, data variables
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"Nu",Nu,0);
            current_statement_begin__ = 4;
            check_greater_or_equal(function__,"Nl",Nl,0);
            current_statement_begin__ = 5;
            current_statement_begin__ = 6;
            current_statement_begin__ = 7;
            current_statement_begin__ = 8;
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 22;
            ++num_params_r__;
            current_statement_begin__ = 23;
            ++num_params_r__;
            current_statement_begin__ = 24;
            ++num_params_r__;
            current_statement_begin__ = 25;
            ++num_params_r__;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_choiceRT_ddm_single() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("alpha")))
            throw std::runtime_error("variable alpha missing");
        vals_r__ = context__.vals_r("alpha");
        pos__ = 0U;
        context__.validate_dims("initialization", "alpha", "double", context__.to_vec());
        double alpha(0);
        alpha = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,alpha);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha: ") + e.what());
        }

        if (!(context__.contains_r("beta")))
            throw std::runtime_error("variable beta missing");
        vals_r__ = context__.vals_r("beta");
        pos__ = 0U;
        context__.validate_dims("initialization", "beta", "double", context__.to_vec());
        double beta(0);
        beta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,beta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta: ") + e.what());
        }

        if (!(context__.contains_r("delta")))
            throw std::runtime_error("variable delta missing");
        vals_r__ = context__.vals_r("delta");
        pos__ = 0U;
        context__.validate_dims("initialization", "delta", "double", context__.to_vec());
        double delta(0);
        delta = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,delta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable delta: ") + e.what());
        }

        if (!(context__.contains_r("tau")))
            throw std::runtime_error("variable tau missing");
        vals_r__ = context__.vals_r("tau");
        pos__ = 0U;
        context__.validate_dims("initialization", "tau", "double", context__.to_vec());
        double tau(0);
        tau = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(RTbound,minRT,tau);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ alpha;
            (void) alpha;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha = in__.scalar_lb_constrain(0,lp__);
            else
                alpha = in__.scalar_lb_constrain(0);

            T__ beta;
            (void) beta;  // dummy to suppress unused var warning
            if (jacobian__)
                beta = in__.scalar_lub_constrain(0,1,lp__);
            else
                beta = in__.scalar_lub_constrain(0,1);

            T__ delta;
            (void) delta;  // dummy to suppress unused var warning
            if (jacobian__)
                delta = in__.scalar_lb_constrain(0,lp__);
            else
                delta = in__.scalar_lb_constrain(0);

            T__ tau;
            (void) tau;  // dummy to suppress unused var warning
            if (jacobian__)
                tau = in__.scalar_lub_constrain(RTbound,minRT,lp__);
            else
                tau = in__.scalar_lub_constrain(RTbound,minRT);


            // transformed parameters



            // validate transformed parameters

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            // model body

            current_statement_begin__ = 29;
            lp_accum__.add(uniform_log<propto__>(alpha, 0, 5));
            current_statement_begin__ = 30;
            lp_accum__.add(uniform_log<propto__>(beta, 0, 1));
            current_statement_begin__ = 31;
            lp_accum__.add(normal_log<propto__>(delta, 0, 2));
            current_statement_begin__ = 32;
            lp_accum__.add(uniform_log<propto__>(tau, 0.10000000000000001, minRT));
            current_statement_begin__ = 34;
            lp_accum__.add(wiener_log<propto__>(RTu, alpha, tau, beta, delta));
            current_statement_begin__ = 35;
            lp_accum__.add(wiener_log<propto__>(RTl, alpha, tau, (1 - beta), -(delta)));

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("alpha");
        names__.push_back("beta");
        names__.push_back("delta");
        names__.push_back("tau");
        names__.push_back("log_lik");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_choiceRT_ddm_single_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double alpha = in__.scalar_lb_constrain(0);
        double beta = in__.scalar_lub_constrain(0,1);
        double delta = in__.scalar_lb_constrain(0);
        double tau = in__.scalar_lub_constrain(RTbound,minRT);
        vars__.push_back(alpha);
        vars__.push_back(beta);
        vars__.push_back(delta);
        vars__.push_back(tau);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {



            // validate transformed parameters

            // write transformed parameters

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 41;
            double log_lik(0.0);
            (void) log_lik;  // dummy to suppress unused var warning

            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);



            current_statement_begin__ = 48;
            stan::math::assign(log_lik, wiener_log(RTu,alpha,tau,beta,delta));
            current_statement_begin__ = 49;
            stan::math::assign(log_lik, (log_lik + wiener_log(RTl,alpha,tau,(1 - beta),-(delta))));

            // validate generated quantities
            current_statement_begin__ = 41;

            // write generated quantities
        vars__.push_back(log_lik);

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_choiceRT_ddm_single";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "delta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "delta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_choiceRT_lba_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_choiceRT_lba");
    reader.add_event(271, 271, "end", "model_choiceRT_lba");
    return reader;
}

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
lba_pdf(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v_pdf,
            const T4__& s, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 6;
        fun_scalar_t__ b_A_tv_ts;
        (void) b_A_tv_ts;  // dummy to suppress unused var warning

        stan::math::initialize(b_A_tv_ts, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_A_tv_ts,DUMMY_VAR__);
        current_statement_begin__ = 7;
        fun_scalar_t__ b_tv_ts;
        (void) b_tv_ts;  // dummy to suppress unused var warning

        stan::math::initialize(b_tv_ts, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_tv_ts,DUMMY_VAR__);
        current_statement_begin__ = 8;
        fun_scalar_t__ term_1b;
        (void) term_1b;  // dummy to suppress unused var warning

        stan::math::initialize(term_1b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_1b,DUMMY_VAR__);
        current_statement_begin__ = 9;
        fun_scalar_t__ term_2b;
        (void) term_2b;  // dummy to suppress unused var warning

        stan::math::initialize(term_2b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_2b,DUMMY_VAR__);
        current_statement_begin__ = 10;
        fun_scalar_t__ term_3b;
        (void) term_3b;  // dummy to suppress unused var warning

        stan::math::initialize(term_3b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_3b,DUMMY_VAR__);
        current_statement_begin__ = 11;
        fun_scalar_t__ term_4b;
        (void) term_4b;  // dummy to suppress unused var warning

        stan::math::initialize(term_4b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_4b,DUMMY_VAR__);
        current_statement_begin__ = 12;
        fun_scalar_t__ pdf;
        (void) pdf;  // dummy to suppress unused var warning

        stan::math::initialize(pdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(pdf,DUMMY_VAR__);


        current_statement_begin__ = 14;
        stan::math::assign(b_A_tv_ts, (((b - A) - (t * v_pdf)) / (t * s)));
        current_statement_begin__ = 15;
        stan::math::assign(b_tv_ts, ((b - (t * v_pdf)) / (t * s)));
        current_statement_begin__ = 17;
        stan::math::assign(term_1b, (v_pdf * Phi(b_A_tv_ts)));
        current_statement_begin__ = 18;
        stan::math::assign(term_2b, (s * exp(normal_log(fabs(b_A_tv_ts),0,1))));
        current_statement_begin__ = 19;
        stan::math::assign(term_3b, (v_pdf * Phi(b_tv_ts)));
        current_statement_begin__ = 20;
        stan::math::assign(term_4b, (s * exp(normal_log(fabs(b_tv_ts),0,1))));
        current_statement_begin__ = 22;
        stan::math::assign(pdf, ((1 / A) * (((-(term_1b) + term_2b) + term_3b) - term_4b)));
        current_statement_begin__ = 24;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lba_pdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v_pdf,
            const T4__& s, std::ostream* pstream__) const {
        return lba_pdf(t, b, A, v_pdf, s, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
lba_cdf(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v_cdf,
            const T4__& s, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 29;
        fun_scalar_t__ b_A_tv;
        (void) b_A_tv;  // dummy to suppress unused var warning

        stan::math::initialize(b_A_tv, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_A_tv,DUMMY_VAR__);
        current_statement_begin__ = 30;
        fun_scalar_t__ b_tv;
        (void) b_tv;  // dummy to suppress unused var warning

        stan::math::initialize(b_tv, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_tv,DUMMY_VAR__);
        current_statement_begin__ = 31;
        fun_scalar_t__ ts;
        (void) ts;  // dummy to suppress unused var warning

        stan::math::initialize(ts, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(ts,DUMMY_VAR__);
        current_statement_begin__ = 32;
        fun_scalar_t__ term_1a;
        (void) term_1a;  // dummy to suppress unused var warning

        stan::math::initialize(term_1a, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_1a,DUMMY_VAR__);
        current_statement_begin__ = 33;
        fun_scalar_t__ term_2a;
        (void) term_2a;  // dummy to suppress unused var warning

        stan::math::initialize(term_2a, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_2a,DUMMY_VAR__);
        current_statement_begin__ = 34;
        fun_scalar_t__ term_3a;
        (void) term_3a;  // dummy to suppress unused var warning

        stan::math::initialize(term_3a, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_3a,DUMMY_VAR__);
        current_statement_begin__ = 35;
        fun_scalar_t__ term_4a;
        (void) term_4a;  // dummy to suppress unused var warning

        stan::math::initialize(term_4a, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_4a,DUMMY_VAR__);
        current_statement_begin__ = 36;
        fun_scalar_t__ cdf;
        (void) cdf;  // dummy to suppress unused var warning

        stan::math::initialize(cdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(cdf,DUMMY_VAR__);


        current_statement_begin__ = 38;
        stan::math::assign(b_A_tv, ((b - A) - (t * v_cdf)));
        current_statement_begin__ = 39;
        stan::math::assign(b_tv, (b - (t * v_cdf)));
        current_statement_begin__ = 40;
        stan::math::assign(ts, (t * s));
        current_statement_begin__ = 42;
        stan::math::assign(term_1a, ((b_A_tv / A) * Phi((b_A_tv / ts))));
        current_statement_begin__ = 43;
        stan::math::assign(term_2a, ((b_tv / A) * Phi((b_tv / ts))));
        current_statement_begin__ = 44;
        stan::math::assign(term_3a, ((ts / A) * exp(normal_log(fabs((b_A_tv / ts)),0,1))));
        current_statement_begin__ = 45;
        stan::math::assign(term_4a, ((ts / A) * exp(normal_log(fabs((b_tv / ts)),0,1))));
        current_statement_begin__ = 47;
        stan::math::assign(cdf, ((((1 + term_1a) - term_2a) + term_3a) - term_4a));
        current_statement_begin__ = 49;
        return stan::math::promote_scalar<fun_return_scalar_t__>(cdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lba_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v_cdf,
            const T4__& s, std::ostream* pstream__) const {
        return lba_cdf(t, b, A, v_cdf, s, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
lba_lpdf(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& RT,
             const T1__& d,
             const T2__& A,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
             const T4__& s,
             const T5__& tau, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 54;
        fun_scalar_t__ t;
        (void) t;  // dummy to suppress unused var warning

        stan::math::initialize(t, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(t,DUMMY_VAR__);
        current_statement_begin__ = 55;
        fun_scalar_t__ b;
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b,DUMMY_VAR__);
        current_statement_begin__ = 56;
        fun_scalar_t__ cdf;
        (void) cdf;  // dummy to suppress unused var warning

        stan::math::initialize(cdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(cdf,DUMMY_VAR__);
        current_statement_begin__ = 57;
        fun_scalar_t__ pdf;
        (void) pdf;  // dummy to suppress unused var warning

        stan::math::initialize(pdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(pdf,DUMMY_VAR__);
        current_statement_begin__ = 58;
        validate_non_negative_index("prob", "cols(RT)", cols(RT));
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  prob(static_cast<Eigen::VectorXd::Index>(cols(RT)));
        (void) prob;  // dummy to suppress unused var warning

        stan::math::initialize(prob, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(prob,DUMMY_VAR__);
        current_statement_begin__ = 59;
        fun_scalar_t__ out;
        (void) out;  // dummy to suppress unused var warning

        stan::math::initialize(out, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(out,DUMMY_VAR__);
        current_statement_begin__ = 60;
        fun_scalar_t__ prob_neg;
        (void) prob_neg;  // dummy to suppress unused var warning

        stan::math::initialize(prob_neg, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(prob_neg,DUMMY_VAR__);


        current_statement_begin__ = 62;
        stan::math::assign(b, (A + d));
        current_statement_begin__ = 63;
        for (int i = 1; i <= cols(RT); ++i) {

            current_statement_begin__ = 64;
            stan::math::assign(t, (get_base1(RT,1,i,"RT",1) - tau));
            current_statement_begin__ = 65;
            if (as_bool(logical_gt(t,0))) {

                current_statement_begin__ = 66;
                stan::math::assign(cdf, 1);
                current_statement_begin__ = 67;
                for (int j = 1; j <= num_elements(v); ++j) {

                    current_statement_begin__ = 68;
                    if (as_bool(logical_eq(get_base1(RT,2,i,"RT",1),j))) {

                        current_statement_begin__ = 69;
                        stan::math::assign(pdf, lba_pdf(t,b,A,get_base1(v,j,"v",1),s, pstream__));
                    } else {

                        current_statement_begin__ = 71;
                        stan::math::assign(cdf, (lba_cdf(t,b,A,get_base1(v,j,"v",1),s, pstream__) * cdf));
                    }
                }
                current_statement_begin__ = 74;
                stan::math::assign(prob_neg, 1);
                current_statement_begin__ = 75;
                for (int j = 1; j <= num_elements(v); ++j) {

                    current_statement_begin__ = 76;
                    stan::math::assign(prob_neg, (Phi((-(get_base1(v,j,"v",1)) / s)) * prob_neg));
                }
                current_statement_begin__ = 78;
                stan::math::assign(get_base1_lhs(prob,i,"prob",1), (pdf * (1 - cdf)));
                current_statement_begin__ = 79;
                stan::math::assign(get_base1_lhs(prob,i,"prob",1), (get_base1(prob,i,"prob",1) / (1 - prob_neg)));
                current_statement_begin__ = 80;
                if (as_bool(logical_lt(get_base1(prob,i,"prob",1),1e-10))) {

                    current_statement_begin__ = 81;
                    stan::math::assign(get_base1_lhs(prob,i,"prob",1), 1e-10);
                }
            } else {

                current_statement_begin__ = 85;
                stan::math::assign(get_base1_lhs(prob,i,"prob",1), 1e-10);
            }
        }
        current_statement_begin__ = 88;
        stan::math::assign(out, sum(log(prob)));
        current_statement_begin__ = 89;
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
lba_lpdf(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& RT,
             const T1__& d,
             const T2__& A,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
             const T4__& s,
             const T5__& tau, std::ostream* pstream__) {
    return lba_lpdf<false>(RT,d,A,v,s,tau, pstream__);
}


struct lba_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& RT,
             const T1__& d,
             const T2__& A,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
             const T4__& s,
             const T5__& tau, std::ostream* pstream__) const {
        return lba_lpdf(RT, d, A, v, s, tau, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1>
lba_rng(const T0__& d,
            const T1__& A,
            const Eigen::Matrix<T2__, Eigen::Dynamic,1>& v,
            const T3__& s,
            const T4__& tau, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 94;
        int get_pos_drift(0);
        (void) get_pos_drift;  // dummy to suppress unused var warning

        stan::math::fill(get_pos_drift, std::numeric_limits<int>::min());
        current_statement_begin__ = 95;
        int no_pos_drift(0);
        (void) no_pos_drift;  // dummy to suppress unused var warning

        stan::math::fill(no_pos_drift, std::numeric_limits<int>::min());
        current_statement_begin__ = 96;
        int get_first_pos(0);
        (void) get_first_pos;  // dummy to suppress unused var warning

        stan::math::fill(get_first_pos, std::numeric_limits<int>::min());
        current_statement_begin__ = 97;
        validate_non_negative_index("drift", "num_elements(v)", num_elements(v));
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  drift(static_cast<Eigen::VectorXd::Index>(num_elements(v)));
        (void) drift;  // dummy to suppress unused var warning

        stan::math::initialize(drift, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(drift,DUMMY_VAR__);
        current_statement_begin__ = 98;
        int max_iter(0);
        (void) max_iter;  // dummy to suppress unused var warning

        stan::math::fill(max_iter, std::numeric_limits<int>::min());
        current_statement_begin__ = 99;
        int iter(0);
        (void) iter;  // dummy to suppress unused var warning

        stan::math::fill(iter, std::numeric_limits<int>::min());
        current_statement_begin__ = 100;
        validate_non_negative_index("start", "num_elements(v)", num_elements(v));
        vector<fun_scalar_t__> start(num_elements(v));
        stan::math::initialize(start, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(start,DUMMY_VAR__);
        current_statement_begin__ = 101;
        validate_non_negative_index("ttf", "num_elements(v)", num_elements(v));
        vector<fun_scalar_t__> ttf(num_elements(v));
        stan::math::initialize(ttf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(ttf,DUMMY_VAR__);
        current_statement_begin__ = 102;
        validate_non_negative_index("resp", "num_elements(v)", num_elements(v));
        vector<int> resp(num_elements(v), 0);
        stan::math::fill(resp, std::numeric_limits<int>::min());
        current_statement_begin__ = 103;
        fun_scalar_t__ rt;
        (void) rt;  // dummy to suppress unused var warning

        stan::math::initialize(rt, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(rt,DUMMY_VAR__);
        current_statement_begin__ = 104;
        validate_non_negative_index("pred", "2", 2);
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  pred(static_cast<Eigen::VectorXd::Index>(2));
        (void) pred;  // dummy to suppress unused var warning

        stan::math::initialize(pred, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(pred,DUMMY_VAR__);
        current_statement_begin__ = 105;
        fun_scalar_t__ b;
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b,DUMMY_VAR__);


        current_statement_begin__ = 108;
        stan::math::assign(get_pos_drift, 1);
        current_statement_begin__ = 109;
        stan::math::assign(no_pos_drift, 0);
        current_statement_begin__ = 110;
        stan::math::assign(max_iter, 1000);
        current_statement_begin__ = 111;
        stan::math::assign(iter, 0);
        current_statement_begin__ = 112;
        while (as_bool(get_pos_drift)) {

            current_statement_begin__ = 113;
            for (int j = 1; j <= num_elements(v); ++j) {

                current_statement_begin__ = 114;
                stan::math::assign(get_base1_lhs(drift,j,"drift",1), normal_rng(get_base1(v,j,"v",1),s, base_rng__));
                current_statement_begin__ = 115;
                if (as_bool(logical_gt(get_base1(drift,j,"drift",1),0))) {

                    current_statement_begin__ = 116;
                    stan::math::assign(get_pos_drift, 0);
                }
            }
            current_statement_begin__ = 119;
            stan::math::assign(iter, (iter + 1));
            current_statement_begin__ = 120;
            if (as_bool(logical_gt(iter,max_iter))) {

                current_statement_begin__ = 121;
                stan::math::assign(get_pos_drift, 0);
                current_statement_begin__ = 122;
                stan::math::assign(no_pos_drift, 1);
            }
        }
        current_statement_begin__ = 127;
        if (as_bool(no_pos_drift)) {

            current_statement_begin__ = 128;
            stan::math::assign(get_base1_lhs(pred,1,"pred",1), -(1));
            current_statement_begin__ = 129;
            stan::math::assign(get_base1_lhs(pred,2,"pred",1), -(1));
        } else {

            current_statement_begin__ = 131;
            stan::math::assign(b, (A + d));
            current_statement_begin__ = 132;
            for (int i = 1; i <= num_elements(v); ++i) {

                current_statement_begin__ = 134;
                stan::math::assign(get_base1_lhs(start,i,"start",1), uniform_rng(0,A, base_rng__));
                current_statement_begin__ = 136;
                stan::math::assign(get_base1_lhs(ttf,i,"ttf",1), ((b - get_base1(start,i,"start",1)) / get_base1(drift,i,"drift",1)));
            }
            current_statement_begin__ = 140;
            stan::math::assign(resp, sort_indices_asc(ttf));
            current_statement_begin__ = 141;
            stan::math::assign(ttf, sort_asc(ttf));
            current_statement_begin__ = 142;
            stan::math::assign(get_first_pos, 1);
            current_statement_begin__ = 143;
            stan::math::assign(iter, 1);
            current_statement_begin__ = 144;
            while (as_bool(get_first_pos)) {

                current_statement_begin__ = 145;
                if (as_bool(logical_gt(get_base1(ttf,iter,"ttf",1),0))) {

                    current_statement_begin__ = 146;
                    stan::math::assign(get_base1_lhs(pred,1,"pred",1), get_base1(ttf,iter,"ttf",1));
                    current_statement_begin__ = 147;
                    stan::math::assign(get_base1_lhs(pred,2,"pred",1), get_base1(resp,iter,"resp",1));
                    current_statement_begin__ = 148;
                    stan::math::assign(get_first_pos, 0);
                }
                current_statement_begin__ = 150;
                stan::math::assign(iter, (iter + 1));
            }
        }
        current_statement_begin__ = 153;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pred);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lba_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1>
    operator()(const T0__& d,
            const T1__& A,
            const Eigen::Matrix<T2__, Eigen::Dynamic,1>& v,
            const T3__& s,
            const T4__& tau, RNG& base_rng__, std::ostream* pstream__) const {
        return lba_rng(d, A, v, s, tau, base_rng__, pstream__);
    }
};

class model_choiceRT_lba : public prob_grad {
private:
    int N;
    int Max_tr;
    int N_choices;
    int N_cond;
    vector<vector<int> > N_tr_cond;
    vector<vector<matrix_d> > RT;
public:
    model_choiceRT_lba(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_choiceRT_lba(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_choiceRT_lba_namespace::model_choiceRT_lba";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 157;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 158;
            context__.validate_dims("data initialization", "Max_tr", "int", context__.to_vec());
            Max_tr = int(0);
            vals_i__ = context__.vals_i("Max_tr");
            pos__ = 0;
            Max_tr = vals_i__[pos__++];
            current_statement_begin__ = 159;
            context__.validate_dims("data initialization", "N_choices", "int", context__.to_vec());
            N_choices = int(0);
            vals_i__ = context__.vals_i("N_choices");
            pos__ = 0;
            N_choices = vals_i__[pos__++];
            current_statement_begin__ = 160;
            context__.validate_dims("data initialization", "N_cond", "int", context__.to_vec());
            N_cond = int(0);
            vals_i__ = context__.vals_i("N_cond");
            pos__ = 0;
            N_cond = vals_i__[pos__++];
            current_statement_begin__ = 161;
            validate_non_negative_index("N_tr_cond", "N", N);
            validate_non_negative_index("N_tr_cond", "N_cond", N_cond);
            context__.validate_dims("data initialization", "N_tr_cond", "int", context__.to_vec(N,N_cond));
            validate_non_negative_index("N_tr_cond", "N", N);
            validate_non_negative_index("N_tr_cond", "N_cond", N_cond);
            N_tr_cond = std::vector<std::vector<int> >(N,std::vector<int>(N_cond,int(0)));
            vals_i__ = context__.vals_i("N_tr_cond");
            pos__ = 0;
            size_t N_tr_cond_limit_1__ = N_cond;
            for (size_t i_1__ = 0; i_1__ < N_tr_cond_limit_1__; ++i_1__) {
                size_t N_tr_cond_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < N_tr_cond_limit_0__; ++i_0__) {
                    N_tr_cond[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 162;
            validate_non_negative_index("RT", "N", N);
            validate_non_negative_index("RT", "N_cond", N_cond);
            validate_non_negative_index("RT", "2", 2);
            validate_non_negative_index("RT", "Max_tr", Max_tr);
            context__.validate_dims("data initialization", "RT", "matrix_d", context__.to_vec(N,N_cond,2,Max_tr));
            validate_non_negative_index("RT", "N", N);
            validate_non_negative_index("RT", "N_cond", N_cond);
            validate_non_negative_index("RT", "2", 2);
            validate_non_negative_index("RT", "Max_tr", Max_tr);
            RT = std::vector<std::vector<matrix_d> >(N,std::vector<matrix_d>(N_cond,matrix_d(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(Max_tr))));
            vals_r__ = context__.vals_r("RT");
            pos__ = 0;
            size_t RT_m_mat_lim__ = 2;
            size_t RT_n_mat_lim__ = Max_tr;
            for (size_t n_mat__ = 0; n_mat__ < RT_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < RT_m_mat_lim__; ++m_mat__) {
                    size_t RT_limit_1__ = N_cond;
                    for (size_t i_1__ = 0; i_1__ < RT_limit_1__; ++i_1__) {
                        size_t RT_limit_0__ = N;
                        for (size_t i_0__ = 0; i_0__ < RT_limit_0__; ++i_0__) {
                            RT[i_0__][i_1__](m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
                }
            }

            // validate, data variables
            current_statement_begin__ = 157;
            current_statement_begin__ = 158;
            current_statement_begin__ = 159;
            current_statement_begin__ = 160;
            current_statement_begin__ = 161;
            current_statement_begin__ = 162;
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 168;
            ++num_params_r__;
            current_statement_begin__ = 169;
            ++num_params_r__;
            current_statement_begin__ = 170;
            ++num_params_r__;
            current_statement_begin__ = 171;
            validate_non_negative_index("mu_v", "N_choices", N_choices);
            validate_non_negative_index("mu_v", "N_cond", N_cond);
            num_params_r__ += N_choices * N_cond;
            current_statement_begin__ = 174;
            ++num_params_r__;
            current_statement_begin__ = 175;
            ++num_params_r__;
            current_statement_begin__ = 176;
            ++num_params_r__;
            current_statement_begin__ = 177;
            validate_non_negative_index("sigma_v", "N_choices", N_choices);
            validate_non_negative_index("sigma_v", "N_cond", N_cond);
            num_params_r__ += N_choices * N_cond;
            current_statement_begin__ = 180;
            validate_non_negative_index("d", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 181;
            validate_non_negative_index("A", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 182;
            validate_non_negative_index("tau", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 183;
            validate_non_negative_index("v", "N_choices", N_choices);
            validate_non_negative_index("v", "N", N);
            validate_non_negative_index("v", "N_cond", N_cond);
            num_params_r__ += N_choices * N * N_cond;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_choiceRT_lba() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_d")))
            throw std::runtime_error("variable mu_d missing");
        vals_r__ = context__.vals_r("mu_d");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_d", "double", context__.to_vec());
        double mu_d(0);
        mu_d = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,mu_d);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_d: ") + e.what());
        }

        if (!(context__.contains_r("mu_A")))
            throw std::runtime_error("variable mu_A missing");
        vals_r__ = context__.vals_r("mu_A");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_A", "double", context__.to_vec());
        double mu_A(0);
        mu_A = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,mu_A);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_A: ") + e.what());
        }

        if (!(context__.contains_r("mu_tau")))
            throw std::runtime_error("variable mu_tau missing");
        vals_r__ = context__.vals_r("mu_tau");
        pos__ = 0U;
        context__.validate_dims("initialization", "mu_tau", "double", context__.to_vec());
        double mu_tau(0);
        mu_tau = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,mu_tau);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_tau: ") + e.what());
        }

        if (!(context__.contains_r("mu_v")))
            throw std::runtime_error("variable mu_v missing");
        vals_r__ = context__.vals_r("mu_v");
        pos__ = 0U;
        validate_non_negative_index("mu_v", "N_cond", N_cond);
        validate_non_negative_index("mu_v", "N_choices", N_choices);
        context__.validate_dims("initialization", "mu_v", "vector_d", context__.to_vec(N_cond,N_choices));
        std::vector<vector_d> mu_v(N_cond,vector_d(static_cast<Eigen::VectorXd::Index>(N_choices)));
        for (int j1__ = 0U; j1__ < N_choices; ++j1__)
            for (int i0__ = 0U; i0__ < N_cond; ++i0__)
                mu_v[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_cond; ++i0__)
            try {
            writer__.vector_lb_unconstrain(0,mu_v[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_v: ") + e.what());
        }

        if (!(context__.contains_r("sigma_d")))
            throw std::runtime_error("variable sigma_d missing");
        vals_r__ = context__.vals_r("sigma_d");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_d", "double", context__.to_vec());
        double sigma_d(0);
        sigma_d = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_d);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_d: ") + e.what());
        }

        if (!(context__.contains_r("sigma_A")))
            throw std::runtime_error("variable sigma_A missing");
        vals_r__ = context__.vals_r("sigma_A");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_A", "double", context__.to_vec());
        double sigma_A(0);
        sigma_A = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_A);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_A: ") + e.what());
        }

        if (!(context__.contains_r("sigma_tau")))
            throw std::runtime_error("variable sigma_tau missing");
        vals_r__ = context__.vals_r("sigma_tau");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_tau", "double", context__.to_vec());
        double sigma_tau(0);
        sigma_tau = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma_tau);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_tau: ") + e.what());
        }

        if (!(context__.contains_r("sigma_v")))
            throw std::runtime_error("variable sigma_v missing");
        vals_r__ = context__.vals_r("sigma_v");
        pos__ = 0U;
        validate_non_negative_index("sigma_v", "N_cond", N_cond);
        validate_non_negative_index("sigma_v", "N_choices", N_choices);
        context__.validate_dims("initialization", "sigma_v", "vector_d", context__.to_vec(N_cond,N_choices));
        std::vector<vector_d> sigma_v(N_cond,vector_d(static_cast<Eigen::VectorXd::Index>(N_choices)));
        for (int j1__ = 0U; j1__ < N_choices; ++j1__)
            for (int i0__ = 0U; i0__ < N_cond; ++i0__)
                sigma_v[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_cond; ++i0__)
            try {
            writer__.vector_lb_unconstrain(0,sigma_v[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_v: ") + e.what());
        }

        if (!(context__.contains_r("d")))
            throw std::runtime_error("variable d missing");
        vals_r__ = context__.vals_r("d");
        pos__ = 0U;
        validate_non_negative_index("d", "N", N);
        context__.validate_dims("initialization", "d", "double", context__.to_vec(N));
        std::vector<double> d(N,double(0));
        for (int i0__ = 0U; i0__ < N; ++i0__)
            d[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N; ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,d[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable d: ") + e.what());
        }

        if (!(context__.contains_r("A")))
            throw std::runtime_error("variable A missing");
        vals_r__ = context__.vals_r("A");
        pos__ = 0U;
        validate_non_negative_index("A", "N", N);
        context__.validate_dims("initialization", "A", "double", context__.to_vec(N));
        std::vector<double> A(N,double(0));
        for (int i0__ = 0U; i0__ < N; ++i0__)
            A[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N; ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,A[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable A: ") + e.what());
        }

        if (!(context__.contains_r("tau")))
            throw std::runtime_error("variable tau missing");
        vals_r__ = context__.vals_r("tau");
        pos__ = 0U;
        validate_non_negative_index("tau", "N", N);
        context__.validate_dims("initialization", "tau", "double", context__.to_vec(N));
        std::vector<double> tau(N,double(0));
        for (int i0__ = 0U; i0__ < N; ++i0__)
            tau[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N; ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,tau[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau: ") + e.what());
        }

        if (!(context__.contains_r("v")))
            throw std::runtime_error("variable v missing");
        vals_r__ = context__.vals_r("v");
        pos__ = 0U;
        validate_non_negative_index("v", "N", N);
        validate_non_negative_index("v", "N_cond", N_cond);
        validate_non_negative_index("v", "N_choices", N_choices);
        context__.validate_dims("initialization", "v", "vector_d", context__.to_vec(N,N_cond,N_choices));
        std::vector<std::vector<vector_d> > v(N,std::vector<vector_d>(N_cond,vector_d(static_cast<Eigen::VectorXd::Index>(N_choices))));
        for (int j1__ = 0U; j1__ < N_choices; ++j1__)
            for (int i1__ = 0U; i1__ < N_cond; ++i1__)
                for (int i0__ = 0U; i0__ < N; ++i0__)
                    v[i0__][i1__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N; ++i0__)
            for (int i1__ = 0U; i1__ < N_cond; ++i1__)
                try {
            writer__.vector_lb_unconstrain(0,v[i0__][i1__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable v: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ mu_d;
            (void) mu_d;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_d = in__.scalar_lb_constrain(0,lp__);
            else
                mu_d = in__.scalar_lb_constrain(0);

            T__ mu_A;
            (void) mu_A;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_A = in__.scalar_lb_constrain(0,lp__);
            else
                mu_A = in__.scalar_lb_constrain(0);

            T__ mu_tau;
            (void) mu_tau;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_tau = in__.scalar_lb_constrain(0,lp__);
            else
                mu_tau = in__.scalar_lb_constrain(0);

            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > mu_v;
            size_t dim_mu_v_0__ = N_cond;
            mu_v.reserve(dim_mu_v_0__);
            for (size_t k_0__ = 0; k_0__ < dim_mu_v_0__; ++k_0__) {
                if (jacobian__)
                    mu_v.push_back(in__.vector_lb_constrain(0,N_choices,lp__));
                else
                    mu_v.push_back(in__.vector_lb_constrain(0,N_choices));
            }

            T__ sigma_d;
            (void) sigma_d;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma_d = in__.scalar_lb_constrain(0,lp__);
            else
                sigma_d = in__.scalar_lb_constrain(0);

            T__ sigma_A;
            (void) sigma_A;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma_A = in__.scalar_lb_constrain(0,lp__);
            else
                sigma_A = in__.scalar_lb_constrain(0);

            T__ sigma_tau;
            (void) sigma_tau;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma_tau = in__.scalar_lb_constrain(0,lp__);
            else
                sigma_tau = in__.scalar_lb_constrain(0);

            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > sigma_v;
            size_t dim_sigma_v_0__ = N_cond;
            sigma_v.reserve(dim_sigma_v_0__);
            for (size_t k_0__ = 0; k_0__ < dim_sigma_v_0__; ++k_0__) {
                if (jacobian__)
                    sigma_v.push_back(in__.vector_lb_constrain(0,N_choices,lp__));
                else
                    sigma_v.push_back(in__.vector_lb_constrain(0,N_choices));
            }

            vector<T__> d;
            size_t dim_d_0__ = N;
            d.reserve(dim_d_0__);
            for (size_t k_0__ = 0; k_0__ < dim_d_0__; ++k_0__) {
                if (jacobian__)
                    d.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    d.push_back(in__.scalar_lb_constrain(0));
            }

            vector<T__> A;
            size_t dim_A_0__ = N;
            A.reserve(dim_A_0__);
            for (size_t k_0__ = 0; k_0__ < dim_A_0__; ++k_0__) {
                if (jacobian__)
                    A.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    A.push_back(in__.scalar_lb_constrain(0));
            }

            vector<T__> tau;
            size_t dim_tau_0__ = N;
            tau.reserve(dim_tau_0__);
            for (size_t k_0__ = 0; k_0__ < dim_tau_0__; ++k_0__) {
                if (jacobian__)
                    tau.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    tau.push_back(in__.scalar_lb_constrain(0));
            }

            vector<vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > > v;
            size_t dim_v_0__ = N;
            v.resize(dim_v_0__);
            for (size_t k_0__ = 0; k_0__ < dim_v_0__; ++k_0__) {
                size_t dim_v_1__ = N_cond;
                v[k_0__].reserve(dim_v_1__);
                for (size_t k_1__ = 0; k_1__ < dim_v_1__; ++k_1__) {
                    if (jacobian__)
                        v[k_0__].push_back(in__.vector_lb_constrain(0,N_choices,lp__));
                    else
                        v[k_0__].push_back(in__.vector_lb_constrain(0,N_choices));
                }
            }


            // transformed parameters
            current_statement_begin__ = 187;
            T__ s;
            (void) s;  // dummy to suppress unused var warning

            stan::math::initialize(s, DUMMY_VAR__);
            stan::math::fill(s,DUMMY_VAR__);


            current_statement_begin__ = 188;
            stan::math::assign(s, 1);

            // validate transformed parameters
            if (stan::math::is_uninitialized(s)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: s";
                throw std::runtime_error(msg__.str());
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 187;

            // model body

            current_statement_begin__ = 192;
            lp_accum__.add(normal_log<propto__>(mu_d, 0.5, 1));
            if (mu_d < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0.5, 1));
            current_statement_begin__ = 193;
            lp_accum__.add(normal_log<propto__>(mu_A, 0.5, 1));
            if (mu_A < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0.5, 1));
            current_statement_begin__ = 194;
            lp_accum__.add(normal_log<propto__>(mu_tau, 0.5, 0.5));
            if (mu_tau < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0.5, 0.5));
            current_statement_begin__ = 197;
            lp_accum__.add(gamma_log<propto__>(sigma_d, 1, 1));
            current_statement_begin__ = 198;
            lp_accum__.add(gamma_log<propto__>(sigma_A, 1, 1));
            current_statement_begin__ = 199;
            lp_accum__.add(gamma_log<propto__>(sigma_tau, 1, 1));
            current_statement_begin__ = 202;
            for (int j = 1; j <= N_cond; ++j) {

                current_statement_begin__ = 203;
                for (int n = 1; n <= N_choices; ++n) {

                    current_statement_begin__ = 204;
                    lp_accum__.add(normal_log<propto__>(get_base1(get_base1(mu_v,j,"mu_v",1),n,"mu_v",2), 2, 1));
                    if (get_base1(get_base1(mu_v,j,"mu_v",1),n,"mu_v",2) < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                    else lp_accum__.add(-normal_ccdf_log(0, 2, 1));
                    current_statement_begin__ = 205;
                    lp_accum__.add(gamma_log<propto__>(get_base1(get_base1(sigma_v,j,"sigma_v",1),n,"sigma_v",2), 1, 1));
                }
            }
            current_statement_begin__ = 209;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 211;
                int n_trials(0);
                (void) n_trials;  // dummy to suppress unused var warning

                stan::math::fill(n_trials, std::numeric_limits<int>::min());


                current_statement_begin__ = 214;
                lp_accum__.add(normal_log<propto__>(get_base1(d,i,"d",1), mu_d, sigma_d));
                if (get_base1(d,i,"d",1) < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-normal_ccdf_log(0, mu_d, sigma_d));
                current_statement_begin__ = 215;
                lp_accum__.add(normal_log<propto__>(get_base1(A,i,"A",1), mu_A, sigma_A));
                if (get_base1(A,i,"A",1) < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-normal_ccdf_log(0, mu_A, sigma_A));
                current_statement_begin__ = 216;
                lp_accum__.add(normal_log<propto__>(get_base1(tau,i,"tau",1), mu_tau, sigma_tau));
                if (get_base1(tau,i,"tau",1) < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-normal_ccdf_log(0, mu_tau, sigma_tau));
                current_statement_begin__ = 218;
                for (int j = 1; j <= N_cond; ++j) {

                    current_statement_begin__ = 220;
                    stan::math::assign(n_trials, get_base1(get_base1(N_tr_cond,i,"N_tr_cond",1),j,"N_tr_cond",2));
                    current_statement_begin__ = 222;
                    for (int n = 1; n <= N_choices; ++n) {

                        current_statement_begin__ = 224;
                        lp_accum__.add(normal_log<propto__>(get_base1(get_base1(get_base1(v,i,"v",1),j,"v",2),n,"v",3), get_base1(get_base1(mu_v,j,"mu_v",1),n,"mu_v",2), get_base1(get_base1(sigma_v,j,"sigma_v",1),n,"sigma_v",2)));
                        if (get_base1(get_base1(get_base1(v,i,"v",1),j,"v",2),n,"v",3) < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                        else lp_accum__.add(-normal_ccdf_log(0, get_base1(get_base1(mu_v,j,"mu_v",1),n,"mu_v",2), get_base1(get_base1(sigma_v,j,"sigma_v",1),n,"sigma_v",2)));
                    }
                    current_statement_begin__ = 227;
                    lp_accum__.add(lba_lpdf<propto__>(stan::model::rvalue(RT, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(1, n_trials), stan::model::nil_index_list())))), "RT"), get_base1(d,i,"d",1), get_base1(A,i,"A",1), stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "v"), s, get_base1(tau,i,"tau",1), pstream__));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_d");
        names__.push_back("mu_A");
        names__.push_back("mu_tau");
        names__.push_back("mu_v");
        names__.push_back("sigma_d");
        names__.push_back("sigma_A");
        names__.push_back("sigma_tau");
        names__.push_back("sigma_v");
        names__.push_back("d");
        names__.push_back("A");
        names__.push_back("tau");
        names__.push_back("v");
        names__.push_back("s");
        names__.push_back("n_trials");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_cond);
        dims__.push_back(N_choices);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_cond);
        dims__.push_back(N_choices);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(N_cond);
        dims__.push_back(N_choices);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(N_cond);
        dims__.push_back(2);
        dims__.push_back(Max_tr);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_choiceRT_lba_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double mu_d = in__.scalar_lb_constrain(0);
        double mu_A = in__.scalar_lb_constrain(0);
        double mu_tau = in__.scalar_lb_constrain(0);
        vector<vector_d> mu_v;
        size_t dim_mu_v_0__ = N_cond;
        for (size_t k_0__ = 0; k_0__ < dim_mu_v_0__; ++k_0__) {
            mu_v.push_back(in__.vector_lb_constrain(0,N_choices));
        }
        double sigma_d = in__.scalar_lb_constrain(0);
        double sigma_A = in__.scalar_lb_constrain(0);
        double sigma_tau = in__.scalar_lb_constrain(0);
        vector<vector_d> sigma_v;
        size_t dim_sigma_v_0__ = N_cond;
        for (size_t k_0__ = 0; k_0__ < dim_sigma_v_0__; ++k_0__) {
            sigma_v.push_back(in__.vector_lb_constrain(0,N_choices));
        }
        vector<double> d;
        size_t dim_d_0__ = N;
        for (size_t k_0__ = 0; k_0__ < dim_d_0__; ++k_0__) {
            d.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> A;
        size_t dim_A_0__ = N;
        for (size_t k_0__ = 0; k_0__ < dim_A_0__; ++k_0__) {
            A.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> tau;
        size_t dim_tau_0__ = N;
        for (size_t k_0__ = 0; k_0__ < dim_tau_0__; ++k_0__) {
            tau.push_back(in__.scalar_lb_constrain(0));
        }
        vector<vector<vector_d> > v;
        size_t dim_v_0__ = N;
        v.resize(dim_v_0__);
        for (size_t k_0__ = 0; k_0__ < dim_v_0__; ++k_0__) {
            size_t dim_v_1__ = N_cond;
            for (size_t k_1__ = 0; k_1__ < dim_v_1__; ++k_1__) {
                v[k_0__].push_back(in__.vector_lb_constrain(0,N_choices));
            }
        }
        vars__.push_back(mu_d);
        vars__.push_back(mu_A);
        vars__.push_back(mu_tau);
            for (int k_1__ = 0; k_1__ < N_choices; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N_cond; ++k_0__) {
                vars__.push_back(mu_v[k_0__][k_1__]);
                }
            }
        vars__.push_back(sigma_d);
        vars__.push_back(sigma_A);
        vars__.push_back(sigma_tau);
            for (int k_1__ = 0; k_1__ < N_choices; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N_cond; ++k_0__) {
                vars__.push_back(sigma_v[k_0__][k_1__]);
                }
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(d[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }
            for (int k_2__ = 0; k_2__ < N_choices; ++k_2__) {
                for (int k_1__ = 0; k_1__ < N_cond; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(v[k_0__][k_1__][k_2__]);
                    }
                }
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 187;
            double s(0.0);
            (void) s;  // dummy to suppress unused var warning

            stan::math::initialize(s, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(s,DUMMY_VAR__);


            current_statement_begin__ = 188;
            stan::math::assign(s, 1);

            // validate transformed parameters
            current_statement_begin__ = 187;

            // write transformed parameters
        vars__.push_back(s);

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 234;
            int n_trials(0);
            (void) n_trials;  // dummy to suppress unused var warning

            stan::math::fill(n_trials, std::numeric_limits<int>::min());
            current_statement_begin__ = 237;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 240;
            validate_non_negative_index("y_pred", "2", 2);
            validate_non_negative_index("y_pred", "Max_tr", Max_tr);
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "N_cond", N_cond);
            vector<vector<matrix_d> > y_pred(N, (vector<matrix_d>(N_cond, (matrix_d(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(Max_tr))))));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 243;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 244;
                for (int j = 1; j <= N_cond; ++j) {

                    current_statement_begin__ = 245;
                    for (int t = 1; t <= Max_tr; ++t) {

                        current_statement_begin__ = 246;
                        stan::model::assign(y_pred, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list())))), 
                                    rep_vector(-(1),2), 
                                    "assigning variable y_pred");
                    }
                }
            }

            current_statement_begin__ = 252;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 254;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 256;
                for (int j = 1; j <= N_cond; ++j) {

                    current_statement_begin__ = 258;
                    stan::math::assign(n_trials, get_base1(get_base1(N_tr_cond,i,"N_tr_cond",1),j,"N_tr_cond",2));
                    current_statement_begin__ = 261;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + lba_lpdf(stan::model::rvalue(RT, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(1, n_trials), stan::model::nil_index_list())))), "RT"),get_base1(d,i,"d",1),get_base1(A,i,"A",1),stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "v"),s,get_base1(tau,i,"tau",1), pstream__)));
                    current_statement_begin__ = 263;
                    for (int t = 1; t <= n_trials; ++t) {

                        current_statement_begin__ = 265;
                        stan::model::assign(y_pred, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list())))), 
                                    lba_rng(get_base1(d,i,"d",1),get_base1(A,i,"A",1),stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "v"),s,get_base1(tau,i,"tau",1), base_rng__, pstream__), 
                                    "assigning variable y_pred");
                    }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 234;
            current_statement_begin__ = 237;
            current_statement_begin__ = 240;

            // write generated quantities
        vars__.push_back(n_trials);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_3__ = 0; k_3__ < Max_tr; ++k_3__) {
                for (int k_2__ = 0; k_2__ < 2; ++k_2__) {
                    for (int k_1__ = 0; k_1__ < N_cond; ++k_1__) {
                        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                        vars__.push_back(y_pred[k_0__][k_1__](k_2__, k_3__));
                        }
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_choiceRT_lba";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_d";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= N_choices; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_v" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_d";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= N_choices; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "sigma_v" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "d" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= N_choices; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= N_cond; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "v" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "s";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "n_trials";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_3__ = 1; k_3__ <= Max_tr; ++k_3__) {
            for (int k_2__ = 1; k_2__ <= 2; ++k_2__) {
                for (int k_1__ = 1; k_1__ <= N_cond; ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__ << '.' << k_3__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_d";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= N_choices; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_v" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_d";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= N_choices; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "sigma_v" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "d" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= N_choices; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= N_cond; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "v" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "s";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "n_trials";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_3__ = 1; k_3__ <= Max_tr; ++k_3__) {
            for (int k_2__ = 1; k_2__ <= 2; ++k_2__) {
                for (int k_1__ = 1; k_1__ <= N_cond; ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__ << '.' << k_3__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_choiceRT_lba_single_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_choiceRT_lba_single");
    reader.add_event(232, 232, "end", "model_choiceRT_lba_single");
    return reader;
}

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
lba_pdf(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v,
            const T4__& s, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 6;
        fun_scalar_t__ b_A_tv_ts;
        (void) b_A_tv_ts;  // dummy to suppress unused var warning

        stan::math::initialize(b_A_tv_ts, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_A_tv_ts,DUMMY_VAR__);
        current_statement_begin__ = 7;
        fun_scalar_t__ b_tv_ts;
        (void) b_tv_ts;  // dummy to suppress unused var warning

        stan::math::initialize(b_tv_ts, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_tv_ts,DUMMY_VAR__);
        current_statement_begin__ = 8;
        fun_scalar_t__ term_1;
        (void) term_1;  // dummy to suppress unused var warning

        stan::math::initialize(term_1, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_1,DUMMY_VAR__);
        current_statement_begin__ = 9;
        fun_scalar_t__ term_2;
        (void) term_2;  // dummy to suppress unused var warning

        stan::math::initialize(term_2, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_2,DUMMY_VAR__);
        current_statement_begin__ = 10;
        fun_scalar_t__ term_3;
        (void) term_3;  // dummy to suppress unused var warning

        stan::math::initialize(term_3, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_3,DUMMY_VAR__);
        current_statement_begin__ = 11;
        fun_scalar_t__ term_4;
        (void) term_4;  // dummy to suppress unused var warning

        stan::math::initialize(term_4, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_4,DUMMY_VAR__);
        current_statement_begin__ = 12;
        fun_scalar_t__ pdf;
        (void) pdf;  // dummy to suppress unused var warning

        stan::math::initialize(pdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(pdf,DUMMY_VAR__);


        current_statement_begin__ = 14;
        stan::math::assign(b_A_tv_ts, (((b - A) - (t * v)) / (t * s)));
        current_statement_begin__ = 15;
        stan::math::assign(b_tv_ts, ((b - (t * v)) / (t * s)));
        current_statement_begin__ = 17;
        stan::math::assign(term_1, (v * Phi(b_A_tv_ts)));
        current_statement_begin__ = 18;
        stan::math::assign(term_2, (s * exp(normal_log(b_A_tv_ts,0,1))));
        current_statement_begin__ = 19;
        stan::math::assign(term_3, (v * Phi(b_tv_ts)));
        current_statement_begin__ = 20;
        stan::math::assign(term_4, (s * exp(normal_log(b_tv_ts,0,1))));
        current_statement_begin__ = 22;
        stan::math::assign(pdf, ((1 / A) * (((-(term_1) + term_2) + term_3) - term_4)));
        current_statement_begin__ = 24;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lba_pdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v,
            const T4__& s, std::ostream* pstream__) const {
        return lba_pdf(t, b, A, v, s, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
lba_cdf(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v,
            const T4__& s, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 29;
        fun_scalar_t__ b_A_tv;
        (void) b_A_tv;  // dummy to suppress unused var warning

        stan::math::initialize(b_A_tv, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_A_tv,DUMMY_VAR__);
        current_statement_begin__ = 30;
        fun_scalar_t__ b_tv;
        (void) b_tv;  // dummy to suppress unused var warning

        stan::math::initialize(b_tv, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b_tv,DUMMY_VAR__);
        current_statement_begin__ = 31;
        fun_scalar_t__ ts;
        (void) ts;  // dummy to suppress unused var warning

        stan::math::initialize(ts, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(ts,DUMMY_VAR__);
        current_statement_begin__ = 32;
        fun_scalar_t__ term_1;
        (void) term_1;  // dummy to suppress unused var warning

        stan::math::initialize(term_1, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_1,DUMMY_VAR__);
        current_statement_begin__ = 33;
        fun_scalar_t__ term_2;
        (void) term_2;  // dummy to suppress unused var warning

        stan::math::initialize(term_2, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_2,DUMMY_VAR__);
        current_statement_begin__ = 34;
        fun_scalar_t__ term_3;
        (void) term_3;  // dummy to suppress unused var warning

        stan::math::initialize(term_3, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_3,DUMMY_VAR__);
        current_statement_begin__ = 35;
        fun_scalar_t__ term_4;
        (void) term_4;  // dummy to suppress unused var warning

        stan::math::initialize(term_4, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(term_4,DUMMY_VAR__);
        current_statement_begin__ = 36;
        fun_scalar_t__ cdf;
        (void) cdf;  // dummy to suppress unused var warning

        stan::math::initialize(cdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(cdf,DUMMY_VAR__);


        current_statement_begin__ = 38;
        stan::math::assign(b_A_tv, ((b - A) - (t * v)));
        current_statement_begin__ = 39;
        stan::math::assign(b_tv, (b - (t * v)));
        current_statement_begin__ = 40;
        stan::math::assign(ts, (t * s));
        current_statement_begin__ = 42;
        stan::math::assign(term_1, ((b_A_tv / A) * Phi((b_A_tv / ts))));
        current_statement_begin__ = 43;
        stan::math::assign(term_2, ((b_tv / A) * Phi((b_tv / ts))));
        current_statement_begin__ = 44;
        stan::math::assign(term_3, ((ts / A) * exp(normal_log((b_A_tv / ts),0,1))));
        current_statement_begin__ = 45;
        stan::math::assign(term_4, ((ts / A) * exp(normal_log((b_tv / ts),0,1))));
        current_statement_begin__ = 47;
        stan::math::assign(cdf, ((((1 + term_1) - term_2) + term_3) - term_4));
        current_statement_begin__ = 49;
        return stan::math::promote_scalar<fun_return_scalar_t__>(cdf);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lba_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& t,
            const T1__& b,
            const T2__& A,
            const T3__& v,
            const T4__& s, std::ostream* pstream__) const {
        return lba_cdf(t, b, A, v, s, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
lba_lpdf(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& RT,
             const T1__& d,
             const T2__& A,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
             const T4__& s,
             const T5__& tau, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 55;
        fun_scalar_t__ t;
        (void) t;  // dummy to suppress unused var warning

        stan::math::initialize(t, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(t,DUMMY_VAR__);
        current_statement_begin__ = 56;
        fun_scalar_t__ b;
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b,DUMMY_VAR__);
        current_statement_begin__ = 57;
        fun_scalar_t__ cdf;
        (void) cdf;  // dummy to suppress unused var warning

        stan::math::initialize(cdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(cdf,DUMMY_VAR__);
        current_statement_begin__ = 58;
        fun_scalar_t__ pdf;
        (void) pdf;  // dummy to suppress unused var warning

        stan::math::initialize(pdf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(pdf,DUMMY_VAR__);
        current_statement_begin__ = 59;
        validate_non_negative_index("prob", "rows(RT)", rows(RT));
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  prob(static_cast<Eigen::VectorXd::Index>(rows(RT)));
        (void) prob;  // dummy to suppress unused var warning

        stan::math::initialize(prob, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(prob,DUMMY_VAR__);
        current_statement_begin__ = 60;
        fun_scalar_t__ out;
        (void) out;  // dummy to suppress unused var warning

        stan::math::initialize(out, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(out,DUMMY_VAR__);
        current_statement_begin__ = 61;
        fun_scalar_t__ prob_neg;
        (void) prob_neg;  // dummy to suppress unused var warning

        stan::math::initialize(prob_neg, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(prob_neg,DUMMY_VAR__);


        current_statement_begin__ = 63;
        stan::math::assign(b, (A + d));
        current_statement_begin__ = 64;
        for (int i = 1; i <= rows(RT); ++i) {

            current_statement_begin__ = 65;
            stan::math::assign(t, (get_base1(RT,1,i,"RT",1) - tau));
            current_statement_begin__ = 66;
            if (as_bool(logical_gt(t,0))) {

                current_statement_begin__ = 67;
                stan::math::assign(cdf, 1);
                current_statement_begin__ = 69;
                for (int j = 1; j <= num_elements(v); ++j) {

                    current_statement_begin__ = 70;
                    if (as_bool(logical_eq(get_base1(RT,2,i,"RT",1),j))) {

                        current_statement_begin__ = 71;
                        stan::math::assign(pdf, lba_pdf(t,b,A,get_base1(v,j,"v",1),s, pstream__));
                    } else {

                        current_statement_begin__ = 73;
                        stan::math::assign(cdf, ((1 - lba_cdf(t,b,A,get_base1(v,j,"v",1),s, pstream__)) * cdf));
                    }
                }
                current_statement_begin__ = 76;
                stan::math::assign(prob_neg, 1);
                current_statement_begin__ = 77;
                for (int j = 1; j <= num_elements(v); ++j) {

                    current_statement_begin__ = 78;
                    stan::math::assign(prob_neg, (Phi((-(get_base1(v,j,"v",1)) / s)) * prob_neg));
                }
                current_statement_begin__ = 80;
                stan::math::assign(get_base1_lhs(prob,i,"prob",1), (pdf * cdf));
                current_statement_begin__ = 81;
                stan::math::assign(get_base1_lhs(prob,i,"prob",1), (get_base1(prob,i,"prob",1) / (1 - prob_neg)));
                current_statement_begin__ = 82;
                if (as_bool(logical_lt(get_base1(prob,i,"prob",1),1e-10))) {

                    current_statement_begin__ = 83;
                    stan::math::assign(get_base1_lhs(prob,i,"prob",1), 1e-10);
                }
            } else {

                current_statement_begin__ = 87;
                stan::math::assign(get_base1_lhs(prob,i,"prob",1), 1e-10);
            }
        }
        current_statement_begin__ = 90;
        stan::math::assign(out, sum(log(prob)));
        current_statement_begin__ = 91;
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
lba_lpdf(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& RT,
             const T1__& d,
             const T2__& A,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
             const T4__& s,
             const T5__& tau, std::ostream* pstream__) {
    return lba_lpdf<false>(RT,d,A,v,s,tau, pstream__);
}


struct lba_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& RT,
             const T1__& d,
             const T2__& A,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
             const T4__& s,
             const T5__& tau, std::ostream* pstream__) const {
        return lba_lpdf(RT, d, A, v, s, tau, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1>
lba_rng(const T0__& d,
            const T1__& A,
            const Eigen::Matrix<T2__, Eigen::Dynamic,1>& v,
            const T3__& s,
            const T4__& tau, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 96;
        int get_pos_drift(0);
        (void) get_pos_drift;  // dummy to suppress unused var warning

        stan::math::fill(get_pos_drift, std::numeric_limits<int>::min());
        current_statement_begin__ = 97;
        int no_pos_drift(0);
        (void) no_pos_drift;  // dummy to suppress unused var warning

        stan::math::fill(no_pos_drift, std::numeric_limits<int>::min());
        current_statement_begin__ = 98;
        int get_first_pos(0);
        (void) get_first_pos;  // dummy to suppress unused var warning

        stan::math::fill(get_first_pos, std::numeric_limits<int>::min());
        current_statement_begin__ = 99;
        validate_non_negative_index("drift", "num_elements(v)", num_elements(v));
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  drift(static_cast<Eigen::VectorXd::Index>(num_elements(v)));
        (void) drift;  // dummy to suppress unused var warning

        stan::math::initialize(drift, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(drift,DUMMY_VAR__);
        current_statement_begin__ = 100;
        int max_iter(0);
        (void) max_iter;  // dummy to suppress unused var warning

        stan::math::fill(max_iter, std::numeric_limits<int>::min());
        current_statement_begin__ = 101;
        int iter(0);
        (void) iter;  // dummy to suppress unused var warning

        stan::math::fill(iter, std::numeric_limits<int>::min());
        current_statement_begin__ = 102;
        validate_non_negative_index("start", "num_elements(v)", num_elements(v));
        vector<fun_scalar_t__> start(num_elements(v));
        stan::math::initialize(start, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(start,DUMMY_VAR__);
        current_statement_begin__ = 103;
        validate_non_negative_index("ttf", "num_elements(v)", num_elements(v));
        vector<fun_scalar_t__> ttf(num_elements(v));
        stan::math::initialize(ttf, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(ttf,DUMMY_VAR__);
        current_statement_begin__ = 104;
        validate_non_negative_index("resp", "num_elements(v)", num_elements(v));
        vector<int> resp(num_elements(v), 0);
        stan::math::fill(resp, std::numeric_limits<int>::min());
        current_statement_begin__ = 105;
        fun_scalar_t__ rt;
        (void) rt;  // dummy to suppress unused var warning

        stan::math::initialize(rt, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(rt,DUMMY_VAR__);
        current_statement_begin__ = 106;
        validate_non_negative_index("pred", "2", 2);
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  pred(static_cast<Eigen::VectorXd::Index>(2));
        (void) pred;  // dummy to suppress unused var warning

        stan::math::initialize(pred, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(pred,DUMMY_VAR__);
        current_statement_begin__ = 107;
        fun_scalar_t__ b;
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b,DUMMY_VAR__);


        current_statement_begin__ = 110;
        stan::math::assign(get_pos_drift, 1);
        current_statement_begin__ = 111;
        stan::math::assign(no_pos_drift, 0);
        current_statement_begin__ = 112;
        stan::math::assign(max_iter, 1000);
        current_statement_begin__ = 113;
        stan::math::assign(iter, 0);
        current_statement_begin__ = 114;
        while (as_bool(get_pos_drift)) {

            current_statement_begin__ = 115;
            for (int j = 1; j <= num_elements(v); ++j) {

                current_statement_begin__ = 116;
                stan::math::assign(get_base1_lhs(drift,j,"drift",1), normal_rng(get_base1(v,j,"v",1),s, base_rng__));
                current_statement_begin__ = 117;
                if (as_bool(logical_gt(get_base1(drift,j,"drift",1),0))) {

                    current_statement_begin__ = 118;
                    stan::math::assign(get_pos_drift, 0);
                }
            }
            current_statement_begin__ = 121;
            stan::math::assign(iter, (iter + 1));
            current_statement_begin__ = 122;
            if (as_bool(logical_gt(iter,max_iter))) {

                current_statement_begin__ = 123;
                stan::math::assign(get_pos_drift, 0);
                current_statement_begin__ = 124;
                stan::math::assign(no_pos_drift, 1);
            }
        }
        current_statement_begin__ = 129;
        if (as_bool(no_pos_drift)) {

            current_statement_begin__ = 130;
            stan::math::assign(get_base1_lhs(pred,1,"pred",1), -(1));
            current_statement_begin__ = 131;
            stan::math::assign(get_base1_lhs(pred,2,"pred",1), -(1));
        } else {

            current_statement_begin__ = 133;
            stan::math::assign(b, (A + d));
            current_statement_begin__ = 134;
            for (int i = 1; i <= num_elements(v); ++i) {

                current_statement_begin__ = 136;
                stan::math::assign(get_base1_lhs(start,i,"start",1), uniform_rng(0,A, base_rng__));
                current_statement_begin__ = 138;
                stan::math::assign(get_base1_lhs(ttf,i,"ttf",1), ((b - get_base1(start,i,"start",1)) / get_base1(drift,i,"drift",1)));
            }
            current_statement_begin__ = 142;
            stan::math::assign(resp, sort_indices_asc(ttf));
            current_statement_begin__ = 143;
            stan::math::assign(ttf, sort_asc(ttf));
            current_statement_begin__ = 144;
            stan::math::assign(get_first_pos, 1);
            current_statement_begin__ = 145;
            stan::math::assign(iter, 1);
            current_statement_begin__ = 146;
            while (as_bool(get_first_pos)) {

                current_statement_begin__ = 147;
                if (as_bool(logical_gt(get_base1(ttf,iter,"ttf",1),0))) {

                    current_statement_begin__ = 148;
                    stan::math::assign(get_base1_lhs(pred,1,"pred",1), (get_base1(ttf,iter,"ttf",1) + tau));
                    current_statement_begin__ = 149;
                    stan::math::assign(get_base1_lhs(pred,2,"pred",1), get_base1(resp,iter,"resp",1));
                    current_statement_begin__ = 150;
                    stan::math::assign(get_first_pos, 0);
                }
                current_statement_begin__ = 152;
                stan::math::assign(iter, (iter + 1));
            }
        }
        current_statement_begin__ = 155;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pred);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lba_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1>
    operator()(const T0__& d,
            const T1__& A,
            const Eigen::Matrix<T2__, Eigen::Dynamic,1>& v,
            const T3__& s,
            const T4__& tau, RNG& base_rng__, std::ostream* pstream__) const {
        return lba_rng(d, A, v, s, tau, base_rng__, pstream__);
    }
};

class model_choiceRT_lba_single : public prob_grad {
private:
    int Max_tr;
    int N_choices;
    int N_cond;
    vector<int> N_tr_cond;
    vector<matrix_d> RT;
public:
    model_choiceRT_lba_single(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_choiceRT_lba_single(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_choiceRT_lba_single_namespace::model_choiceRT_lba_single";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 159;
            context__.validate_dims("data initialization", "Max_tr", "int", context__.to_vec());
            Max_tr = int(0);
            vals_i__ = context__.vals_i("Max_tr");
            pos__ = 0;
            Max_tr = vals_i__[pos__++];
            current_statement_begin__ = 160;
            context__.validate_dims("data initialization", "N_choices", "int", context__.to_vec());
            N_choices = int(0);
            vals_i__ = context__.vals_i("N_choices");
            pos__ = 0;
            N_choices = vals_i__[pos__++];
            current_statement_begin__ = 161;
            context__.validate_dims("data initialization", "N_cond", "int", context__.to_vec());
            N_cond = int(0);
            vals_i__ = context__.vals_i("N_cond");
            pos__ = 0;
            N_cond = vals_i__[pos__++];
            current_statement_begin__ = 162;
            validate_non_negative_index("N_tr_cond", "N_cond", N_cond);
            context__.validate_dims("data initialization", "N_tr_cond", "int", context__.to_vec(N_cond));
            validate_non_negative_index("N_tr_cond", "N_cond", N_cond);
            N_tr_cond = std::vector<int>(N_cond,int(0));
            vals_i__ = context__.vals_i("N_tr_cond");
            pos__ = 0;
            size_t N_tr_cond_limit_0__ = N_cond;
            for (size_t i_0__ = 0; i_0__ < N_tr_cond_limit_0__; ++i_0__) {
                N_tr_cond[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 163;
            validate_non_negative_index("RT", "N_cond", N_cond);
            validate_non_negative_index("RT", "2", 2);
            validate_non_negative_index("RT", "Max_tr", Max_tr);
            context__.validate_dims("data initialization", "RT", "matrix_d", context__.to_vec(N_cond,2,Max_tr));
            validate_non_negative_index("RT", "N_cond", N_cond);
            validate_non_negative_index("RT", "2", 2);
            validate_non_negative_index("RT", "Max_tr", Max_tr);
            RT = std::vector<matrix_d>(N_cond,matrix_d(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(Max_tr)));
            vals_r__ = context__.vals_r("RT");
            pos__ = 0;
            size_t RT_m_mat_lim__ = 2;
            size_t RT_n_mat_lim__ = Max_tr;
            for (size_t n_mat__ = 0; n_mat__ < RT_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < RT_m_mat_lim__; ++m_mat__) {
                    size_t RT_limit_0__ = N_cond;
                    for (size_t i_0__ = 0; i_0__ < RT_limit_0__; ++i_0__) {
                        RT[i_0__](m_mat__,n_mat__) = vals_r__[pos__++];
            }
                }
            }

            // validate, data variables
            current_statement_begin__ = 159;
            current_statement_begin__ = 160;
            current_statement_begin__ = 161;
            current_statement_begin__ = 162;
            current_statement_begin__ = 163;
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 167;
            ++num_params_r__;
            current_statement_begin__ = 168;
            ++num_params_r__;
            current_statement_begin__ = 169;
            ++num_params_r__;
            current_statement_begin__ = 170;
            validate_non_negative_index("v", "N_choices", N_choices);
            validate_non_negative_index("v", "N_cond", N_cond);
            num_params_r__ += N_choices * N_cond;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_choiceRT_lba_single() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("d")))
            throw std::runtime_error("variable d missing");
        vals_r__ = context__.vals_r("d");
        pos__ = 0U;
        context__.validate_dims("initialization", "d", "double", context__.to_vec());
        double d(0);
        d = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,d);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable d: ") + e.what());
        }

        if (!(context__.contains_r("A")))
            throw std::runtime_error("variable A missing");
        vals_r__ = context__.vals_r("A");
        pos__ = 0U;
        context__.validate_dims("initialization", "A", "double", context__.to_vec());
        double A(0);
        A = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,A);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable A: ") + e.what());
        }

        if (!(context__.contains_r("tau")))
            throw std::runtime_error("variable tau missing");
        vals_r__ = context__.vals_r("tau");
        pos__ = 0U;
        context__.validate_dims("initialization", "tau", "double", context__.to_vec());
        double tau(0);
        tau = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,tau);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau: ") + e.what());
        }

        if (!(context__.contains_r("v")))
            throw std::runtime_error("variable v missing");
        vals_r__ = context__.vals_r("v");
        pos__ = 0U;
        validate_non_negative_index("v", "N_cond", N_cond);
        validate_non_negative_index("v", "N_choices", N_choices);
        context__.validate_dims("initialization", "v", "vector_d", context__.to_vec(N_cond,N_choices));
        std::vector<vector_d> v(N_cond,vector_d(static_cast<Eigen::VectorXd::Index>(N_choices)));
        for (int j1__ = 0U; j1__ < N_choices; ++j1__)
            for (int i0__ = 0U; i0__ < N_cond; ++i0__)
                v[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_cond; ++i0__)
            try {
            writer__.vector_lb_unconstrain(0,v[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable v: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ d;
            (void) d;  // dummy to suppress unused var warning
            if (jacobian__)
                d = in__.scalar_lb_constrain(0,lp__);
            else
                d = in__.scalar_lb_constrain(0);

            T__ A;
            (void) A;  // dummy to suppress unused var warning
            if (jacobian__)
                A = in__.scalar_lb_constrain(0,lp__);
            else
                A = in__.scalar_lb_constrain(0);

            T__ tau;
            (void) tau;  // dummy to suppress unused var warning
            if (jacobian__)
                tau = in__.scalar_lb_constrain(0,lp__);
            else
                tau = in__.scalar_lb_constrain(0);

            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > v;
            size_t dim_v_0__ = N_cond;
            v.reserve(dim_v_0__);
            for (size_t k_0__ = 0; k_0__ < dim_v_0__; ++k_0__) {
                if (jacobian__)
                    v.push_back(in__.vector_lb_constrain(0,N_choices,lp__));
                else
                    v.push_back(in__.vector_lb_constrain(0,N_choices));
            }


            // transformed parameters
            current_statement_begin__ = 173;
            T__ s;
            (void) s;  // dummy to suppress unused var warning

            stan::math::initialize(s, DUMMY_VAR__);
            stan::math::fill(s,DUMMY_VAR__);


            current_statement_begin__ = 174;
            stan::math::assign(s, 1);

            // validate transformed parameters
            if (stan::math::is_uninitialized(s)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: s";
                throw std::runtime_error(msg__.str());
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 173;

            // model body
            {
            current_statement_begin__ = 178;
            int n_trials(0);
            (void) n_trials;  // dummy to suppress unused var warning

            stan::math::fill(n_trials, std::numeric_limits<int>::min());


            current_statement_begin__ = 181;
            lp_accum__.add(normal_log<propto__>(d, 0.5, 1));
            if (d < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0.5, 1));
            current_statement_begin__ = 182;
            lp_accum__.add(normal_log<propto__>(A, 0.5, 1));
            if (A < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0.5, 1));
            current_statement_begin__ = 183;
            lp_accum__.add(normal_log<propto__>(tau, 0.5, 0.5));
            if (tau < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0.5, 0.5));
            current_statement_begin__ = 185;
            for (int j = 1; j <= N_cond; ++j) {

                current_statement_begin__ = 187;
                stan::math::assign(n_trials, get_base1(N_tr_cond,j,"N_tr_cond",1));
                current_statement_begin__ = 189;
                for (int n = 1; n <= N_choices; ++n) {

                    current_statement_begin__ = 191;
                    lp_accum__.add(normal_log<propto__>(get_base1(get_base1(v,j,"v",1),n,"v",2), 2, 1));
                    if (get_base1(get_base1(v,j,"v",1),n,"v",2) < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                    else lp_accum__.add(-normal_ccdf_log(0, 2, 1));
                }
                current_statement_begin__ = 194;
                lp_accum__.add(lba_lpdf<propto__>(stan::model::rvalue(RT, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(1, n_trials), stan::model::nil_index_list()))), "RT"), d, A, stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "v"), s, tau, pstream__));
            }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("d");
        names__.push_back("A");
        names__.push_back("tau");
        names__.push_back("v");
        names__.push_back("s");
        names__.push_back("n_trials");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_cond);
        dims__.push_back(N_choices);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_cond);
        dims__.push_back(2);
        dims__.push_back(Max_tr);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_choiceRT_lba_single_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double d = in__.scalar_lb_constrain(0);
        double A = in__.scalar_lb_constrain(0);
        double tau = in__.scalar_lb_constrain(0);
        vector<vector_d> v;
        size_t dim_v_0__ = N_cond;
        for (size_t k_0__ = 0; k_0__ < dim_v_0__; ++k_0__) {
            v.push_back(in__.vector_lb_constrain(0,N_choices));
        }
        vars__.push_back(d);
        vars__.push_back(A);
        vars__.push_back(tau);
            for (int k_1__ = 0; k_1__ < N_choices; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N_cond; ++k_0__) {
                vars__.push_back(v[k_0__][k_1__]);
                }
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 173;
            double s(0.0);
            (void) s;  // dummy to suppress unused var warning

            stan::math::initialize(s, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(s,DUMMY_VAR__);


            current_statement_begin__ = 174;
            stan::math::assign(s, 1);

            // validate transformed parameters
            current_statement_begin__ = 173;

            // write transformed parameters
        vars__.push_back(s);

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 200;
            int n_trials(0);
            (void) n_trials;  // dummy to suppress unused var warning

            stan::math::fill(n_trials, std::numeric_limits<int>::min());
            current_statement_begin__ = 203;
            double log_lik(0.0);
            (void) log_lik;  // dummy to suppress unused var warning

            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 206;
            validate_non_negative_index("y_pred", "2", 2);
            validate_non_negative_index("y_pred", "Max_tr", Max_tr);
            validate_non_negative_index("y_pred", "N_cond", N_cond);
            vector<matrix_d> y_pred(N_cond, (matrix_d(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(Max_tr))));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 209;
            for (int j = 1; j <= N_cond; ++j) {

                current_statement_begin__ = 210;
                for (int t = 1; t <= Max_tr; ++t) {

                    current_statement_begin__ = 211;
                    stan::model::assign(y_pred, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()))), 
                                rep_vector(-(1),2), 
                                "assigning variable y_pred");
                }
            }
            current_statement_begin__ = 216;
            stan::math::assign(log_lik, 0);

            current_statement_begin__ = 219;
            for (int j = 1; j <= N_cond; ++j) {

                current_statement_begin__ = 221;
                stan::math::assign(n_trials, get_base1(N_tr_cond,j,"N_tr_cond",1));
                current_statement_begin__ = 224;
                stan::math::assign(log_lik, (log_lik + lba_lpdf(stan::model::rvalue(RT, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(1, n_trials), stan::model::nil_index_list()))), "RT"),d,A,stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "v"),s,tau, pstream__)));
                current_statement_begin__ = 226;
                for (int t = 1; t <= n_trials; ++t) {

                    current_statement_begin__ = 228;
                    stan::model::assign(y_pred, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()))), 
                                lba_rng(d,A,stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "v"),s,tau, base_rng__, pstream__), 
                                "assigning variable y_pred");
                }
            }

            // validate generated quantities
            current_statement_begin__ = 200;
            current_statement_begin__ = 203;
            current_statement_begin__ = 206;

            // write generated quantities
        vars__.push_back(n_trials);
        vars__.push_back(log_lik);
            for (int k_2__ = 0; k_2__ < Max_tr; ++k_2__) {
                for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N_cond; ++k_0__) {
                    vars__.push_back(y_pred[k_0__](k_1__, k_2__));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_choiceRT_lba_single";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "d";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= N_choices; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "v" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "s";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "n_trials";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_2__ = 1; k_2__ <= Max_tr; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "d";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= N_choices; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "v" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "s";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "n_trials";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_2__ = 1; k_2__ <= Max_tr; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N_cond; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_dd_cs_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_dd_cs");
    reader.add_event(104, 104, "end", "model_dd_cs");
    return reader;
}

class model_dd_cs : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > delay_later;
    vector<vector<double> > amount_later;
    vector<vector<double> > delay_sooner;
    vector<vector<double> > amount_sooner;
    vector<vector<int> > choice;
public:
    model_dd_cs(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_dd_cs(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_dd_cs_namespace::model_dd_cs";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("delay_later", "N", N);
            validate_non_negative_index("delay_later", "T", T);
            context__.validate_dims("data initialization", "delay_later", "double", context__.to_vec(N,T));
            validate_non_negative_index("delay_later", "N", N);
            validate_non_negative_index("delay_later", "T", T);
            delay_later = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("delay_later");
            pos__ = 0;
            size_t delay_later_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < delay_later_limit_1__; ++i_1__) {
                size_t delay_later_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < delay_later_limit_0__; ++i_0__) {
                    delay_later[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("amount_later", "N", N);
            validate_non_negative_index("amount_later", "T", T);
            context__.validate_dims("data initialization", "amount_later", "double", context__.to_vec(N,T));
            validate_non_negative_index("amount_later", "N", N);
            validate_non_negative_index("amount_later", "T", T);
            amount_later = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("amount_later");
            pos__ = 0;
            size_t amount_later_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < amount_later_limit_1__; ++i_1__) {
                size_t amount_later_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < amount_later_limit_0__; ++i_0__) {
                    amount_later[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("delay_sooner", "N", N);
            validate_non_negative_index("delay_sooner", "T", T);
            context__.validate_dims("data initialization", "delay_sooner", "double", context__.to_vec(N,T));
            validate_non_negative_index("delay_sooner", "N", N);
            validate_non_negative_index("delay_sooner", "T", T);
            delay_sooner = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("delay_sooner");
            pos__ = 0;
            size_t delay_sooner_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < delay_sooner_limit_1__; ++i_1__) {
                size_t delay_sooner_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < delay_sooner_limit_0__; ++i_0__) {
                    delay_sooner[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("amount_sooner", "N", N);
            validate_non_negative_index("amount_sooner", "T", T);
            context__.validate_dims("data initialization", "amount_sooner", "double", context__.to_vec(N,T));
            validate_non_negative_index("amount_sooner", "N", N);
            validate_non_negative_index("amount_sooner", "T", T);
            amount_sooner = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("amount_sooner");
            pos__ = 0;
            size_t amount_sooner_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < amount_sooner_limit_1__; ++i_1__) {
                size_t amount_sooner_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < amount_sooner_limit_0__; ++i_0__) {
                    amount_sooner[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 9;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"delay_later[k0__][k1__]",delay_later[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"amount_later[k0__][k1__]",amount_later[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"delay_sooner[k0__][k1__]",delay_sooner[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 8;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"amount_sooner[k0__][k1__]",amount_sooner[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 9;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],1);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 18;
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 19;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 22;
            validate_non_negative_index("r_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 23;
            validate_non_negative_index("s_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 24;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_dd_cs() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("r_pr")))
            throw std::runtime_error("variable r_pr missing");
        vals_r__ = context__.vals_r("r_pr");
        pos__ = 0U;
        validate_non_negative_index("r_pr", "N", N);
        context__.validate_dims("initialization", "r_pr", "vector_d", context__.to_vec(N));
        vector_d r_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            r_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(r_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable r_pr: ") + e.what());
        }

        if (!(context__.contains_r("s_pr")))
            throw std::runtime_error("variable s_pr missing");
        vals_r__ = context__.vals_r("s_pr");
        pos__ = 0U;
        validate_non_negative_index("s_pr", "N", N);
        context__.validate_dims("initialization", "s_pr", "vector_d", context__.to_vec(N));
        vector_d s_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            s_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(s_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable s_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  r_pr;
            (void) r_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                r_pr = in__.vector_constrain(N,lp__);
            else
                r_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  s_pr;
            (void) s_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                s_pr = in__.vector_constrain(N,lp__);
            else
                s_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 29;
            validate_non_negative_index("r", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  r(static_cast<Eigen::VectorXd::Index>(N));
            (void) r;  // dummy to suppress unused var warning

            stan::math::initialize(r, DUMMY_VAR__);
            stan::math::fill(r,DUMMY_VAR__);
            current_statement_begin__ = 30;
            validate_non_negative_index("s", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  s(static_cast<Eigen::VectorXd::Index>(N));
            (void) s;  // dummy to suppress unused var warning

            stan::math::initialize(s, DUMMY_VAR__);
            stan::math::fill(s,DUMMY_VAR__);
            current_statement_begin__ = 31;
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 33;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 34;
                stan::math::assign(get_base1_lhs(r,i,"r",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(r_pr,i,"r_pr",1)))));
                current_statement_begin__ = 35;
                stan::math::assign(get_base1_lhs(s,i,"s",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(s_pr,i,"s_pr",1)))) * 10));
                current_statement_begin__ = 36;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(r(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: r" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(s(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: s" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"r",r,0);
            check_less_or_equal(function__,"r",r,1);
            current_statement_begin__ = 30;
            check_greater_or_equal(function__,"s",s,0);
            check_less_or_equal(function__,"s",s,10);
            current_statement_begin__ = 31;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // model body

            current_statement_begin__ = 43;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 44;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 47;
            lp_accum__.add(normal_log<propto__>(r_pr, 0, 1));
            current_statement_begin__ = 48;
            lp_accum__.add(normal_log<propto__>(s_pr, 0, 1));
            current_statement_begin__ = 49;
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            current_statement_begin__ = 51;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 53;
                T__ ev_later;
                (void) ev_later;  // dummy to suppress unused var warning

                stan::math::initialize(ev_later, DUMMY_VAR__);
                stan::math::fill(ev_later,DUMMY_VAR__);
                current_statement_begin__ = 54;
                T__ ev_sooner;
                (void) ev_sooner;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sooner, DUMMY_VAR__);
                stan::math::fill(ev_sooner,DUMMY_VAR__);


                current_statement_begin__ = 56;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 57;
                    stan::math::assign(ev_later, (get_base1(get_base1(amount_later,i,"amount_later",1),t,"amount_later",2) * exp((-(1) * pow((get_base1(r,i,"r",1) * get_base1(get_base1(delay_later,i,"delay_later",1),t,"delay_later",2)),get_base1(s,i,"s",1))))));
                    current_statement_begin__ = 58;
                    stan::math::assign(ev_sooner, (get_base1(get_base1(amount_sooner,i,"amount_sooner",1),t,"amount_sooner",2) * exp((-(1) * pow((get_base1(r,i,"r",1) * get_base1(get_base1(delay_sooner,i,"delay_sooner",1),t,"delay_sooner",2)),get_base1(s,i,"s",1))))));
                    current_statement_begin__ = 59;
                    lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), (get_base1(beta,i,"beta",1) * (ev_later - ev_sooner))));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("r_pr");
        names__.push_back("s_pr");
        names__.push_back("beta_pr");
        names__.push_back("r");
        names__.push_back("s");
        names__.push_back("beta");
        names__.push_back("mu_r");
        names__.push_back("mu_s");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_dd_cs_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d r_pr = in__.vector_constrain(N);
        vector_d s_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(r_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(s_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 29;
            validate_non_negative_index("r", "N", N);
            vector_d r(static_cast<Eigen::VectorXd::Index>(N));
            (void) r;  // dummy to suppress unused var warning

            stan::math::initialize(r, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(r,DUMMY_VAR__);
            current_statement_begin__ = 30;
            validate_non_negative_index("s", "N", N);
            vector_d s(static_cast<Eigen::VectorXd::Index>(N));
            (void) s;  // dummy to suppress unused var warning

            stan::math::initialize(s, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(s,DUMMY_VAR__);
            current_statement_begin__ = 31;
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 33;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 34;
                stan::math::assign(get_base1_lhs(r,i,"r",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(r_pr,i,"r_pr",1)))));
                current_statement_begin__ = 35;
                stan::math::assign(get_base1_lhs(s,i,"s",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(s_pr,i,"s_pr",1)))) * 10));
                current_statement_begin__ = 36;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"r",r,0);
            check_less_or_equal(function__,"r",r,1);
            current_statement_begin__ = 30;
            check_greater_or_equal(function__,"s",s,0);
            check_less_or_equal(function__,"s",s,10);
            current_statement_begin__ = 31;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(r[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(s[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 65;
            double mu_r(0.0);
            (void) mu_r;  // dummy to suppress unused var warning

            stan::math::initialize(mu_r, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_r,DUMMY_VAR__);
            current_statement_begin__ = 66;
            double mu_s(0.0);
            (void) mu_s;  // dummy to suppress unused var warning

            stan::math::initialize(mu_s, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_s,DUMMY_VAR__);
            current_statement_begin__ = 67;
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            current_statement_begin__ = 70;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 73;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 76;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 77;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 78;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 82;
            stan::math::assign(mu_r, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 83;
            stan::math::assign(mu_s, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 10));
            current_statement_begin__ = 84;
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));

            current_statement_begin__ = 87;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 89;
                double ev_later(0.0);
                (void) ev_later;  // dummy to suppress unused var warning

                stan::math::initialize(ev_later, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_later,DUMMY_VAR__);
                current_statement_begin__ = 90;
                double ev_sooner(0.0);
                (void) ev_sooner;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sooner, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_sooner,DUMMY_VAR__);


                current_statement_begin__ = 92;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 94;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 95;
                    stan::math::assign(ev_later, (get_base1(get_base1(amount_later,i,"amount_later",1),t,"amount_later",2) * exp((-(1) * pow((get_base1(r,i,"r",1) * get_base1(get_base1(delay_later,i,"delay_later",1),t,"delay_later",2)),get_base1(s,i,"s",1))))));
                    current_statement_begin__ = 96;
                    stan::math::assign(ev_sooner, (get_base1(get_base1(amount_sooner,i,"amount_sooner",1),t,"amount_sooner",2) * exp((-(1) * pow((get_base1(r,i,"r",1) * get_base1(get_base1(delay_sooner,i,"delay_sooner",1),t,"delay_sooner",2)),get_base1(s,i,"s",1))))));
                    current_statement_begin__ = 97;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),(get_base1(beta,i,"beta",1) * (ev_later - ev_sooner)))));
                    current_statement_begin__ = 100;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(inv_logit((get_base1(beta,i,"beta",1) * (ev_later - ev_sooner))), base_rng__));
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 65;
            check_greater_or_equal(function__,"mu_r",mu_r,0);
            check_less_or_equal(function__,"mu_r",mu_r,1);
            current_statement_begin__ = 66;
            check_greater_or_equal(function__,"mu_s",mu_s,0);
            check_less_or_equal(function__,"mu_s",mu_s,10);
            current_statement_begin__ = 67;
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,5);
            current_statement_begin__ = 70;
            current_statement_begin__ = 73;

            // write generated quantities
        vars__.push_back(mu_r);
        vars__.push_back(mu_s);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_dd_cs";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_s";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_s";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_dd_cs_single_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_dd_cs_single");
    reader.add_event(60, 60, "end", "model_dd_cs_single");
    return reader;
}

class model_dd_cs_single : public prob_grad {
private:
    int Tsubj;
    vector<double> delay_later;
    vector<double> amount_later;
    vector<double> delay_sooner;
    vector<double> amount_sooner;
    vector<int> choice;
public:
    model_dd_cs_single(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_dd_cs_single(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_dd_cs_single_namespace::model_dd_cs_single";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec());
            Tsubj = int(0);
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            Tsubj = vals_i__[pos__++];
            current_statement_begin__ = 3;
            validate_non_negative_index("delay_later", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "delay_later", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("delay_later", "Tsubj", Tsubj);
            delay_later = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("delay_later");
            pos__ = 0;
            size_t delay_later_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < delay_later_limit_0__; ++i_0__) {
                delay_later[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 4;
            validate_non_negative_index("amount_later", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "amount_later", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("amount_later", "Tsubj", Tsubj);
            amount_later = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("amount_later");
            pos__ = 0;
            size_t amount_later_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < amount_later_limit_0__; ++i_0__) {
                amount_later[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("delay_sooner", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "delay_sooner", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("delay_sooner", "Tsubj", Tsubj);
            delay_sooner = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("delay_sooner");
            pos__ = 0;
            size_t delay_sooner_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < delay_sooner_limit_0__; ++i_0__) {
                delay_sooner[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("amount_sooner", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "amount_sooner", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("amount_sooner", "Tsubj", Tsubj);
            amount_sooner = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("amount_sooner");
            pos__ = 0;
            size_t amount_sooner_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < amount_sooner_limit_0__; ++i_0__) {
                amount_sooner[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("choice", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(Tsubj));
            validate_non_negative_index("choice", "Tsubj", Tsubj);
            choice = std::vector<int>(Tsubj,int(0));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                choice[i_0__] = vals_i__[pos__++];
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"Tsubj",Tsubj,1);
            current_statement_begin__ = 3;
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"delay_later[k0__]",delay_later[k0__],0);
            }
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"amount_later[k0__]",amount_later[k0__],0);
            }
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"delay_sooner[k0__]",delay_sooner[k0__],0);
            }
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"amount_sooner[k0__]",amount_sooner[k0__],0);
            }
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"choice[k0__]",choice[k0__],-(1));
                check_less_or_equal(function__,"choice[k0__]",choice[k0__],1);
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 14;
            ++num_params_r__;
            current_statement_begin__ = 15;
            ++num_params_r__;
            current_statement_begin__ = 16;
            ++num_params_r__;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_dd_cs_single() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("r")))
            throw std::runtime_error("variable r missing");
        vals_r__ = context__.vals_r("r");
        pos__ = 0U;
        context__.validate_dims("initialization", "r", "double", context__.to_vec());
        double r(0);
        r = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,r);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable r: ") + e.what());
        }

        if (!(context__.contains_r("s")))
            throw std::runtime_error("variable s missing");
        vals_r__ = context__.vals_r("s");
        pos__ = 0U;
        context__.validate_dims("initialization", "s", "double", context__.to_vec());
        double s(0);
        s = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,10,s);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable s: ") + e.what());
        }

        if (!(context__.contains_r("beta")))
            throw std::runtime_error("variable beta missing");
        vals_r__ = context__.vals_r("beta");
        pos__ = 0U;
        context__.validate_dims("initialization", "beta", "double", context__.to_vec());
        double beta(0);
        beta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,5,beta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ r;
            (void) r;  // dummy to suppress unused var warning
            if (jacobian__)
                r = in__.scalar_lub_constrain(0,1,lp__);
            else
                r = in__.scalar_lub_constrain(0,1);

            T__ s;
            (void) s;  // dummy to suppress unused var warning
            if (jacobian__)
                s = in__.scalar_lub_constrain(0,10,lp__);
            else
                s = in__.scalar_lub_constrain(0,10);

            T__ beta;
            (void) beta;  // dummy to suppress unused var warning
            if (jacobian__)
                beta = in__.scalar_lub_constrain(0,5,lp__);
            else
                beta = in__.scalar_lub_constrain(0,5);


            // transformed parameters
            current_statement_begin__ = 20;
            validate_non_negative_index("ev_later", "Tsubj", Tsubj);
            vector<T__> ev_later(Tsubj);
            stan::math::initialize(ev_later, DUMMY_VAR__);
            stan::math::fill(ev_later,DUMMY_VAR__);
            current_statement_begin__ = 21;
            validate_non_negative_index("ev_sooner", "Tsubj", Tsubj);
            vector<T__> ev_sooner(Tsubj);
            stan::math::initialize(ev_sooner, DUMMY_VAR__);
            stan::math::fill(ev_sooner,DUMMY_VAR__);


            current_statement_begin__ = 23;
            for (int t = 1; t <= Tsubj; ++t) {

                current_statement_begin__ = 24;
                stan::math::assign(get_base1_lhs(ev_later,t,"ev_later",1), (get_base1(amount_later,t,"amount_later",1) * exp((-(1) * pow((r * get_base1(delay_later,t,"delay_later",1)),s)))));
                current_statement_begin__ = 25;
                stan::math::assign(get_base1_lhs(ev_sooner,t,"ev_sooner",1), (get_base1(amount_sooner,t,"amount_sooner",1) * exp((-(1) * pow((r * get_base1(delay_sooner,t,"delay_sooner",1)),s)))));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < Tsubj; ++i0__) {
                if (stan::math::is_uninitialized(ev_later[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ev_later" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < Tsubj; ++i0__) {
                if (stan::math::is_uninitialized(ev_sooner[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ev_sooner" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 20;
            current_statement_begin__ = 21;

            // model body

            current_statement_begin__ = 32;
            lp_accum__.add(uniform_log<propto__>(r, 0, 1));
            current_statement_begin__ = 33;
            lp_accum__.add(uniform_log<propto__>(s, 0, 10));
            current_statement_begin__ = 34;
            lp_accum__.add(uniform_log<propto__>(beta, 0, 5));
            current_statement_begin__ = 36;
            for (int t = 1; t <= Tsubj; ++t) {

                current_statement_begin__ = 37;
                lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(choice,t,"choice",1), (beta * (get_base1(ev_later,t,"ev_later",1) - get_base1(ev_sooner,t,"ev_sooner",1)))));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("r");
        names__.push_back("s");
        names__.push_back("beta");
        names__.push_back("ev_later");
        names__.push_back("ev_sooner");
        names__.push_back("logR");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Tsubj);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Tsubj);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Tsubj);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_dd_cs_single_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double r = in__.scalar_lub_constrain(0,1);
        double s = in__.scalar_lub_constrain(0,10);
        double beta = in__.scalar_lub_constrain(0,5);
        vars__.push_back(r);
        vars__.push_back(s);
        vars__.push_back(beta);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 20;
            validate_non_negative_index("ev_later", "Tsubj", Tsubj);
            vector<double> ev_later(Tsubj, 0.0);
            stan::math::initialize(ev_later, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ev_later,DUMMY_VAR__);
            current_statement_begin__ = 21;
            validate_non_negative_index("ev_sooner", "Tsubj", Tsubj);
            vector<double> ev_sooner(Tsubj, 0.0);
            stan::math::initialize(ev_sooner, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ev_sooner,DUMMY_VAR__);


            current_statement_begin__ = 23;
            for (int t = 1; t <= Tsubj; ++t) {

                current_statement_begin__ = 24;
                stan::math::assign(get_base1_lhs(ev_later,t,"ev_later",1), (get_base1(amount_later,t,"amount_later",1) * exp((-(1) * pow((r * get_base1(delay_later,t,"delay_later",1)),s)))));
                current_statement_begin__ = 25;
                stan::math::assign(get_base1_lhs(ev_sooner,t,"ev_sooner",1), (get_base1(amount_sooner,t,"amount_sooner",1) * exp((-(1) * pow((r * get_base1(delay_sooner,t,"delay_sooner",1)),s)))));
            }

            // validate transformed parameters
            current_statement_begin__ = 20;
            current_statement_begin__ = 21;

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < Tsubj; ++k_0__) {
            vars__.push_back(ev_later[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < Tsubj; ++k_0__) {
            vars__.push_back(ev_sooner[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 42;
            double logR(0.0);
            (void) logR;  // dummy to suppress unused var warning

            stan::math::initialize(logR, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(logR,DUMMY_VAR__);
            current_statement_begin__ = 43;
            double log_lik(0.0);
            (void) log_lik;  // dummy to suppress unused var warning

            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 46;
            validate_non_negative_index("y_pred", "Tsubj", Tsubj);
            vector<double> y_pred(Tsubj, 0.0);
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 48;
            stan::math::assign(logR, log(r));

            current_statement_begin__ = 51;
            stan::math::assign(log_lik, 0);
            current_statement_begin__ = 53;
            for (int t = 1; t <= Tsubj; ++t) {

                current_statement_begin__ = 54;
                stan::math::assign(log_lik, (log_lik + bernoulli_logit_log(get_base1(choice,t,"choice",1),(beta * (get_base1(ev_later,t,"ev_later",1) - get_base1(ev_sooner,t,"ev_sooner",1))))));
                current_statement_begin__ = 57;
                stan::math::assign(get_base1_lhs(y_pred,t,"y_pred",1), bernoulli_rng(inv_logit((beta * (get_base1(ev_later,t,"ev_later",1) - get_base1(ev_sooner,t,"ev_sooner",1)))), base_rng__));
            }

            // validate generated quantities
            current_statement_begin__ = 42;
            current_statement_begin__ = 43;
            current_statement_begin__ = 46;

            // write generated quantities
        vars__.push_back(logR);
        vars__.push_back(log_lik);
            for (int k_0__ = 0; k_0__ < Tsubj; ++k_0__) {
            vars__.push_back(y_pred[k_0__]);
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_dd_cs_single";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "s";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_later" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_sooner" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "logR";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "y_pred" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "s";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_later" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_sooner" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "logR";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "y_pred" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_dd_exp_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_dd_exp");
    reader.add_event(98, 98, "end", "model_dd_exp");
    return reader;
}

class model_dd_exp : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > delay_later;
    vector<vector<double> > amount_later;
    vector<vector<double> > delay_sooner;
    vector<vector<double> > amount_sooner;
    vector<vector<int> > choice;
public:
    model_dd_exp(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_dd_exp(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_dd_exp_namespace::model_dd_exp";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("delay_later", "N", N);
            validate_non_negative_index("delay_later", "T", T);
            context__.validate_dims("data initialization", "delay_later", "double", context__.to_vec(N,T));
            validate_non_negative_index("delay_later", "N", N);
            validate_non_negative_index("delay_later", "T", T);
            delay_later = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("delay_later");
            pos__ = 0;
            size_t delay_later_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < delay_later_limit_1__; ++i_1__) {
                size_t delay_later_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < delay_later_limit_0__; ++i_0__) {
                    delay_later[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("amount_later", "N", N);
            validate_non_negative_index("amount_later", "T", T);
            context__.validate_dims("data initialization", "amount_later", "double", context__.to_vec(N,T));
            validate_non_negative_index("amount_later", "N", N);
            validate_non_negative_index("amount_later", "T", T);
            amount_later = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("amount_later");
            pos__ = 0;
            size_t amount_later_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < amount_later_limit_1__; ++i_1__) {
                size_t amount_later_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < amount_later_limit_0__; ++i_0__) {
                    amount_later[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("delay_sooner", "N", N);
            validate_non_negative_index("delay_sooner", "T", T);
            context__.validate_dims("data initialization", "delay_sooner", "double", context__.to_vec(N,T));
            validate_non_negative_index("delay_sooner", "N", N);
            validate_non_negative_index("delay_sooner", "T", T);
            delay_sooner = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("delay_sooner");
            pos__ = 0;
            size_t delay_sooner_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < delay_sooner_limit_1__; ++i_1__) {
                size_t delay_sooner_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < delay_sooner_limit_0__; ++i_0__) {
                    delay_sooner[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("amount_sooner", "N", N);
            validate_non_negative_index("amount_sooner", "T", T);
            context__.validate_dims("data initialization", "amount_sooner", "double", context__.to_vec(N,T));
            validate_non_negative_index("amount_sooner", "N", N);
            validate_non_negative_index("amount_sooner", "T", T);
            amount_sooner = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("amount_sooner");
            pos__ = 0;
            size_t amount_sooner_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < amount_sooner_limit_1__; ++i_1__) {
                size_t amount_sooner_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < amount_sooner_limit_0__; ++i_0__) {
                    amount_sooner[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 9;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"delay_later[k0__][k1__]",delay_later[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"amount_later[k0__][k1__]",amount_later[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"delay_sooner[k0__][k1__]",delay_sooner[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 8;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"amount_sooner[k0__][k1__]",amount_sooner[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 9;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],1);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 18;
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 19;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 22;
            validate_non_negative_index("r_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 23;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_dd_exp() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("r_pr")))
            throw std::runtime_error("variable r_pr missing");
        vals_r__ = context__.vals_r("r_pr");
        pos__ = 0U;
        validate_non_negative_index("r_pr", "N", N);
        context__.validate_dims("initialization", "r_pr", "vector_d", context__.to_vec(N));
        vector_d r_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            r_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(r_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable r_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  r_pr;
            (void) r_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                r_pr = in__.vector_constrain(N,lp__);
            else
                r_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 28;
            validate_non_negative_index("r", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  r(static_cast<Eigen::VectorXd::Index>(N));
            (void) r;  // dummy to suppress unused var warning

            stan::math::initialize(r, DUMMY_VAR__);
            stan::math::fill(r,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 31;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(r,i,"r",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(r_pr,i,"r_pr",1)))));
                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(r(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: r" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"r",r,0);
            check_less_or_equal(function__,"r",r,1);
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // model body

            current_statement_begin__ = 40;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 41;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 44;
            lp_accum__.add(normal_log<propto__>(r_pr, 0, 1));
            current_statement_begin__ = 45;
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            current_statement_begin__ = 47;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 49;
                T__ ev_later;
                (void) ev_later;  // dummy to suppress unused var warning

                stan::math::initialize(ev_later, DUMMY_VAR__);
                stan::math::fill(ev_later,DUMMY_VAR__);
                current_statement_begin__ = 50;
                T__ ev_sooner;
                (void) ev_sooner;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sooner, DUMMY_VAR__);
                stan::math::fill(ev_sooner,DUMMY_VAR__);


                current_statement_begin__ = 52;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 53;
                    stan::math::assign(ev_later, (get_base1(get_base1(amount_later,i,"amount_later",1),t,"amount_later",2) * exp(((-(1) * get_base1(r,i,"r",1)) * get_base1(get_base1(delay_later,i,"delay_later",1),t,"delay_later",2)))));
                    current_statement_begin__ = 54;
                    stan::math::assign(ev_sooner, (get_base1(get_base1(amount_sooner,i,"amount_sooner",1),t,"amount_sooner",2) * exp(((-(1) * get_base1(r,i,"r",1)) * get_base1(get_base1(delay_sooner,i,"delay_sooner",1),t,"delay_sooner",2)))));
                    current_statement_begin__ = 55;
                    lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), (get_base1(beta,i,"beta",1) * (ev_later - ev_sooner))));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("r_pr");
        names__.push_back("beta_pr");
        names__.push_back("r");
        names__.push_back("beta");
        names__.push_back("mu_r");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_dd_exp_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d r_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(r_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 28;
            validate_non_negative_index("r", "N", N);
            vector_d r(static_cast<Eigen::VectorXd::Index>(N));
            (void) r;  // dummy to suppress unused var warning

            stan::math::initialize(r, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(r,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 31;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(r,i,"r",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(r_pr,i,"r_pr",1)))));
                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"r",r,0);
            check_less_or_equal(function__,"r",r,1);
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(r[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 61;
            double mu_r(0.0);
            (void) mu_r;  // dummy to suppress unused var warning

            stan::math::initialize(mu_r, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_r,DUMMY_VAR__);
            current_statement_begin__ = 62;
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            current_statement_begin__ = 65;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 68;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 71;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 72;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 73;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 77;
            stan::math::assign(mu_r, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 78;
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 5));

            current_statement_begin__ = 81;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 83;
                double ev_later(0.0);
                (void) ev_later;  // dummy to suppress unused var warning

                stan::math::initialize(ev_later, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_later,DUMMY_VAR__);
                current_statement_begin__ = 84;
                double ev_sooner(0.0);
                (void) ev_sooner;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sooner, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_sooner,DUMMY_VAR__);


                current_statement_begin__ = 86;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 88;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 89;
                    stan::math::assign(ev_later, (get_base1(get_base1(amount_later,i,"amount_later",1),t,"amount_later",2) * exp(((-(1) * get_base1(r,i,"r",1)) * get_base1(get_base1(delay_later,i,"delay_later",1),t,"delay_later",2)))));
                    current_statement_begin__ = 90;
                    stan::math::assign(ev_sooner, (get_base1(get_base1(amount_sooner,i,"amount_sooner",1),t,"amount_sooner",2) * exp(((-(1) * get_base1(r,i,"r",1)) * get_base1(get_base1(delay_sooner,i,"delay_sooner",1),t,"delay_sooner",2)))));
                    current_statement_begin__ = 91;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),(get_base1(beta,i,"beta",1) * (ev_later - ev_sooner)))));
                    current_statement_begin__ = 94;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(inv_logit((get_base1(beta,i,"beta",1) * (ev_later - ev_sooner))), base_rng__));
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 61;
            check_greater_or_equal(function__,"mu_r",mu_r,0);
            check_less_or_equal(function__,"mu_r",mu_r,1);
            current_statement_begin__ = 62;
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,5);
            current_statement_begin__ = 65;
            current_statement_begin__ = 68;

            // write generated quantities
        vars__.push_back(mu_r);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_dd_exp";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "r" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_r";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_dd_hyperbolic_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_dd_hyperbolic");
    reader.add_event(98, 98, "end", "model_dd_hyperbolic");
    return reader;
}

class model_dd_hyperbolic : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > delay_later;
    vector<vector<double> > amount_later;
    vector<vector<double> > delay_sooner;
    vector<vector<double> > amount_sooner;
    vector<vector<int> > choice;
public:
    model_dd_hyperbolic(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_dd_hyperbolic(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_dd_hyperbolic_namespace::model_dd_hyperbolic";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("delay_later", "N", N);
            validate_non_negative_index("delay_later", "T", T);
            context__.validate_dims("data initialization", "delay_later", "double", context__.to_vec(N,T));
            validate_non_negative_index("delay_later", "N", N);
            validate_non_negative_index("delay_later", "T", T);
            delay_later = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("delay_later");
            pos__ = 0;
            size_t delay_later_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < delay_later_limit_1__; ++i_1__) {
                size_t delay_later_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < delay_later_limit_0__; ++i_0__) {
                    delay_later[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("amount_later", "N", N);
            validate_non_negative_index("amount_later", "T", T);
            context__.validate_dims("data initialization", "amount_later", "double", context__.to_vec(N,T));
            validate_non_negative_index("amount_later", "N", N);
            validate_non_negative_index("amount_later", "T", T);
            amount_later = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("amount_later");
            pos__ = 0;
            size_t amount_later_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < amount_later_limit_1__; ++i_1__) {
                size_t amount_later_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < amount_later_limit_0__; ++i_0__) {
                    amount_later[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("delay_sooner", "N", N);
            validate_non_negative_index("delay_sooner", "T", T);
            context__.validate_dims("data initialization", "delay_sooner", "double", context__.to_vec(N,T));
            validate_non_negative_index("delay_sooner", "N", N);
            validate_non_negative_index("delay_sooner", "T", T);
            delay_sooner = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("delay_sooner");
            pos__ = 0;
            size_t delay_sooner_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < delay_sooner_limit_1__; ++i_1__) {
                size_t delay_sooner_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < delay_sooner_limit_0__; ++i_0__) {
                    delay_sooner[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("amount_sooner", "N", N);
            validate_non_negative_index("amount_sooner", "T", T);
            context__.validate_dims("data initialization", "amount_sooner", "double", context__.to_vec(N,T));
            validate_non_negative_index("amount_sooner", "N", N);
            validate_non_negative_index("amount_sooner", "T", T);
            amount_sooner = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("amount_sooner");
            pos__ = 0;
            size_t amount_sooner_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < amount_sooner_limit_1__; ++i_1__) {
                size_t amount_sooner_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < amount_sooner_limit_0__; ++i_0__) {
                    amount_sooner[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 9;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"delay_later[k0__][k1__]",delay_later[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"amount_later[k0__][k1__]",amount_later[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"delay_sooner[k0__][k1__]",delay_sooner[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 8;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"amount_sooner[k0__][k1__]",amount_sooner[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 9;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],1);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 18;
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 19;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 22;
            validate_non_negative_index("k_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 23;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_dd_hyperbolic() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("k_pr")))
            throw std::runtime_error("variable k_pr missing");
        vals_r__ = context__.vals_r("k_pr");
        pos__ = 0U;
        validate_non_negative_index("k_pr", "N", N);
        context__.validate_dims("initialization", "k_pr", "vector_d", context__.to_vec(N));
        vector_d k_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            k_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(k_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable k_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  k_pr;
            (void) k_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                k_pr = in__.vector_constrain(N,lp__);
            else
                k_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 28;
            validate_non_negative_index("k", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  k(static_cast<Eigen::VectorXd::Index>(N));
            (void) k;  // dummy to suppress unused var warning

            stan::math::initialize(k, DUMMY_VAR__);
            stan::math::fill(k,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 31;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(k,i,"k",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(k_pr,i,"k_pr",1)))));
                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(k(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: k" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"k",k,0);
            check_less_or_equal(function__,"k",k,1);
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // model body

            current_statement_begin__ = 40;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 41;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 44;
            lp_accum__.add(normal_log<propto__>(k_pr, 0, 1));
            current_statement_begin__ = 45;
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            current_statement_begin__ = 47;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 49;
                T__ ev_later;
                (void) ev_later;  // dummy to suppress unused var warning

                stan::math::initialize(ev_later, DUMMY_VAR__);
                stan::math::fill(ev_later,DUMMY_VAR__);
                current_statement_begin__ = 50;
                T__ ev_sooner;
                (void) ev_sooner;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sooner, DUMMY_VAR__);
                stan::math::fill(ev_sooner,DUMMY_VAR__);


                current_statement_begin__ = 52;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 53;
                    stan::math::assign(ev_later, (get_base1(get_base1(amount_later,i,"amount_later",1),t,"amount_later",2) / (1 + (get_base1(k,i,"k",1) * get_base1(get_base1(delay_later,i,"delay_later",1),t,"delay_later",2)))));
                    current_statement_begin__ = 54;
                    stan::math::assign(ev_sooner, (get_base1(get_base1(amount_sooner,i,"amount_sooner",1),t,"amount_sooner",2) / (1 + (get_base1(k,i,"k",1) * get_base1(get_base1(delay_sooner,i,"delay_sooner",1),t,"delay_sooner",2)))));
                    current_statement_begin__ = 55;
                    lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), (get_base1(beta,i,"beta",1) * (ev_later - ev_sooner))));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("k_pr");
        names__.push_back("beta_pr");
        names__.push_back("k");
        names__.push_back("beta");
        names__.push_back("mu_k");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_dd_hyperbolic_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d k_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(k_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 28;
            validate_non_negative_index("k", "N", N);
            vector_d k(static_cast<Eigen::VectorXd::Index>(N));
            (void) k;  // dummy to suppress unused var warning

            stan::math::initialize(k, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(k,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 31;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(k,i,"k",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(k_pr,i,"k_pr",1)))));
                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"k",k,0);
            check_less_or_equal(function__,"k",k,1);
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(k[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 61;
            double mu_k(0.0);
            (void) mu_k;  // dummy to suppress unused var warning

            stan::math::initialize(mu_k, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_k,DUMMY_VAR__);
            current_statement_begin__ = 62;
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            current_statement_begin__ = 65;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 68;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 71;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 72;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 73;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 77;
            stan::math::assign(mu_k, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 78;
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 5));

            current_statement_begin__ = 81;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 83;
                double ev_later(0.0);
                (void) ev_later;  // dummy to suppress unused var warning

                stan::math::initialize(ev_later, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_later,DUMMY_VAR__);
                current_statement_begin__ = 84;
                double ev_sooner(0.0);
                (void) ev_sooner;  // dummy to suppress unused var warning

                stan::math::initialize(ev_sooner, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev_sooner,DUMMY_VAR__);


                current_statement_begin__ = 86;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 88;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 89;
                    stan::math::assign(ev_later, (get_base1(get_base1(amount_later,i,"amount_later",1),t,"amount_later",2) / (1 + (get_base1(k,i,"k",1) * get_base1(get_base1(delay_later,i,"delay_later",1),t,"delay_later",2)))));
                    current_statement_begin__ = 90;
                    stan::math::assign(ev_sooner, (get_base1(get_base1(amount_sooner,i,"amount_sooner",1),t,"amount_sooner",2) / (1 + (get_base1(k,i,"k",1) * get_base1(get_base1(delay_sooner,i,"delay_sooner",1),t,"delay_sooner",2)))));
                    current_statement_begin__ = 91;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),(get_base1(beta,i,"beta",1) * (ev_later - ev_sooner)))));
                    current_statement_begin__ = 94;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(inv_logit((get_base1(beta,i,"beta",1) * (ev_later - ev_sooner))), base_rng__));
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 61;
            check_greater_or_equal(function__,"mu_k",mu_k,0);
            check_less_or_equal(function__,"mu_k",mu_k,1);
            current_statement_begin__ = 62;
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,5);
            current_statement_begin__ = 65;
            current_statement_begin__ = 68;

            // write generated quantities
        vars__.push_back(mu_k);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_dd_hyperbolic";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "k_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "k" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_k";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "k_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "k" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_k";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_dd_hyperbolic_single_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_dd_hyperbolic_single");
    reader.add_event(54, 54, "end", "model_dd_hyperbolic_single");
    return reader;
}

class model_dd_hyperbolic_single : public prob_grad {
private:
    int Tsubj;
    vector<double> delay_later;
    vector<double> amount_later;
    vector<double> delay_sooner;
    vector<double> amount_sooner;
    vector<int> choice;
public:
    model_dd_hyperbolic_single(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_dd_hyperbolic_single(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_dd_hyperbolic_single_namespace::model_dd_hyperbolic_single";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec());
            Tsubj = int(0);
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            Tsubj = vals_i__[pos__++];
            current_statement_begin__ = 3;
            validate_non_negative_index("delay_later", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "delay_later", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("delay_later", "Tsubj", Tsubj);
            delay_later = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("delay_later");
            pos__ = 0;
            size_t delay_later_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < delay_later_limit_0__; ++i_0__) {
                delay_later[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 4;
            validate_non_negative_index("amount_later", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "amount_later", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("amount_later", "Tsubj", Tsubj);
            amount_later = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("amount_later");
            pos__ = 0;
            size_t amount_later_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < amount_later_limit_0__; ++i_0__) {
                amount_later[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("delay_sooner", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "delay_sooner", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("delay_sooner", "Tsubj", Tsubj);
            delay_sooner = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("delay_sooner");
            pos__ = 0;
            size_t delay_sooner_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < delay_sooner_limit_0__; ++i_0__) {
                delay_sooner[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("amount_sooner", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "amount_sooner", "double", context__.to_vec(Tsubj));
            validate_non_negative_index("amount_sooner", "Tsubj", Tsubj);
            amount_sooner = std::vector<double>(Tsubj,double(0));
            vals_r__ = context__.vals_r("amount_sooner");
            pos__ = 0;
            size_t amount_sooner_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < amount_sooner_limit_0__; ++i_0__) {
                amount_sooner[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("choice", "Tsubj", Tsubj);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(Tsubj));
            validate_non_negative_index("choice", "Tsubj", Tsubj);
            choice = std::vector<int>(Tsubj,int(0));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_0__ = Tsubj;
            for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                choice[i_0__] = vals_i__[pos__++];
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"Tsubj",Tsubj,1);
            current_statement_begin__ = 3;
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"delay_later[k0__]",delay_later[k0__],0);
            }
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"amount_later[k0__]",amount_later[k0__],0);
            }
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"delay_sooner[k0__]",delay_sooner[k0__],0);
            }
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"amount_sooner[k0__]",amount_sooner[k0__],0);
            }
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < Tsubj; ++k0__) {
                check_greater_or_equal(function__,"choice[k0__]",choice[k0__],-(1));
                check_less_or_equal(function__,"choice[k0__]",choice[k0__],1);
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 14;
            ++num_params_r__;
            current_statement_begin__ = 15;
            ++num_params_r__;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_dd_hyperbolic_single() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("k")))
            throw std::runtime_error("variable k missing");
        vals_r__ = context__.vals_r("k");
        pos__ = 0U;
        context__.validate_dims("initialization", "k", "double", context__.to_vec());
        double k(0);
        k = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,k);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable k: ") + e.what());
        }

        if (!(context__.contains_r("beta")))
            throw std::runtime_error("variable beta missing");
        vals_r__ = context__.vals_r("beta");
        pos__ = 0U;
        context__.validate_dims("initialization", "beta", "double", context__.to_vec());
        double beta(0);
        beta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,5,beta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ k;
            (void) k;  // dummy to suppress unused var warning
            if (jacobian__)
                k = in__.scalar_lub_constrain(0,1,lp__);
            else
                k = in__.scalar_lub_constrain(0,1);

            T__ beta;
            (void) beta;  // dummy to suppress unused var warning
            if (jacobian__)
                beta = in__.scalar_lub_constrain(0,5,lp__);
            else
                beta = in__.scalar_lub_constrain(0,5);


            // transformed parameters
            current_statement_begin__ = 19;
            validate_non_negative_index("ev_later", "Tsubj", Tsubj);
            vector<T__> ev_later(Tsubj);
            stan::math::initialize(ev_later, DUMMY_VAR__);
            stan::math::fill(ev_later,DUMMY_VAR__);
            current_statement_begin__ = 20;
            validate_non_negative_index("ev_sooner", "Tsubj", Tsubj);
            vector<T__> ev_sooner(Tsubj);
            stan::math::initialize(ev_sooner, DUMMY_VAR__);
            stan::math::fill(ev_sooner,DUMMY_VAR__);


            current_statement_begin__ = 22;
            for (int t = 1; t <= Tsubj; ++t) {

                current_statement_begin__ = 23;
                stan::math::assign(get_base1_lhs(ev_later,t,"ev_later",1), (get_base1(amount_later,t,"amount_later",1) / (1 + (k * get_base1(delay_later,t,"delay_later",1)))));
                current_statement_begin__ = 24;
                stan::math::assign(get_base1_lhs(ev_sooner,t,"ev_sooner",1), (get_base1(amount_sooner,t,"amount_sooner",1) / (1 + (k * get_base1(delay_sooner,t,"delay_sooner",1)))));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < Tsubj; ++i0__) {
                if (stan::math::is_uninitialized(ev_later[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ev_later" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < Tsubj; ++i0__) {
                if (stan::math::is_uninitialized(ev_sooner[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ev_sooner" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 19;
            current_statement_begin__ = 20;

            // model body

            current_statement_begin__ = 29;
            lp_accum__.add(uniform_log<propto__>(k, 0, 1));
            current_statement_begin__ = 30;
            lp_accum__.add(uniform_log<propto__>(beta, 0, 5));
            current_statement_begin__ = 32;
            for (int t = 1; t <= Tsubj; ++t) {

                current_statement_begin__ = 33;
                lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(choice,t,"choice",1), (beta * (get_base1(ev_later,t,"ev_later",1) - get_base1(ev_sooner,t,"ev_sooner",1)))));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("k");
        names__.push_back("beta");
        names__.push_back("ev_later");
        names__.push_back("ev_sooner");
        names__.push_back("logK");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Tsubj);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Tsubj);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Tsubj);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_dd_hyperbolic_single_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double k = in__.scalar_lub_constrain(0,1);
        double beta = in__.scalar_lub_constrain(0,5);
        vars__.push_back(k);
        vars__.push_back(beta);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 19;
            validate_non_negative_index("ev_later", "Tsubj", Tsubj);
            vector<double> ev_later(Tsubj, 0.0);
            stan::math::initialize(ev_later, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ev_later,DUMMY_VAR__);
            current_statement_begin__ = 20;
            validate_non_negative_index("ev_sooner", "Tsubj", Tsubj);
            vector<double> ev_sooner(Tsubj, 0.0);
            stan::math::initialize(ev_sooner, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ev_sooner,DUMMY_VAR__);


            current_statement_begin__ = 22;
            for (int t = 1; t <= Tsubj; ++t) {

                current_statement_begin__ = 23;
                stan::math::assign(get_base1_lhs(ev_later,t,"ev_later",1), (get_base1(amount_later,t,"amount_later",1) / (1 + (k * get_base1(delay_later,t,"delay_later",1)))));
                current_statement_begin__ = 24;
                stan::math::assign(get_base1_lhs(ev_sooner,t,"ev_sooner",1), (get_base1(amount_sooner,t,"amount_sooner",1) / (1 + (k * get_base1(delay_sooner,t,"delay_sooner",1)))));
            }

            // validate transformed parameters
            current_statement_begin__ = 19;
            current_statement_begin__ = 20;

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < Tsubj; ++k_0__) {
            vars__.push_back(ev_later[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < Tsubj; ++k_0__) {
            vars__.push_back(ev_sooner[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 37;
            double logK(0.0);
            (void) logK;  // dummy to suppress unused var warning

            stan::math::initialize(logK, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(logK,DUMMY_VAR__);
            current_statement_begin__ = 38;
            double log_lik(0.0);
            (void) log_lik;  // dummy to suppress unused var warning

            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 41;
            validate_non_negative_index("y_pred", "Tsubj", Tsubj);
            vector<double> y_pred(Tsubj, 0.0);
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 43;
            stan::math::assign(logK, log(k));

            current_statement_begin__ = 46;
            stan::math::assign(log_lik, 0);
            current_statement_begin__ = 47;
            for (int t = 1; t <= Tsubj; ++t) {

                current_statement_begin__ = 48;
                stan::math::assign(log_lik, (log_lik + bernoulli_logit_log(get_base1(choice,t,"choice",1),(beta * (get_base1(ev_later,t,"ev_later",1) - get_base1(ev_sooner,t,"ev_sooner",1))))));
                current_statement_begin__ = 51;
                stan::math::assign(get_base1_lhs(y_pred,t,"y_pred",1), bernoulli_rng(inv_logit((beta * (get_base1(ev_later,t,"ev_later",1) - get_base1(ev_sooner,t,"ev_sooner",1)))), base_rng__));
            }

            // validate generated quantities
            current_statement_begin__ = 37;
            current_statement_begin__ = 38;
            current_statement_begin__ = 41;

            // write generated quantities
        vars__.push_back(logK);
        vars__.push_back(log_lik);
            for (int k_0__ = 0; k_0__ < Tsubj; ++k_0__) {
            vars__.push_back(y_pred[k_0__]);
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_dd_hyperbolic_single";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "k";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_later" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_sooner" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "logK";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "y_pred" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "k";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_later" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ev_sooner" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "logK";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "log_lik";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= Tsubj; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "y_pred" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m1_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m1");
    reader.add_event(131, 131, "end", "model_gng_m1");
    return reader;
}

class model_gng_m1 : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m1(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m1(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m1_namespace::model_gng_m1";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            current_statement_begin__ = 11;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 12;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 11;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 17;
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 18;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 19;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 20;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 21;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m1() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 25;
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 26;
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);


            current_statement_begin__ = 29;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 30;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 31;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 33;
            stan::math::assign(rho, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),rho_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 25;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 26;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"rho",rho,0);

            // model body

            current_statement_begin__ = 39;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            current_statement_begin__ = 40;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5.0));
            current_statement_begin__ = 43;
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            current_statement_begin__ = 44;
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            current_statement_begin__ = 45;
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1.0));
            current_statement_begin__ = 47;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 48;
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 49;
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 50;
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 51;
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 52;
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 54;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 55;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 56;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 57;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 59;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 60;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    current_statement_begin__ = 61;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 62;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 63;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 64;
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    current_statement_begin__ = 67;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 68;
                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        current_statement_begin__ = 70;
                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("rho_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("rho");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_rho");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m1_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 25;
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 26;
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);


            current_statement_begin__ = 29;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 30;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 31;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 33;
            stan::math::assign(rho, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),rho_pr))));

            // validate transformed parameters
            current_statement_begin__ = 25;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 26;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"rho",rho,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 77;
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            current_statement_begin__ = 78;
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            current_statement_begin__ = 79;
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            current_statement_begin__ = 81;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 84;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 87;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 88;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 89;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 93;
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 94;
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 95;
            stan::math::assign(mu_rho, exp(get_base1(mu_p,3,"mu_p",1)));

            current_statement_begin__ = 98;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 99;
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 100;
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 101;
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 102;
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 103;
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 105;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 106;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 107;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 108;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 110;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 112;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 113;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    current_statement_begin__ = 114;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 115;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 116;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 117;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    current_statement_begin__ = 120;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    current_statement_begin__ = 123;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 124;
                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        current_statement_begin__ = 126;
                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 77;
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            current_statement_begin__ = 78;
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            current_statement_begin__ = 79;
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            current_statement_begin__ = 81;
            current_statement_begin__ = 84;

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_rho);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m1";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m1_reg_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m1_reg");
    reader.add_event(141, 141, "end", "model_gng_m1_reg");
    return reader;
}

class model_gng_m1_reg : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m1_reg(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m1_reg(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m1_reg_namespace::model_gng_m1_reg";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 4;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 5;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 4;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 6;
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            current_statement_begin__ = 8;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            current_statement_begin__ = 12;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 13;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 12;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 18;
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 19;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 20;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 21;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 22;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m1_reg() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 26;
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);


            current_statement_begin__ = 30;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 31;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 34;
            stan::math::assign(rho, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),rho_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 26;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"rho",rho,0);

            // model body

            current_statement_begin__ = 40;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            current_statement_begin__ = 41;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5.0));
            current_statement_begin__ = 44;
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            current_statement_begin__ = 45;
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            current_statement_begin__ = 46;
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1.0));
            current_statement_begin__ = 48;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 49;
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 50;
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 51;
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 52;
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 53;
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 55;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 56;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 57;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 58;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 60;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 61;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    current_statement_begin__ = 62;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 63;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 64;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 65;
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    current_statement_begin__ = 68;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 69;
                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        current_statement_begin__ = 71;
                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("rho_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("rho");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_rho");
        names__.push_back("log_lik");
        names__.push_back("Qgo");
        names__.push_back("Qnogo");
        names__.push_back("Wgo");
        names__.push_back("Wnogo");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m1_reg_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 26;
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);


            current_statement_begin__ = 30;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 31;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 34;
            stan::math::assign(rho, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),rho_pr))));

            // validate transformed parameters
            current_statement_begin__ = 26;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"rho",rho,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 78;
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            current_statement_begin__ = 79;
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            current_statement_begin__ = 80;
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            current_statement_begin__ = 81;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 82;
            validate_non_negative_index("Qgo", "N", N);
            validate_non_negative_index("Qgo", "T", T);
            vector<vector<double> > Qgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qgo,DUMMY_VAR__);
            current_statement_begin__ = 83;
            validate_non_negative_index("Qnogo", "N", N);
            validate_non_negative_index("Qnogo", "T", T);
            vector<vector<double> > Qnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qnogo,DUMMY_VAR__);
            current_statement_begin__ = 84;
            validate_non_negative_index("Wgo", "N", N);
            validate_non_negative_index("Wgo", "T", T);
            vector<vector<double> > Wgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wgo,DUMMY_VAR__);
            current_statement_begin__ = 85;
            validate_non_negative_index("Wnogo", "N", N);
            validate_non_negative_index("Wnogo", "T", T);
            vector<vector<double> > Wnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wnogo,DUMMY_VAR__);
            current_statement_begin__ = 88;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 91;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 92;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 93;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 97;
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 98;
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 99;
            stan::math::assign(mu_rho, exp(get_base1(mu_p,3,"mu_p",1)));

            current_statement_begin__ = 102;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 103;
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 104;
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 105;
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 106;
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 107;
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 109;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 110;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 111;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 112;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 114;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 116;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 117;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    current_statement_begin__ = 118;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 119;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 120;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 121;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    current_statement_begin__ = 124;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    current_statement_begin__ = 127;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qgo,i,"Qgo",1),t,"Qgo",2), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    current_statement_begin__ = 128;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qnogo,i,"Qnogo",1),t,"Qnogo",2), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 129;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wgo,i,"Wgo",1),t,"Wgo",2), get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1));
                    current_statement_begin__ = 130;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wnogo,i,"Wnogo",1),t,"Wnogo",2), get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1));
                    current_statement_begin__ = 133;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 134;
                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        current_statement_begin__ = 136;
                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 78;
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            current_statement_begin__ = 79;
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            current_statement_begin__ = 80;
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            current_statement_begin__ = 81;
            current_statement_begin__ = 82;
            current_statement_begin__ = 83;
            current_statement_begin__ = 84;
            current_statement_begin__ = 85;
            current_statement_begin__ = 88;

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_rho);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m1_reg";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m2_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m2");
    reader.add_event(140, 140, "end", "model_gng_m2");
    return reader;
}

class model_gng_m2 : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m2(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m2(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m2_namespace::model_gng_m2";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            current_statement_begin__ = 11;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 12;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 11;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 17;
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            current_statement_begin__ = 18;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            current_statement_begin__ = 19;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 20;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 21;
            validate_non_negative_index("b_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 22;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m2() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("b_pr")))
            throw std::runtime_error("variable b_pr missing");
        vals_r__ = context__.vals_r("b_pr");
        pos__ = 0U;
        validate_non_negative_index("b_pr", "N", N);
        context__.validate_dims("initialization", "b_pr", "vector_d", context__.to_vec(N));
        vector_d b_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            b_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(b_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable b_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  b_pr;
            (void) b_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                b_pr = in__.vector_constrain(N,lp__);
            else
                b_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 26;
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("b", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, DUMMY_VAR__);
            stan::math::fill(b,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);


            current_statement_begin__ = 31;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 35;
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            current_statement_begin__ = 36;
            stan::math::assign(rho, exp(add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),rho_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(b(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 26;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 28;
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"rho",rho,0);

            // model body

            current_statement_begin__ = 42;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 43;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 44;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 10.0));
            current_statement_begin__ = 45;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 46;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5.0));
            current_statement_begin__ = 49;
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            current_statement_begin__ = 50;
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            current_statement_begin__ = 51;
            lp_accum__.add(normal_log<propto__>(b_pr, 0, 1.0));
            current_statement_begin__ = 52;
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1.0));
            current_statement_begin__ = 54;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 55;
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 56;
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 57;
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 58;
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 59;
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 61;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 62;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 63;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 64;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 66;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 67;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)));
                    current_statement_begin__ = 68;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 69;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 70;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 71;
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    current_statement_begin__ = 74;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 75;
                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        current_statement_begin__ = 77;
                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("b_pr");
        names__.push_back("rho_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("b");
        names__.push_back("rho");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_b");
        names__.push_back("mu_rho");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m2_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d b_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 26;
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("b", "N", N);
            vector_d b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);


            current_statement_begin__ = 31;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 35;
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            current_statement_begin__ = 36;
            stan::math::assign(rho, exp(add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),rho_pr))));

            // validate transformed parameters
            current_statement_begin__ = 26;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 28;
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"rho",rho,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 84;
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            current_statement_begin__ = 85;
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            current_statement_begin__ = 86;
            double mu_b(0.0);
            (void) mu_b;  // dummy to suppress unused var warning

            stan::math::initialize(mu_b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_b,DUMMY_VAR__);
            current_statement_begin__ = 87;
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            current_statement_begin__ = 89;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 92;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 95;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 96;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 97;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 101;
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 102;
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 103;
            stan::math::assign(mu_b, get_base1(mu_p,3,"mu_p",1));
            current_statement_begin__ = 104;
            stan::math::assign(mu_rho, exp(get_base1(mu_p,4,"mu_p",1)));

            current_statement_begin__ = 107;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 108;
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 109;
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 110;
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 111;
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 112;
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 114;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 115;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 116;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 117;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 119;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 121;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 122;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)));
                    current_statement_begin__ = 123;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 124;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 125;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 126;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    current_statement_begin__ = 129;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    current_statement_begin__ = 132;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 133;
                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        current_statement_begin__ = 135;
                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 84;
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            current_statement_begin__ = 85;
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            current_statement_begin__ = 86;
            current_statement_begin__ = 87;
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            current_statement_begin__ = 89;
            current_statement_begin__ = 92;

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_b);
        vars__.push_back(mu_rho);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m2";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m2_reg_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m2_reg");
    reader.add_event(150, 150, "end", "model_gng_m2_reg");
    return reader;
}

class model_gng_m2_reg : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m2_reg(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m2_reg(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m2_reg_namespace::model_gng_m2_reg";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 4;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 5;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 4;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 6;
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            current_statement_begin__ = 8;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            current_statement_begin__ = 12;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 13;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 12;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 18;
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            current_statement_begin__ = 19;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            current_statement_begin__ = 20;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 21;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 22;
            validate_non_negative_index("b_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 23;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m2_reg() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("b_pr")))
            throw std::runtime_error("variable b_pr missing");
        vals_r__ = context__.vals_r("b_pr");
        pos__ = 0U;
        validate_non_negative_index("b_pr", "N", N);
        context__.validate_dims("initialization", "b_pr", "vector_d", context__.to_vec(N));
        vector_d b_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            b_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(b_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable b_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  b_pr;
            (void) b_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                b_pr = in__.vector_constrain(N,lp__);
            else
                b_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 27;
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("b", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, DUMMY_VAR__);
            stan::math::fill(b,DUMMY_VAR__);
            current_statement_begin__ = 30;
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);


            current_statement_begin__ = 32;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 34;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 36;
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            current_statement_begin__ = 37;
            stan::math::assign(rho, exp(add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),rho_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(b(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 29;
            current_statement_begin__ = 30;
            check_greater_or_equal(function__,"rho",rho,0);

            // model body

            current_statement_begin__ = 43;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 44;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 45;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 10.0));
            current_statement_begin__ = 46;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 47;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5.0));
            current_statement_begin__ = 50;
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            current_statement_begin__ = 51;
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            current_statement_begin__ = 52;
            lp_accum__.add(normal_log<propto__>(b_pr, 0, 1.0));
            current_statement_begin__ = 53;
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1.0));
            current_statement_begin__ = 55;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 56;
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 57;
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 58;
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 59;
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 60;
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 62;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 63;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 64;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 65;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 67;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 68;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)));
                    current_statement_begin__ = 69;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 70;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 71;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 72;
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    current_statement_begin__ = 75;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 76;
                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        current_statement_begin__ = 78;
                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("b_pr");
        names__.push_back("rho_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("b");
        names__.push_back("rho");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_b");
        names__.push_back("mu_rho");
        names__.push_back("log_lik");
        names__.push_back("Qgo");
        names__.push_back("Qnogo");
        names__.push_back("Wgo");
        names__.push_back("Wnogo");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m2_reg_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d b_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 27;
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("b", "N", N);
            vector_d b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b,DUMMY_VAR__);
            current_statement_begin__ = 30;
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);


            current_statement_begin__ = 32;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 34;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 36;
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            current_statement_begin__ = 37;
            stan::math::assign(rho, exp(add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),rho_pr))));

            // validate transformed parameters
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 29;
            current_statement_begin__ = 30;
            check_greater_or_equal(function__,"rho",rho,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 85;
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            current_statement_begin__ = 86;
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            current_statement_begin__ = 87;
            double mu_b(0.0);
            (void) mu_b;  // dummy to suppress unused var warning

            stan::math::initialize(mu_b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_b,DUMMY_VAR__);
            current_statement_begin__ = 88;
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            current_statement_begin__ = 89;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 90;
            validate_non_negative_index("Qgo", "N", N);
            validate_non_negative_index("Qgo", "T", T);
            vector<vector<double> > Qgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qgo,DUMMY_VAR__);
            current_statement_begin__ = 91;
            validate_non_negative_index("Qnogo", "N", N);
            validate_non_negative_index("Qnogo", "T", T);
            vector<vector<double> > Qnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qnogo,DUMMY_VAR__);
            current_statement_begin__ = 92;
            validate_non_negative_index("Wgo", "N", N);
            validate_non_negative_index("Wgo", "T", T);
            vector<vector<double> > Wgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wgo,DUMMY_VAR__);
            current_statement_begin__ = 93;
            validate_non_negative_index("Wnogo", "N", N);
            validate_non_negative_index("Wnogo", "T", T);
            vector<vector<double> > Wnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wnogo,DUMMY_VAR__);
            current_statement_begin__ = 96;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 99;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 100;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 101;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 105;
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 106;
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 107;
            stan::math::assign(mu_b, get_base1(mu_p,3,"mu_p",1));
            current_statement_begin__ = 108;
            stan::math::assign(mu_rho, exp(get_base1(mu_p,4,"mu_p",1)));

            current_statement_begin__ = 111;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 112;
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 113;
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 114;
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 115;
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 116;
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 118;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 119;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 120;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 121;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 123;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 125;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 126;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)));
                    current_statement_begin__ = 127;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 128;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 129;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 130;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    current_statement_begin__ = 133;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    current_statement_begin__ = 136;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qgo,i,"Qgo",1),t,"Qgo",2), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    current_statement_begin__ = 137;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qnogo,i,"Qnogo",1),t,"Qnogo",2), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 138;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wgo,i,"Wgo",1),t,"Wgo",2), get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1));
                    current_statement_begin__ = 139;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wnogo,i,"Wnogo",1),t,"Wnogo",2), get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1));
                    current_statement_begin__ = 142;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 143;
                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        current_statement_begin__ = 145;
                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 85;
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            current_statement_begin__ = 86;
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            current_statement_begin__ = 87;
            current_statement_begin__ = 88;
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            current_statement_begin__ = 89;
            current_statement_begin__ = 90;
            current_statement_begin__ = 91;
            current_statement_begin__ = 92;
            current_statement_begin__ = 93;
            current_statement_begin__ = 96;

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_b);
        vars__.push_back(mu_rho);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m2_reg";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m3_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m3");
    reader.add_event(157, 157, "end", "model_gng_m3");
    return reader;
}

class model_gng_m3 : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m3(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m3(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m3_namespace::model_gng_m3";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            current_statement_begin__ = 11;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 12;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 11;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 17;
            validate_non_negative_index("mu_p", "5", 5);
            num_params_r__ += 5;
            current_statement_begin__ = 18;
            validate_non_negative_index("sigma", "5", 5);
            num_params_r__ += 5;
            current_statement_begin__ = 19;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 20;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 21;
            validate_non_negative_index("b_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 22;
            validate_non_negative_index("pi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 23;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m3() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "5", 5);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(5));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "5", 5);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(5));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("b_pr")))
            throw std::runtime_error("variable b_pr missing");
        vals_r__ = context__.vals_r("b_pr");
        pos__ = 0U;
        validate_non_negative_index("b_pr", "N", N);
        context__.validate_dims("initialization", "b_pr", "vector_d", context__.to_vec(N));
        vector_d b_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            b_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(b_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable b_pr: ") + e.what());
        }

        if (!(context__.contains_r("pi_pr")))
            throw std::runtime_error("variable pi_pr missing");
        vals_r__ = context__.vals_r("pi_pr");
        pos__ = 0U;
        validate_non_negative_index("pi_pr", "N", N);
        context__.validate_dims("initialization", "pi_pr", "vector_d", context__.to_vec(N));
        vector_d pi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            pi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(pi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable pi_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(5,lp__);
            else
                mu_p = in__.vector_constrain(5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,5,lp__);
            else
                sigma = in__.vector_lb_constrain(0,5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  b_pr;
            (void) b_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                b_pr = in__.vector_constrain(N,lp__);
            else
                b_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi_pr;
            (void) pi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                pi_pr = in__.vector_constrain(N,lp__);
            else
                pi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 27;
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("b", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, DUMMY_VAR__);
            stan::math::fill(b,DUMMY_VAR__);
            current_statement_begin__ = 30;
            validate_non_negative_index("pi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, DUMMY_VAR__);
            stan::math::fill(pi,DUMMY_VAR__);
            current_statement_begin__ = 31;
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);


            current_statement_begin__ = 33;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 34;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 35;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 37;
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            current_statement_begin__ = 38;
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            current_statement_begin__ = 39;
            stan::math::assign(rho, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rho_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(b(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 29;
            current_statement_begin__ = 30;
            current_statement_begin__ = 31;
            check_greater_or_equal(function__,"rho",rho,0);

            // model body

            current_statement_begin__ = 45;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 46;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 47;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 10.0));
            current_statement_begin__ = 48;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 10.0));
            current_statement_begin__ = 49;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,5,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 50;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5.0));
            current_statement_begin__ = 53;
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            current_statement_begin__ = 54;
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            current_statement_begin__ = 55;
            lp_accum__.add(normal_log<propto__>(b_pr, 0, 1.0));
            current_statement_begin__ = 56;
            lp_accum__.add(normal_log<propto__>(pi_pr, 0, 1.0));
            current_statement_begin__ = 57;
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1.0));
            current_statement_begin__ = 59;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 60;
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 61;
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 62;
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 63;
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 64;
                validate_non_negative_index("sv", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, DUMMY_VAR__);
                stan::math::fill(sv,DUMMY_VAR__);
                current_statement_begin__ = 65;
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 67;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 68;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 69;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 70;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 71;
                stan::math::assign(sv, initV);
                current_statement_begin__ = 73;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 74;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    current_statement_begin__ = 75;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 76;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 77;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 78;
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    current_statement_begin__ = 81;
                    stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    current_statement_begin__ = 84;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 85;
                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        current_statement_begin__ = 87;
                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("b_pr");
        names__.push_back("pi_pr");
        names__.push_back("rho_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("b");
        names__.push_back("pi");
        names__.push_back("rho");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_b");
        names__.push_back("mu_pi");
        names__.push_back("mu_rho");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m3_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(5);
        vector_d sigma = in__.vector_lb_constrain(0,5);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d b_pr = in__.vector_constrain(N);
        vector_d pi_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 27;
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("b", "N", N);
            vector_d b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b,DUMMY_VAR__);
            current_statement_begin__ = 30;
            validate_non_negative_index("pi", "N", N);
            vector_d pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pi,DUMMY_VAR__);
            current_statement_begin__ = 31;
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);


            current_statement_begin__ = 33;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 34;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 35;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 37;
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            current_statement_begin__ = 38;
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            current_statement_begin__ = 39;
            stan::math::assign(rho, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rho_pr))));

            // validate transformed parameters
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 29;
            current_statement_begin__ = 30;
            current_statement_begin__ = 31;
            check_greater_or_equal(function__,"rho",rho,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 94;
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            current_statement_begin__ = 95;
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            current_statement_begin__ = 96;
            double mu_b(0.0);
            (void) mu_b;  // dummy to suppress unused var warning

            stan::math::initialize(mu_b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_b,DUMMY_VAR__);
            current_statement_begin__ = 97;
            double mu_pi(0.0);
            (void) mu_pi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_pi,DUMMY_VAR__);
            current_statement_begin__ = 98;
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            current_statement_begin__ = 100;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 103;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 106;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 107;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 108;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 112;
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 113;
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 114;
            stan::math::assign(mu_b, get_base1(mu_p,3,"mu_p",1));
            current_statement_begin__ = 115;
            stan::math::assign(mu_pi, get_base1(mu_p,4,"mu_p",1));
            current_statement_begin__ = 116;
            stan::math::assign(mu_rho, exp(get_base1(mu_p,5,"mu_p",1)));

            current_statement_begin__ = 119;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 120;
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 121;
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 122;
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 123;
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 124;
                validate_non_negative_index("sv", "4", 4);
                vector_d sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sv,DUMMY_VAR__);
                current_statement_begin__ = 125;
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 127;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 128;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 129;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 130;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 131;
                stan::math::assign(sv, initV);
                current_statement_begin__ = 133;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 135;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 136;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    current_statement_begin__ = 137;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 138;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 139;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 140;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    current_statement_begin__ = 143;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    current_statement_begin__ = 146;
                    stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    current_statement_begin__ = 149;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 150;
                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        current_statement_begin__ = 152;
                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 94;
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            current_statement_begin__ = 95;
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            current_statement_begin__ = 96;
            current_statement_begin__ = 97;
            current_statement_begin__ = 98;
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            current_statement_begin__ = 100;
            current_statement_begin__ = 103;

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_b);
        vars__.push_back(mu_pi);
        vars__.push_back(mu_rho);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m3";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m3_reg_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m3_reg");
    reader.add_event(169, 169, "end", "model_gng_m3_reg");
    return reader;
}

class model_gng_m3_reg : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m3_reg(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m3_reg(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m3_reg_namespace::model_gng_m3_reg";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 4;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 5;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 4;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 6;
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            current_statement_begin__ = 8;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            current_statement_begin__ = 12;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 13;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 12;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 18;
            validate_non_negative_index("mu_p", "5", 5);
            num_params_r__ += 5;
            current_statement_begin__ = 19;
            validate_non_negative_index("sigma", "5", 5);
            num_params_r__ += 5;
            current_statement_begin__ = 20;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 21;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 22;
            validate_non_negative_index("b_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 23;
            validate_non_negative_index("pi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 24;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m3_reg() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "5", 5);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(5));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "5", 5);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(5));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(5));
        for (int j1__ = 0U; j1__ < 5; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("b_pr")))
            throw std::runtime_error("variable b_pr missing");
        vals_r__ = context__.vals_r("b_pr");
        pos__ = 0U;
        validate_non_negative_index("b_pr", "N", N);
        context__.validate_dims("initialization", "b_pr", "vector_d", context__.to_vec(N));
        vector_d b_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            b_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(b_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable b_pr: ") + e.what());
        }

        if (!(context__.contains_r("pi_pr")))
            throw std::runtime_error("variable pi_pr missing");
        vals_r__ = context__.vals_r("pi_pr");
        pos__ = 0U;
        validate_non_negative_index("pi_pr", "N", N);
        context__.validate_dims("initialization", "pi_pr", "vector_d", context__.to_vec(N));
        vector_d pi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            pi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(pi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable pi_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(5,lp__);
            else
                mu_p = in__.vector_constrain(5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,5,lp__);
            else
                sigma = in__.vector_lb_constrain(0,5);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  b_pr;
            (void) b_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                b_pr = in__.vector_constrain(N,lp__);
            else
                b_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi_pr;
            (void) pi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                pi_pr = in__.vector_constrain(N,lp__);
            else
                pi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 28;
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 30;
            validate_non_negative_index("b", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, DUMMY_VAR__);
            stan::math::fill(b,DUMMY_VAR__);
            current_statement_begin__ = 31;
            validate_non_negative_index("pi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, DUMMY_VAR__);
            stan::math::fill(pi,DUMMY_VAR__);
            current_statement_begin__ = 32;
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);


            current_statement_begin__ = 34;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 35;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 36;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 38;
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            current_statement_begin__ = 39;
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            current_statement_begin__ = 40;
            stan::math::assign(rho, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rho_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(b(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 30;
            current_statement_begin__ = 31;
            current_statement_begin__ = 32;
            check_greater_or_equal(function__,"rho",rho,0);

            // model body

            current_statement_begin__ = 46;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 47;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 48;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 10.0));
            current_statement_begin__ = 49;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 10.0));
            current_statement_begin__ = 50;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,5,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 51;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5.0));
            current_statement_begin__ = 54;
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            current_statement_begin__ = 55;
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            current_statement_begin__ = 56;
            lp_accum__.add(normal_log<propto__>(b_pr, 0, 1.0));
            current_statement_begin__ = 57;
            lp_accum__.add(normal_log<propto__>(pi_pr, 0, 1.0));
            current_statement_begin__ = 58;
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1.0));
            current_statement_begin__ = 60;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 61;
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 62;
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 63;
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 64;
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 65;
                validate_non_negative_index("sv", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, DUMMY_VAR__);
                stan::math::fill(sv,DUMMY_VAR__);
                current_statement_begin__ = 66;
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 68;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 69;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 70;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 71;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 72;
                stan::math::assign(sv, initV);
                current_statement_begin__ = 74;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 75;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    current_statement_begin__ = 76;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 77;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 78;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 79;
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    current_statement_begin__ = 82;
                    stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    current_statement_begin__ = 85;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 86;
                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        current_statement_begin__ = 88;
                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("b_pr");
        names__.push_back("pi_pr");
        names__.push_back("rho_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("b");
        names__.push_back("pi");
        names__.push_back("rho");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_b");
        names__.push_back("mu_pi");
        names__.push_back("mu_rho");
        names__.push_back("log_lik");
        names__.push_back("Qgo");
        names__.push_back("Qnogo");
        names__.push_back("Wgo");
        names__.push_back("Wnogo");
        names__.push_back("SV");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(5);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m3_reg_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(5);
        vector_d sigma = in__.vector_lb_constrain(0,5);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d b_pr = in__.vector_constrain(N);
        vector_d pi_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 5; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 28;
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 30;
            validate_non_negative_index("b", "N", N);
            vector_d b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b,DUMMY_VAR__);
            current_statement_begin__ = 31;
            validate_non_negative_index("pi", "N", N);
            vector_d pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pi,DUMMY_VAR__);
            current_statement_begin__ = 32;
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);


            current_statement_begin__ = 34;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 35;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 36;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 38;
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            current_statement_begin__ = 39;
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            current_statement_begin__ = 40;
            stan::math::assign(rho, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rho_pr))));

            // validate transformed parameters
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 30;
            current_statement_begin__ = 31;
            current_statement_begin__ = 32;
            check_greater_or_equal(function__,"rho",rho,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 95;
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            current_statement_begin__ = 96;
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            current_statement_begin__ = 97;
            double mu_b(0.0);
            (void) mu_b;  // dummy to suppress unused var warning

            stan::math::initialize(mu_b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_b,DUMMY_VAR__);
            current_statement_begin__ = 98;
            double mu_pi(0.0);
            (void) mu_pi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_pi,DUMMY_VAR__);
            current_statement_begin__ = 99;
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            current_statement_begin__ = 100;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 101;
            validate_non_negative_index("Qgo", "N", N);
            validate_non_negative_index("Qgo", "T", T);
            vector<vector<double> > Qgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qgo,DUMMY_VAR__);
            current_statement_begin__ = 102;
            validate_non_negative_index("Qnogo", "N", N);
            validate_non_negative_index("Qnogo", "T", T);
            vector<vector<double> > Qnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qnogo,DUMMY_VAR__);
            current_statement_begin__ = 103;
            validate_non_negative_index("Wgo", "N", N);
            validate_non_negative_index("Wgo", "T", T);
            vector<vector<double> > Wgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wgo,DUMMY_VAR__);
            current_statement_begin__ = 104;
            validate_non_negative_index("Wnogo", "N", N);
            validate_non_negative_index("Wnogo", "T", T);
            vector<vector<double> > Wnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wnogo,DUMMY_VAR__);
            current_statement_begin__ = 105;
            validate_non_negative_index("SV", "N", N);
            validate_non_negative_index("SV", "T", T);
            vector<vector<double> > SV(N, (vector<double>(T, 0.0)));
            stan::math::initialize(SV, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(SV,DUMMY_VAR__);
            current_statement_begin__ = 108;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 111;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 112;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 113;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 117;
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 118;
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 119;
            stan::math::assign(mu_b, get_base1(mu_p,3,"mu_p",1));
            current_statement_begin__ = 120;
            stan::math::assign(mu_pi, get_base1(mu_p,4,"mu_p",1));
            current_statement_begin__ = 121;
            stan::math::assign(mu_rho, exp(get_base1(mu_p,5,"mu_p",1)));

            current_statement_begin__ = 124;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 125;
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 126;
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 127;
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 128;
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 129;
                validate_non_negative_index("sv", "4", 4);
                vector_d sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sv,DUMMY_VAR__);
                current_statement_begin__ = 130;
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 132;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 133;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 134;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 135;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 136;
                stan::math::assign(sv, initV);
                current_statement_begin__ = 138;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 140;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 141;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    current_statement_begin__ = 142;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 143;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 144;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 145;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    current_statement_begin__ = 148;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    current_statement_begin__ = 151;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qgo,i,"Qgo",1),t,"Qgo",2), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    current_statement_begin__ = 152;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qnogo,i,"Qnogo",1),t,"Qnogo",2), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 153;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wgo,i,"Wgo",1),t,"Wgo",2), get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1));
                    current_statement_begin__ = 154;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wnogo,i,"Wnogo",1),t,"Wnogo",2), get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1));
                    current_statement_begin__ = 155;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(SV,i,"SV",1),t,"SV",2), get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1));
                    current_statement_begin__ = 158;
                    stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    current_statement_begin__ = 161;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 162;
                        stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                    } else {

                        current_statement_begin__ = 164;
                        stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rho,i,"rho",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                    }
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 95;
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            current_statement_begin__ = 96;
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            current_statement_begin__ = 97;
            current_statement_begin__ = 98;
            current_statement_begin__ = 99;
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            current_statement_begin__ = 100;
            current_statement_begin__ = 101;
            current_statement_begin__ = 102;
            current_statement_begin__ = 103;
            current_statement_begin__ = 104;
            current_statement_begin__ = 105;
            current_statement_begin__ = 108;

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_b);
        vars__.push_back(mu_pi);
        vars__.push_back(mu_rho);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(SV[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m3_reg";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "SV" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 5; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "SV" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m4_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m4");
    reader.add_event(188, 188, "end", "model_gng_m4");
    return reader;
}

class model_gng_m4 : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m4(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m4(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m4_namespace::model_gng_m4";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            current_statement_begin__ = 11;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 12;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 11;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 17;
            validate_non_negative_index("mu_p", "6", 6);
            num_params_r__ += 6;
            current_statement_begin__ = 18;
            validate_non_negative_index("sigma", "6", 6);
            num_params_r__ += 6;
            current_statement_begin__ = 19;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 20;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 21;
            validate_non_negative_index("b_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 22;
            validate_non_negative_index("pi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 23;
            validate_non_negative_index("rhoRew_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 24;
            validate_non_negative_index("rhoPun_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m4() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "6", 6);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(6));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(6));
        for (int j1__ = 0U; j1__ < 6; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "6", 6);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(6));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(6));
        for (int j1__ = 0U; j1__ < 6; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("b_pr")))
            throw std::runtime_error("variable b_pr missing");
        vals_r__ = context__.vals_r("b_pr");
        pos__ = 0U;
        validate_non_negative_index("b_pr", "N", N);
        context__.validate_dims("initialization", "b_pr", "vector_d", context__.to_vec(N));
        vector_d b_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            b_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(b_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable b_pr: ") + e.what());
        }

        if (!(context__.contains_r("pi_pr")))
            throw std::runtime_error("variable pi_pr missing");
        vals_r__ = context__.vals_r("pi_pr");
        pos__ = 0U;
        validate_non_negative_index("pi_pr", "N", N);
        context__.validate_dims("initialization", "pi_pr", "vector_d", context__.to_vec(N));
        vector_d pi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            pi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(pi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable pi_pr: ") + e.what());
        }

        if (!(context__.contains_r("rhoRew_pr")))
            throw std::runtime_error("variable rhoRew_pr missing");
        vals_r__ = context__.vals_r("rhoRew_pr");
        pos__ = 0U;
        validate_non_negative_index("rhoRew_pr", "N", N);
        context__.validate_dims("initialization", "rhoRew_pr", "vector_d", context__.to_vec(N));
        vector_d rhoRew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rhoRew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rhoRew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rhoRew_pr: ") + e.what());
        }

        if (!(context__.contains_r("rhoPun_pr")))
            throw std::runtime_error("variable rhoPun_pr missing");
        vals_r__ = context__.vals_r("rhoPun_pr");
        pos__ = 0U;
        validate_non_negative_index("rhoPun_pr", "N", N);
        context__.validate_dims("initialization", "rhoPun_pr", "vector_d", context__.to_vec(N));
        vector_d rhoPun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rhoPun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rhoPun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rhoPun_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(6,lp__);
            else
                mu_p = in__.vector_constrain(6);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,6,lp__);
            else
                sigma = in__.vector_lb_constrain(0,6);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  b_pr;
            (void) b_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                b_pr = in__.vector_constrain(N,lp__);
            else
                b_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi_pr;
            (void) pi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                pi_pr = in__.vector_constrain(N,lp__);
            else
                pi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoRew_pr;
            (void) rhoRew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rhoRew_pr = in__.vector_constrain(N,lp__);
            else
                rhoRew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoPun_pr;
            (void) rhoPun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rhoPun_pr = in__.vector_constrain(N,lp__);
            else
                rhoPun_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 28;
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 30;
            validate_non_negative_index("b", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, DUMMY_VAR__);
            stan::math::fill(b,DUMMY_VAR__);
            current_statement_begin__ = 31;
            validate_non_negative_index("pi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, DUMMY_VAR__);
            stan::math::fill(pi,DUMMY_VAR__);
            current_statement_begin__ = 32;
            validate_non_negative_index("rhoRew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoRew(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoRew;  // dummy to suppress unused var warning

            stan::math::initialize(rhoRew, DUMMY_VAR__);
            stan::math::fill(rhoRew,DUMMY_VAR__);
            current_statement_begin__ = 33;
            validate_non_negative_index("rhoPun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoPun(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoPun;  // dummy to suppress unused var warning

            stan::math::initialize(rhoPun, DUMMY_VAR__);
            stan::math::fill(rhoPun,DUMMY_VAR__);


            current_statement_begin__ = 35;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 36;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 37;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 39;
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            current_statement_begin__ = 40;
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            current_statement_begin__ = 41;
            stan::math::assign(rhoRew, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rhoRew_pr))));
            current_statement_begin__ = 42;
            stan::math::assign(rhoPun, exp(add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),rhoPun_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(b(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rhoRew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rhoRew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rhoPun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rhoPun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 30;
            current_statement_begin__ = 31;
            current_statement_begin__ = 32;
            check_greater_or_equal(function__,"rhoRew",rhoRew,0);
            current_statement_begin__ = 33;
            check_greater_or_equal(function__,"rhoPun",rhoPun,0);

            // model body

            current_statement_begin__ = 48;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 49;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 50;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 10.0));
            current_statement_begin__ = 51;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 10.0));
            current_statement_begin__ = 52;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,5,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 53;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,6,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 54;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5.0));
            current_statement_begin__ = 57;
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            current_statement_begin__ = 58;
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            current_statement_begin__ = 59;
            lp_accum__.add(normal_log<propto__>(b_pr, 0, 1.0));
            current_statement_begin__ = 60;
            lp_accum__.add(normal_log<propto__>(pi_pr, 0, 1.0));
            current_statement_begin__ = 61;
            lp_accum__.add(normal_log<propto__>(rhoRew_pr, 0, 1.0));
            current_statement_begin__ = 62;
            lp_accum__.add(normal_log<propto__>(rhoPun_pr, 0, 1.0));
            current_statement_begin__ = 64;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 65;
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 66;
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 67;
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 68;
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 69;
                validate_non_negative_index("sv", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, DUMMY_VAR__);
                stan::math::fill(sv,DUMMY_VAR__);
                current_statement_begin__ = 70;
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 72;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 73;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 74;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 75;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 76;
                stan::math::assign(sv, initV);
                current_statement_begin__ = 78;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 79;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    current_statement_begin__ = 80;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 81;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 82;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 83;
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    current_statement_begin__ = 86;
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        current_statement_begin__ = 87;
                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    } else {

                        current_statement_begin__ = 89;
                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    }
                    current_statement_begin__ = 93;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 94;
                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            current_statement_begin__ = 95;
                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        } else {

                            current_statement_begin__ = 97;
                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        }
                    } else {

                        current_statement_begin__ = 100;
                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            current_statement_begin__ = 101;
                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        } else {

                            current_statement_begin__ = 103;
                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        }
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("b_pr");
        names__.push_back("pi_pr");
        names__.push_back("rhoRew_pr");
        names__.push_back("rhoPun_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("b");
        names__.push_back("pi");
        names__.push_back("rhoRew");
        names__.push_back("rhoPun");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_b");
        names__.push_back("mu_pi");
        names__.push_back("mu_rhoRew");
        names__.push_back("mu_rhoPun");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(6);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(6);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m4_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(6);
        vector_d sigma = in__.vector_lb_constrain(0,6);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d b_pr = in__.vector_constrain(N);
        vector_d pi_pr = in__.vector_constrain(N);
        vector_d rhoRew_pr = in__.vector_constrain(N);
        vector_d rhoPun_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 6; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 6; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoRew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoPun_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 28;
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 30;
            validate_non_negative_index("b", "N", N);
            vector_d b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b,DUMMY_VAR__);
            current_statement_begin__ = 31;
            validate_non_negative_index("pi", "N", N);
            vector_d pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pi,DUMMY_VAR__);
            current_statement_begin__ = 32;
            validate_non_negative_index("rhoRew", "N", N);
            vector_d rhoRew(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoRew;  // dummy to suppress unused var warning

            stan::math::initialize(rhoRew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rhoRew,DUMMY_VAR__);
            current_statement_begin__ = 33;
            validate_non_negative_index("rhoPun", "N", N);
            vector_d rhoPun(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoPun;  // dummy to suppress unused var warning

            stan::math::initialize(rhoPun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rhoPun,DUMMY_VAR__);


            current_statement_begin__ = 35;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 36;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 37;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 39;
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            current_statement_begin__ = 40;
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            current_statement_begin__ = 41;
            stan::math::assign(rhoRew, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rhoRew_pr))));
            current_statement_begin__ = 42;
            stan::math::assign(rhoPun, exp(add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),rhoPun_pr))));

            // validate transformed parameters
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 30;
            current_statement_begin__ = 31;
            current_statement_begin__ = 32;
            check_greater_or_equal(function__,"rhoRew",rhoRew,0);
            current_statement_begin__ = 33;
            check_greater_or_equal(function__,"rhoPun",rhoPun,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoRew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoPun[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 111;
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            current_statement_begin__ = 112;
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            current_statement_begin__ = 113;
            double mu_b(0.0);
            (void) mu_b;  // dummy to suppress unused var warning

            stan::math::initialize(mu_b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_b,DUMMY_VAR__);
            current_statement_begin__ = 114;
            double mu_pi(0.0);
            (void) mu_pi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_pi,DUMMY_VAR__);
            current_statement_begin__ = 115;
            double mu_rhoRew(0.0);
            (void) mu_rhoRew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rhoRew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rhoRew,DUMMY_VAR__);
            current_statement_begin__ = 116;
            double mu_rhoPun(0.0);
            (void) mu_rhoPun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rhoPun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rhoPun,DUMMY_VAR__);
            current_statement_begin__ = 118;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 121;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 124;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 125;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 126;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 130;
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 131;
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 132;
            stan::math::assign(mu_b, get_base1(mu_p,3,"mu_p",1));
            current_statement_begin__ = 133;
            stan::math::assign(mu_pi, get_base1(mu_p,4,"mu_p",1));
            current_statement_begin__ = 134;
            stan::math::assign(mu_rhoRew, exp(get_base1(mu_p,5,"mu_p",1)));
            current_statement_begin__ = 135;
            stan::math::assign(mu_rhoPun, exp(get_base1(mu_p,6,"mu_p",1)));

            current_statement_begin__ = 138;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 139;
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 140;
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 141;
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 142;
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 143;
                validate_non_negative_index("sv", "4", 4);
                vector_d sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sv,DUMMY_VAR__);
                current_statement_begin__ = 144;
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 146;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 147;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 148;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 149;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 150;
                stan::math::assign(sv, initV);
                current_statement_begin__ = 152;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 154;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 155;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    current_statement_begin__ = 156;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 157;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 158;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 159;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    current_statement_begin__ = 162;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    current_statement_begin__ = 165;
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        current_statement_begin__ = 166;
                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    } else {

                        current_statement_begin__ = 168;
                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    }
                    current_statement_begin__ = 172;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 173;
                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            current_statement_begin__ = 174;
                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        } else {

                            current_statement_begin__ = 176;
                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        }
                    } else {

                        current_statement_begin__ = 179;
                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            current_statement_begin__ = 180;
                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        } else {

                            current_statement_begin__ = 182;
                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        }
                    }
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 111;
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            current_statement_begin__ = 112;
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            current_statement_begin__ = 113;
            current_statement_begin__ = 114;
            current_statement_begin__ = 115;
            check_greater_or_equal(function__,"mu_rhoRew",mu_rhoRew,0);
            current_statement_begin__ = 116;
            check_greater_or_equal(function__,"mu_rhoPun",mu_rhoPun,0);
            current_statement_begin__ = 118;
            current_statement_begin__ = 121;

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_b);
        vars__.push_back(mu_pi);
        vars__.push_back(mu_rhoRew);
        vars__.push_back(mu_rhoPun);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m4";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoRew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoPun";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoRew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoPun";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_gng_m4_reg_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_gng_m4_reg");
    reader.add_event(200, 200, "end", "model_gng_m4_reg");
    return reader;
}

class model_gng_m4_reg : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > pressed;
    vector<vector<int> > cue;
    vector_d initV;
public:
    model_gng_m4_reg(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_gng_m4_reg(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_gng_m4_reg_namespace::model_gng_m4_reg";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 4;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 5;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            context__.validate_dims("data initialization", "pressed", "int", context__.to_vec(N,T));
            validate_non_negative_index("pressed", "N", N);
            validate_non_negative_index("pressed", "T", T);
            pressed = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("pressed");
            pos__ = 0;
            size_t pressed_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < pressed_limit_1__; ++i_1__) {
                size_t pressed_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < pressed_limit_0__; ++i_0__) {
                    pressed[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            context__.validate_dims("data initialization", "cue", "int", context__.to_vec(N,T));
            validate_non_negative_index("cue", "N", N);
            validate_non_negative_index("cue", "T", T);
            cue = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("cue");
            pos__ = 0;
            size_t cue_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cue_limit_1__; ++i_1__) {
                size_t cue_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cue_limit_0__; ++i_0__) {
                    cue[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 4;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 6;
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],-(1));
                    check_less_or_equal(function__,"pressed[k0__][k1__]",pressed[k0__][k1__],1);
                }
            }
            current_statement_begin__ = 8;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],1);
                    check_less_or_equal(function__,"cue[k0__][k1__]",cue[k0__][k1__],4);
                }
            }
            // initialize data variables
            current_statement_begin__ = 12;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 13;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 12;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 18;
            validate_non_negative_index("mu_p", "6", 6);
            num_params_r__ += 6;
            current_statement_begin__ = 19;
            validate_non_negative_index("sigma", "6", 6);
            num_params_r__ += 6;
            current_statement_begin__ = 20;
            validate_non_negative_index("xi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 21;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 22;
            validate_non_negative_index("b_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 23;
            validate_non_negative_index("pi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 24;
            validate_non_negative_index("rhoRew_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 25;
            validate_non_negative_index("rhoPun_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_gng_m4_reg() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "6", 6);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(6));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(6));
        for (int j1__ = 0U; j1__ < 6; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "6", 6);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(6));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(6));
        for (int j1__ = 0U; j1__ < 6; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("xi_pr")))
            throw std::runtime_error("variable xi_pr missing");
        vals_r__ = context__.vals_r("xi_pr");
        pos__ = 0U;
        validate_non_negative_index("xi_pr", "N", N);
        context__.validate_dims("initialization", "xi_pr", "vector_d", context__.to_vec(N));
        vector_d xi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            xi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(xi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable xi_pr: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("b_pr")))
            throw std::runtime_error("variable b_pr missing");
        vals_r__ = context__.vals_r("b_pr");
        pos__ = 0U;
        validate_non_negative_index("b_pr", "N", N);
        context__.validate_dims("initialization", "b_pr", "vector_d", context__.to_vec(N));
        vector_d b_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            b_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(b_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable b_pr: ") + e.what());
        }

        if (!(context__.contains_r("pi_pr")))
            throw std::runtime_error("variable pi_pr missing");
        vals_r__ = context__.vals_r("pi_pr");
        pos__ = 0U;
        validate_non_negative_index("pi_pr", "N", N);
        context__.validate_dims("initialization", "pi_pr", "vector_d", context__.to_vec(N));
        vector_d pi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            pi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(pi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable pi_pr: ") + e.what());
        }

        if (!(context__.contains_r("rhoRew_pr")))
            throw std::runtime_error("variable rhoRew_pr missing");
        vals_r__ = context__.vals_r("rhoRew_pr");
        pos__ = 0U;
        validate_non_negative_index("rhoRew_pr", "N", N);
        context__.validate_dims("initialization", "rhoRew_pr", "vector_d", context__.to_vec(N));
        vector_d rhoRew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rhoRew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rhoRew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rhoRew_pr: ") + e.what());
        }

        if (!(context__.contains_r("rhoPun_pr")))
            throw std::runtime_error("variable rhoPun_pr missing");
        vals_r__ = context__.vals_r("rhoPun_pr");
        pos__ = 0U;
        validate_non_negative_index("rhoPun_pr", "N", N);
        context__.validate_dims("initialization", "rhoPun_pr", "vector_d", context__.to_vec(N));
        vector_d rhoPun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rhoPun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rhoPun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rhoPun_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(6,lp__);
            else
                mu_p = in__.vector_constrain(6);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,6,lp__);
            else
                sigma = in__.vector_lb_constrain(0,6);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi_pr;
            (void) xi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                xi_pr = in__.vector_constrain(N,lp__);
            else
                xi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  b_pr;
            (void) b_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                b_pr = in__.vector_constrain(N,lp__);
            else
                b_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi_pr;
            (void) pi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                pi_pr = in__.vector_constrain(N,lp__);
            else
                pi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoRew_pr;
            (void) rhoRew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rhoRew_pr = in__.vector_constrain(N,lp__);
            else
                rhoRew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoPun_pr;
            (void) rhoPun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rhoPun_pr = in__.vector_constrain(N,lp__);
            else
                rhoPun_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 29;
            validate_non_negative_index("xi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, DUMMY_VAR__);
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 30;
            validate_non_negative_index("ep", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 31;
            validate_non_negative_index("b", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, DUMMY_VAR__);
            stan::math::fill(b,DUMMY_VAR__);
            current_statement_begin__ = 32;
            validate_non_negative_index("pi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, DUMMY_VAR__);
            stan::math::fill(pi,DUMMY_VAR__);
            current_statement_begin__ = 33;
            validate_non_negative_index("rhoRew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoRew(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoRew;  // dummy to suppress unused var warning

            stan::math::initialize(rhoRew, DUMMY_VAR__);
            stan::math::fill(rhoRew,DUMMY_VAR__);
            current_statement_begin__ = 34;
            validate_non_negative_index("rhoPun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rhoPun(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoPun;  // dummy to suppress unused var warning

            stan::math::initialize(rhoPun, DUMMY_VAR__);
            stan::math::fill(rhoPun,DUMMY_VAR__);


            current_statement_begin__ = 36;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 37;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 38;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 40;
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            current_statement_begin__ = 41;
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            current_statement_begin__ = 42;
            stan::math::assign(rhoRew, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rhoRew_pr))));
            current_statement_begin__ = 43;
            stan::math::assign(rhoPun, exp(add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),rhoPun_pr))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(xi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: xi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(b(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rhoRew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rhoRew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rhoPun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rhoPun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 30;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 31;
            current_statement_begin__ = 32;
            current_statement_begin__ = 33;
            check_greater_or_equal(function__,"rhoRew",rhoRew,0);
            current_statement_begin__ = 34;
            check_greater_or_equal(function__,"rhoPun",rhoPun,0);

            // model body

            current_statement_begin__ = 49;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 50;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 51;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 10.0));
            current_statement_begin__ = 52;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 10.0));
            current_statement_begin__ = 53;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,5,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 54;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,6,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 55;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5.0));
            current_statement_begin__ = 58;
            lp_accum__.add(normal_log<propto__>(xi_pr, 0, 1.0));
            current_statement_begin__ = 59;
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            current_statement_begin__ = 60;
            lp_accum__.add(normal_log<propto__>(b_pr, 0, 1.0));
            current_statement_begin__ = 61;
            lp_accum__.add(normal_log<propto__>(pi_pr, 0, 1.0));
            current_statement_begin__ = 62;
            lp_accum__.add(normal_log<propto__>(rhoRew_pr, 0, 1.0));
            current_statement_begin__ = 63;
            lp_accum__.add(normal_log<propto__>(rhoPun_pr, 0, 1.0));
            current_statement_begin__ = 65;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 66;
                validate_non_negative_index("wv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, DUMMY_VAR__);
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 67;
                validate_non_negative_index("wv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, DUMMY_VAR__);
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 68;
                validate_non_negative_index("qv_g", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, DUMMY_VAR__);
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 69;
                validate_non_negative_index("qv_ng", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, DUMMY_VAR__);
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 70;
                validate_non_negative_index("sv", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, DUMMY_VAR__);
                stan::math::fill(sv,DUMMY_VAR__);
                current_statement_begin__ = 71;
                validate_non_negative_index("pGo", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, DUMMY_VAR__);
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 73;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 74;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 75;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 76;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 77;
                stan::math::assign(sv, initV);
                current_statement_begin__ = 79;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 80;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    current_statement_begin__ = 81;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 82;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 83;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 84;
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2), get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1)));
                    current_statement_begin__ = 87;
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        current_statement_begin__ = 88;
                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    } else {

                        current_statement_begin__ = 90;
                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    }
                    current_statement_begin__ = 94;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 95;
                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            current_statement_begin__ = 96;
                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        } else {

                            current_statement_begin__ = 98;
                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        }
                    } else {

                        current_statement_begin__ = 101;
                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            current_statement_begin__ = 102;
                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        } else {

                            current_statement_begin__ = 104;
                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        }
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("xi_pr");
        names__.push_back("ep_pr");
        names__.push_back("b_pr");
        names__.push_back("pi_pr");
        names__.push_back("rhoRew_pr");
        names__.push_back("rhoPun_pr");
        names__.push_back("xi");
        names__.push_back("ep");
        names__.push_back("b");
        names__.push_back("pi");
        names__.push_back("rhoRew");
        names__.push_back("rhoPun");
        names__.push_back("mu_xi");
        names__.push_back("mu_ep");
        names__.push_back("mu_b");
        names__.push_back("mu_pi");
        names__.push_back("mu_rhoRew");
        names__.push_back("mu_rhoPun");
        names__.push_back("log_lik");
        names__.push_back("Qgo");
        names__.push_back("Qnogo");
        names__.push_back("Wgo");
        names__.push_back("Wnogo");
        names__.push_back("SV");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(6);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(6);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_gng_m4_reg_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(6);
        vector_d sigma = in__.vector_lb_constrain(0,6);
        vector_d xi_pr = in__.vector_constrain(N);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d b_pr = in__.vector_constrain(N);
        vector_d pi_pr = in__.vector_constrain(N);
        vector_d rhoRew_pr = in__.vector_constrain(N);
        vector_d rhoPun_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 6; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 6; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoRew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoPun_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 29;
            validate_non_negative_index("xi", "N", N);
            vector_d xi(static_cast<Eigen::VectorXd::Index>(N));
            (void) xi;  // dummy to suppress unused var warning

            stan::math::initialize(xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(xi,DUMMY_VAR__);
            current_statement_begin__ = 30;
            validate_non_negative_index("ep", "N", N);
            vector_d ep(static_cast<Eigen::VectorXd::Index>(N));
            (void) ep;  // dummy to suppress unused var warning

            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 31;
            validate_non_negative_index("b", "N", N);
            vector_d b(static_cast<Eigen::VectorXd::Index>(N));
            (void) b;  // dummy to suppress unused var warning

            stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b,DUMMY_VAR__);
            current_statement_begin__ = 32;
            validate_non_negative_index("pi", "N", N);
            vector_d pi(static_cast<Eigen::VectorXd::Index>(N));
            (void) pi;  // dummy to suppress unused var warning

            stan::math::initialize(pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pi,DUMMY_VAR__);
            current_statement_begin__ = 33;
            validate_non_negative_index("rhoRew", "N", N);
            vector_d rhoRew(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoRew;  // dummy to suppress unused var warning

            stan::math::initialize(rhoRew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rhoRew,DUMMY_VAR__);
            current_statement_begin__ = 34;
            validate_non_negative_index("rhoPun", "N", N);
            vector_d rhoPun(static_cast<Eigen::VectorXd::Index>(N));
            (void) rhoPun;  // dummy to suppress unused var warning

            stan::math::initialize(rhoPun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rhoPun,DUMMY_VAR__);


            current_statement_begin__ = 36;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 37;
                stan::math::assign(get_base1_lhs(xi,i,"xi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(xi_pr,i,"xi_pr",1)))));
                current_statement_begin__ = 38;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
            }
            current_statement_begin__ = 40;
            stan::math::assign(b, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),b_pr)));
            current_statement_begin__ = 41;
            stan::math::assign(pi, add(get_base1(mu_p,4,"mu_p",1),multiply(get_base1(sigma,4,"sigma",1),pi_pr)));
            current_statement_begin__ = 42;
            stan::math::assign(rhoRew, exp(add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),rhoRew_pr))));
            current_statement_begin__ = 43;
            stan::math::assign(rhoPun, exp(add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),rhoPun_pr))));

            // validate transformed parameters
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"xi",xi,0);
            check_less_or_equal(function__,"xi",xi,1);
            current_statement_begin__ = 30;
            check_greater_or_equal(function__,"ep",ep,0);
            check_less_or_equal(function__,"ep",ep,1);
            current_statement_begin__ = 31;
            current_statement_begin__ = 32;
            current_statement_begin__ = 33;
            check_greater_or_equal(function__,"rhoRew",rhoRew,0);
            current_statement_begin__ = 34;
            check_greater_or_equal(function__,"rhoPun",rhoPun,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(xi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoRew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rhoPun[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 112;
            double mu_xi(0.0);
            (void) mu_xi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_xi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_xi,DUMMY_VAR__);
            current_statement_begin__ = 113;
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            current_statement_begin__ = 114;
            double mu_b(0.0);
            (void) mu_b;  // dummy to suppress unused var warning

            stan::math::initialize(mu_b, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_b,DUMMY_VAR__);
            current_statement_begin__ = 115;
            double mu_pi(0.0);
            (void) mu_pi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_pi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_pi,DUMMY_VAR__);
            current_statement_begin__ = 116;
            double mu_rhoRew(0.0);
            (void) mu_rhoRew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rhoRew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rhoRew,DUMMY_VAR__);
            current_statement_begin__ = 117;
            double mu_rhoPun(0.0);
            (void) mu_rhoPun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rhoPun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rhoPun,DUMMY_VAR__);
            current_statement_begin__ = 118;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 119;
            validate_non_negative_index("Qgo", "N", N);
            validate_non_negative_index("Qgo", "T", T);
            vector<vector<double> > Qgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qgo,DUMMY_VAR__);
            current_statement_begin__ = 120;
            validate_non_negative_index("Qnogo", "N", N);
            validate_non_negative_index("Qnogo", "T", T);
            vector<vector<double> > Qnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Qnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Qnogo,DUMMY_VAR__);
            current_statement_begin__ = 121;
            validate_non_negative_index("Wgo", "N", N);
            validate_non_negative_index("Wgo", "T", T);
            vector<vector<double> > Wgo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wgo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wgo,DUMMY_VAR__);
            current_statement_begin__ = 122;
            validate_non_negative_index("Wnogo", "N", N);
            validate_non_negative_index("Wnogo", "T", T);
            vector<vector<double> > Wnogo(N, (vector<double>(T, 0.0)));
            stan::math::initialize(Wnogo, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Wnogo,DUMMY_VAR__);
            current_statement_begin__ = 123;
            validate_non_negative_index("SV", "N", N);
            validate_non_negative_index("SV", "T", T);
            vector<vector<double> > SV(N, (vector<double>(T, 0.0)));
            stan::math::initialize(SV, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(SV,DUMMY_VAR__);
            current_statement_begin__ = 126;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 129;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 130;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 131;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 135;
            stan::math::assign(mu_xi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 136;
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 137;
            stan::math::assign(mu_b, get_base1(mu_p,3,"mu_p",1));
            current_statement_begin__ = 138;
            stan::math::assign(mu_pi, get_base1(mu_p,4,"mu_p",1));
            current_statement_begin__ = 139;
            stan::math::assign(mu_rhoRew, exp(get_base1(mu_p,5,"mu_p",1)));
            current_statement_begin__ = 140;
            stan::math::assign(mu_rhoPun, exp(get_base1(mu_p,6,"mu_p",1)));

            current_statement_begin__ = 143;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 144;
                validate_non_negative_index("wv_g", "4", 4);
                vector_d wv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_g;  // dummy to suppress unused var warning

                stan::math::initialize(wv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_g,DUMMY_VAR__);
                current_statement_begin__ = 145;
                validate_non_negative_index("wv_ng", "4", 4);
                vector_d wv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) wv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(wv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(wv_ng,DUMMY_VAR__);
                current_statement_begin__ = 146;
                validate_non_negative_index("qv_g", "4", 4);
                vector_d qv_g(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_g;  // dummy to suppress unused var warning

                stan::math::initialize(qv_g, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_g,DUMMY_VAR__);
                current_statement_begin__ = 147;
                validate_non_negative_index("qv_ng", "4", 4);
                vector_d qv_ng(static_cast<Eigen::VectorXd::Index>(4));
                (void) qv_ng;  // dummy to suppress unused var warning

                stan::math::initialize(qv_ng, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(qv_ng,DUMMY_VAR__);
                current_statement_begin__ = 148;
                validate_non_negative_index("sv", "4", 4);
                vector_d sv(static_cast<Eigen::VectorXd::Index>(4));
                (void) sv;  // dummy to suppress unused var warning

                stan::math::initialize(sv, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sv,DUMMY_VAR__);
                current_statement_begin__ = 149;
                validate_non_negative_index("pGo", "4", 4);
                vector_d pGo(static_cast<Eigen::VectorXd::Index>(4));
                (void) pGo;  // dummy to suppress unused var warning

                stan::math::initialize(pGo, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pGo,DUMMY_VAR__);


                current_statement_begin__ = 151;
                stan::math::assign(wv_g, initV);
                current_statement_begin__ = 152;
                stan::math::assign(wv_ng, initV);
                current_statement_begin__ = 153;
                stan::math::assign(qv_g, initV);
                current_statement_begin__ = 154;
                stan::math::assign(qv_ng, initV);
                current_statement_begin__ = 155;
                stan::math::assign(sv, initV);
                current_statement_begin__ = 157;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 159;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 160;
                    stan::math::assign(get_base1_lhs(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1), ((get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + get_base1(b,i,"b",1)) + (get_base1(pi,i,"pi",1) * get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1))));
                    current_statement_begin__ = 161;
                    stan::math::assign(get_base1_lhs(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 162;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), inv_logit((get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1) - get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1))));
                    current_statement_begin__ = 163;
                    stan::math::assign(get_base1_lhs(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), ((get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1) * (1 - get_base1(xi,i,"xi",1))) + (get_base1(xi,i,"xi",1) / 2)));
                    current_statement_begin__ = 164;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2),get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1))));
                    current_statement_begin__ = 167;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(get_base1(pGo,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"pGo",1), base_rng__));
                    current_statement_begin__ = 170;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qgo,i,"Qgo",1),t,"Qgo",2), get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1));
                    current_statement_begin__ = 171;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Qnogo,i,"Qnogo",1),t,"Qnogo",2), get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1));
                    current_statement_begin__ = 172;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wgo,i,"Wgo",1),t,"Wgo",2), get_base1(wv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_g",1));
                    current_statement_begin__ = 173;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(Wnogo,i,"Wnogo",1),t,"Wnogo",2), get_base1(wv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"wv_ng",1));
                    current_statement_begin__ = 174;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(SV,i,"SV",1),t,"SV",2), get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1));
                    current_statement_begin__ = 177;
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        current_statement_begin__ = 178;
                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    } else {

                        current_statement_begin__ = 180;
                        stan::math::assign(get_base1_lhs(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1), (get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(sv,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"sv",1)))));
                    }
                    current_statement_begin__ = 184;
                    if (as_bool(get_base1(get_base1(pressed,i,"pressed",1),t,"pressed",2))) {

                        current_statement_begin__ = 185;
                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            current_statement_begin__ = 186;
                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        } else {

                            current_statement_begin__ = 188;
                            stan::math::assign(get_base1_lhs(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1), (get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_g,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_g",1)))));
                        }
                    } else {

                        current_statement_begin__ = 191;
                        if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                            current_statement_begin__ = 192;
                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoRew,i,"rhoRew",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        } else {

                            current_statement_begin__ = 194;
                            stan::math::assign(get_base1_lhs(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1), (get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1) + (get_base1(ep,i,"ep",1) * ((get_base1(rhoPun,i,"rhoPun",1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(qv_ng,get_base1(get_base1(cue,i,"cue",1),t,"cue",2),"qv_ng",1)))));
                        }
                    }
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 112;
            check_greater_or_equal(function__,"mu_xi",mu_xi,0);
            check_less_or_equal(function__,"mu_xi",mu_xi,1);
            current_statement_begin__ = 113;
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            current_statement_begin__ = 114;
            current_statement_begin__ = 115;
            current_statement_begin__ = 116;
            check_greater_or_equal(function__,"mu_rhoRew",mu_rhoRew,0);
            current_statement_begin__ = 117;
            check_greater_or_equal(function__,"mu_rhoPun",mu_rhoPun,0);
            current_statement_begin__ = 118;
            current_statement_begin__ = 119;
            current_statement_begin__ = 120;
            current_statement_begin__ = 121;
            current_statement_begin__ = 122;
            current_statement_begin__ = 123;
            current_statement_begin__ = 126;

            // write generated quantities
        vars__.push_back(mu_xi);
        vars__.push_back(mu_ep);
        vars__.push_back(mu_b);
        vars__.push_back(mu_pi);
        vars__.push_back(mu_rhoRew);
        vars__.push_back(mu_rhoPun);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Qnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wgo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(Wnogo[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(SV[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_gng_m4_reg";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoRew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoPun";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "SV" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 6; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "xi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoRew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rhoPun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_xi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_b";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_pi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoRew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rhoPun";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Qnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wgo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "Wnogo" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "SV" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_igt_pvl_decay_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_igt_pvl_decay");
    reader.add_event(131, 131, "end", "model_igt_pvl_decay");
    return reader;
}

class model_igt_pvl_decay : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > choice;
    vector_d initV;
public:
    model_igt_pvl_decay(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_igt_pvl_decay(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_igt_pvl_decay_namespace::model_igt_pvl_decay";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            current_statement_begin__ = 6;
            // initialize data variables
            current_statement_begin__ = 9;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 10;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 9;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 15;
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            current_statement_begin__ = 16;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            current_statement_begin__ = 19;
            validate_non_negative_index("A_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 20;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 21;
            validate_non_negative_index("cons_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 22;
            validate_non_negative_index("lambda_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_igt_pvl_decay() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("A_pr")))
            throw std::runtime_error("variable A_pr missing");
        vals_r__ = context__.vals_r("A_pr");
        pos__ = 0U;
        validate_non_negative_index("A_pr", "N", N);
        context__.validate_dims("initialization", "A_pr", "vector_d", context__.to_vec(N));
        vector_d A_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            A_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(A_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable A_pr: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("cons_pr")))
            throw std::runtime_error("variable cons_pr missing");
        vals_r__ = context__.vals_r("cons_pr");
        pos__ = 0U;
        validate_non_negative_index("cons_pr", "N", N);
        context__.validate_dims("initialization", "cons_pr", "vector_d", context__.to_vec(N));
        vector_d cons_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            cons_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(cons_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable cons_pr: ") + e.what());
        }

        if (!(context__.contains_r("lambda_pr")))
            throw std::runtime_error("variable lambda_pr missing");
        vals_r__ = context__.vals_r("lambda_pr");
        pos__ = 0U;
        validate_non_negative_index("lambda_pr", "N", N);
        context__.validate_dims("initialization", "lambda_pr", "vector_d", context__.to_vec(N));
        vector_d lambda_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            lambda_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(lambda_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  A_pr;
            (void) A_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                A_pr = in__.vector_constrain(N,lp__);
            else
                A_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  cons_pr;
            (void) cons_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                cons_pr = in__.vector_constrain(N,lp__);
            else
                cons_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda_pr;
            (void) lambda_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_pr = in__.vector_constrain(N,lp__);
            else
                lambda_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 26;
            validate_non_negative_index("A", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, DUMMY_VAR__);
            stan::math::fill(A,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("cons", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  cons(static_cast<Eigen::VectorXd::Index>(N));
            (void) cons;  // dummy to suppress unused var warning

            stan::math::initialize(cons, DUMMY_VAR__);
            stan::math::fill(cons,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("lambda", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, DUMMY_VAR__);
            stan::math::fill(lambda,DUMMY_VAR__);


            current_statement_begin__ = 31;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 2));
                current_statement_begin__ = 34;
                stan::math::assign(get_base1_lhs(cons,i,"cons",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(cons_pr,i,"cons_pr",1)))) * 5));
                current_statement_begin__ = 35;
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(A(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: A" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(cons(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: cons" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(lambda(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: lambda" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 26;
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"cons",cons,0);
            check_less_or_equal(function__,"cons",cons,5);
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,10);

            // model body

            current_statement_begin__ = 40;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 41;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 44;
            lp_accum__.add(normal_log<propto__>(A_pr, 0, 1));
            current_statement_begin__ = 45;
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1));
            current_statement_begin__ = 46;
            lp_accum__.add(normal_log<propto__>(cons_pr, 0, 1));
            current_statement_begin__ = 47;
            lp_accum__.add(normal_log<propto__>(lambda_pr, 0, 1));
            current_statement_begin__ = 49;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 51;
                validate_non_negative_index("ev", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 52;
                T__ curUtil;
                (void) curUtil;  // dummy to suppress unused var warning

                stan::math::initialize(curUtil, DUMMY_VAR__);
                stan::math::fill(curUtil,DUMMY_VAR__);
                current_statement_begin__ = 53;
                T__ theta;
                (void) theta;  // dummy to suppress unused var warning

                stan::math::initialize(theta, DUMMY_VAR__);
                stan::math::fill(theta,DUMMY_VAR__);


                current_statement_begin__ = 56;
                stan::math::assign(theta, (pow(3,get_base1(cons,i,"cons",1)) - 1));
                current_statement_begin__ = 57;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 59;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 61;
                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), multiply(theta,ev)));
                    current_statement_begin__ = 63;
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        current_statement_begin__ = 64;
                        stan::math::assign(curUtil, pow(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),get_base1(alpha,i,"alpha",1)));
                    } else {

                        current_statement_begin__ = 66;
                        stan::math::assign(curUtil, ((-(1) * get_base1(lambda,i,"lambda",1)) * pow((-(1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)),get_base1(alpha,i,"alpha",1))));
                    }
                    current_statement_begin__ = 70;
                    stan::math::assign(ev, multiply(ev,get_base1(A,i,"A",1)));
                    current_statement_begin__ = 71;
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + curUtil));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("A_pr");
        names__.push_back("alpha_pr");
        names__.push_back("cons_pr");
        names__.push_back("lambda_pr");
        names__.push_back("A");
        names__.push_back("alpha");
        names__.push_back("cons");
        names__.push_back("lambda");
        names__.push_back("mu_A");
        names__.push_back("mu_alpha");
        names__.push_back("mu_cons");
        names__.push_back("mu_lambda");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_igt_pvl_decay_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d A_pr = in__.vector_constrain(N);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d cons_pr = in__.vector_constrain(N);
        vector_d lambda_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(cons_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 26;
            validate_non_negative_index("A", "N", N);
            vector_d A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(A,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("cons", "N", N);
            vector_d cons(static_cast<Eigen::VectorXd::Index>(N));
            (void) cons;  // dummy to suppress unused var warning

            stan::math::initialize(cons, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(cons,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("lambda", "N", N);
            vector_d lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(lambda,DUMMY_VAR__);


            current_statement_begin__ = 31;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 2));
                current_statement_begin__ = 34;
                stan::math::assign(get_base1_lhs(cons,i,"cons",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(cons_pr,i,"cons_pr",1)))) * 5));
                current_statement_begin__ = 35;
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))) * 10));
            }

            // validate transformed parameters
            current_statement_begin__ = 26;
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"cons",cons,0);
            check_less_or_equal(function__,"cons",cons,5);
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(cons[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 77;
            double mu_A(0.0);
            (void) mu_A;  // dummy to suppress unused var warning

            stan::math::initialize(mu_A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_A,DUMMY_VAR__);
            current_statement_begin__ = 78;
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            current_statement_begin__ = 79;
            double mu_cons(0.0);
            (void) mu_cons;  // dummy to suppress unused var warning

            stan::math::initialize(mu_cons, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_cons,DUMMY_VAR__);
            current_statement_begin__ = 80;
            double mu_lambda(0.0);
            (void) mu_lambda;  // dummy to suppress unused var warning

            stan::math::initialize(mu_lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_lambda,DUMMY_VAR__);
            current_statement_begin__ = 83;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 86;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 89;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 90;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 91;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 95;
            stan::math::assign(mu_A, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 96;
            stan::math::assign(mu_alpha, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 2));
            current_statement_begin__ = 97;
            stan::math::assign(mu_cons, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));
            current_statement_begin__ = 98;
            stan::math::assign(mu_lambda, (Phi_approx(get_base1(mu_p,4,"mu_p",1)) * 10));

            current_statement_begin__ = 101;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 103;
                validate_non_negative_index("ev", "4", 4);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 104;
                double curUtil(0.0);
                (void) curUtil;  // dummy to suppress unused var warning

                stan::math::initialize(curUtil, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(curUtil,DUMMY_VAR__);
                current_statement_begin__ = 105;
                double theta(0.0);
                (void) theta;  // dummy to suppress unused var warning

                stan::math::initialize(theta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(theta,DUMMY_VAR__);


                current_statement_begin__ = 108;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 109;
                stan::math::assign(theta, (pow(3,get_base1(cons,i,"cons",1)) - 1));
                current_statement_begin__ = 110;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 112;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 114;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),multiply(theta,ev))));
                    current_statement_begin__ = 117;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(multiply(theta,ev)), base_rng__));
                    current_statement_begin__ = 119;
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        current_statement_begin__ = 120;
                        stan::math::assign(curUtil, pow(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),get_base1(alpha,i,"alpha",1)));
                    } else {

                        current_statement_begin__ = 122;
                        stan::math::assign(curUtil, ((-(1) * get_base1(lambda,i,"lambda",1)) * pow((-(1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)),get_base1(alpha,i,"alpha",1))));
                    }
                    current_statement_begin__ = 126;
                    stan::math::assign(ev, multiply(ev,get_base1(A,i,"A",1)));
                    current_statement_begin__ = 127;
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + curUtil));
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 77;
            check_greater_or_equal(function__,"mu_A",mu_A,0);
            check_less_or_equal(function__,"mu_A",mu_A,1);
            current_statement_begin__ = 78;
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_less_or_equal(function__,"mu_alpha",mu_alpha,2);
            current_statement_begin__ = 79;
            check_greater_or_equal(function__,"mu_cons",mu_cons,0);
            check_less_or_equal(function__,"mu_cons",mu_cons,5);
            current_statement_begin__ = 80;
            check_greater_or_equal(function__,"mu_lambda",mu_lambda,0);
            check_less_or_equal(function__,"mu_lambda",mu_lambda,10);
            current_statement_begin__ = 83;
            current_statement_begin__ = 86;

            // write generated quantities
        vars__.push_back(mu_A);
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_cons);
        vars__.push_back(mu_lambda);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_igt_pvl_decay";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_cons";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_cons";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_igt_pvl_delta_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_igt_pvl_delta");
    reader.add_event(129, 129, "end", "model_igt_pvl_delta");
    return reader;
}

class model_igt_pvl_delta : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > choice;
    vector_d initV;
public:
    model_igt_pvl_delta(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_igt_pvl_delta(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_igt_pvl_delta_namespace::model_igt_pvl_delta";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            current_statement_begin__ = 6;
            // initialize data variables
            current_statement_begin__ = 9;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 10;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 9;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 15;
            validate_non_negative_index("mu_p", "4", 4);
            num_params_r__ += 4;
            current_statement_begin__ = 16;
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            current_statement_begin__ = 19;
            validate_non_negative_index("A_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 20;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 21;
            validate_non_negative_index("cons_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 22;
            validate_non_negative_index("lambda_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_igt_pvl_delta() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "4", 4);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(4));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(4));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(4));
        for (int j1__ = 0U; j1__ < 4; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("A_pr")))
            throw std::runtime_error("variable A_pr missing");
        vals_r__ = context__.vals_r("A_pr");
        pos__ = 0U;
        validate_non_negative_index("A_pr", "N", N);
        context__.validate_dims("initialization", "A_pr", "vector_d", context__.to_vec(N));
        vector_d A_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            A_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(A_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable A_pr: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("cons_pr")))
            throw std::runtime_error("variable cons_pr missing");
        vals_r__ = context__.vals_r("cons_pr");
        pos__ = 0U;
        validate_non_negative_index("cons_pr", "N", N);
        context__.validate_dims("initialization", "cons_pr", "vector_d", context__.to_vec(N));
        vector_d cons_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            cons_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(cons_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable cons_pr: ") + e.what());
        }

        if (!(context__.contains_r("lambda_pr")))
            throw std::runtime_error("variable lambda_pr missing");
        vals_r__ = context__.vals_r("lambda_pr");
        pos__ = 0U;
        validate_non_negative_index("lambda_pr", "N", N);
        context__.validate_dims("initialization", "lambda_pr", "vector_d", context__.to_vec(N));
        vector_d lambda_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            lambda_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(lambda_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(4,lp__);
            else
                mu_p = in__.vector_constrain(4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,4,lp__);
            else
                sigma = in__.vector_lb_constrain(0,4);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  A_pr;
            (void) A_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                A_pr = in__.vector_constrain(N,lp__);
            else
                A_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  cons_pr;
            (void) cons_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                cons_pr = in__.vector_constrain(N,lp__);
            else
                cons_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda_pr;
            (void) lambda_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_pr = in__.vector_constrain(N,lp__);
            else
                lambda_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 26;
            validate_non_negative_index("A", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, DUMMY_VAR__);
            stan::math::fill(A,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("cons", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  cons(static_cast<Eigen::VectorXd::Index>(N));
            (void) cons;  // dummy to suppress unused var warning

            stan::math::initialize(cons, DUMMY_VAR__);
            stan::math::fill(cons,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("lambda", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, DUMMY_VAR__);
            stan::math::fill(lambda,DUMMY_VAR__);


            current_statement_begin__ = 31;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 2));
                current_statement_begin__ = 34;
                stan::math::assign(get_base1_lhs(cons,i,"cons",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(cons_pr,i,"cons_pr",1)))) * 5));
                current_statement_begin__ = 35;
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(A(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: A" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(cons(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: cons" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(lambda(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: lambda" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 26;
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"cons",cons,0);
            check_less_or_equal(function__,"cons",cons,5);
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,10);

            // model body

            current_statement_begin__ = 40;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 41;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 44;
            lp_accum__.add(normal_log<propto__>(A_pr, 0, 1));
            current_statement_begin__ = 45;
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1));
            current_statement_begin__ = 46;
            lp_accum__.add(normal_log<propto__>(cons_pr, 0, 1));
            current_statement_begin__ = 47;
            lp_accum__.add(normal_log<propto__>(lambda_pr, 0, 1));
            current_statement_begin__ = 49;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 51;
                validate_non_negative_index("ev", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 52;
                T__ curUtil;
                (void) curUtil;  // dummy to suppress unused var warning

                stan::math::initialize(curUtil, DUMMY_VAR__);
                stan::math::fill(curUtil,DUMMY_VAR__);
                current_statement_begin__ = 53;
                T__ theta;
                (void) theta;  // dummy to suppress unused var warning

                stan::math::initialize(theta, DUMMY_VAR__);
                stan::math::fill(theta,DUMMY_VAR__);


                current_statement_begin__ = 56;
                stan::math::assign(theta, (pow(3,get_base1(cons,i,"cons",1)) - 1));
                current_statement_begin__ = 57;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 59;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 61;
                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), multiply(theta,ev)));
                    current_statement_begin__ = 63;
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        current_statement_begin__ = 64;
                        stan::math::assign(curUtil, pow(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),get_base1(alpha,i,"alpha",1)));
                    } else {

                        current_statement_begin__ = 66;
                        stan::math::assign(curUtil, ((-(1) * get_base1(lambda,i,"lambda",1)) * pow((-(1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)),get_base1(alpha,i,"alpha",1))));
                    }
                    current_statement_begin__ = 70;
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(A,i,"A",1) * (curUtil - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)))));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("A_pr");
        names__.push_back("alpha_pr");
        names__.push_back("cons_pr");
        names__.push_back("lambda_pr");
        names__.push_back("A");
        names__.push_back("alpha");
        names__.push_back("cons");
        names__.push_back("lambda");
        names__.push_back("mu_A");
        names__.push_back("mu_alpha");
        names__.push_back("mu_cons");
        names__.push_back("mu_lambda");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_igt_pvl_delta_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(4);
        vector_d sigma = in__.vector_lb_constrain(0,4);
        vector_d A_pr = in__.vector_constrain(N);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d cons_pr = in__.vector_constrain(N);
        vector_d lambda_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(cons_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 26;
            validate_non_negative_index("A", "N", N);
            vector_d A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(A,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("cons", "N", N);
            vector_d cons(static_cast<Eigen::VectorXd::Index>(N));
            (void) cons;  // dummy to suppress unused var warning

            stan::math::initialize(cons, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(cons,DUMMY_VAR__);
            current_statement_begin__ = 29;
            validate_non_negative_index("lambda", "N", N);
            vector_d lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(lambda,DUMMY_VAR__);


            current_statement_begin__ = 31;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 2));
                current_statement_begin__ = 34;
                stan::math::assign(get_base1_lhs(cons,i,"cons",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(cons_pr,i,"cons_pr",1)))) * 5));
                current_statement_begin__ = 35;
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))) * 10));
            }

            // validate transformed parameters
            current_statement_begin__ = 26;
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            current_statement_begin__ = 28;
            check_greater_or_equal(function__,"cons",cons,0);
            check_less_or_equal(function__,"cons",cons,5);
            current_statement_begin__ = 29;
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(cons[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 76;
            double mu_A(0.0);
            (void) mu_A;  // dummy to suppress unused var warning

            stan::math::initialize(mu_A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_A,DUMMY_VAR__);
            current_statement_begin__ = 77;
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            current_statement_begin__ = 78;
            double mu_cons(0.0);
            (void) mu_cons;  // dummy to suppress unused var warning

            stan::math::initialize(mu_cons, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_cons,DUMMY_VAR__);
            current_statement_begin__ = 79;
            double mu_lambda(0.0);
            (void) mu_lambda;  // dummy to suppress unused var warning

            stan::math::initialize(mu_lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_lambda,DUMMY_VAR__);
            current_statement_begin__ = 82;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 85;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 88;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 89;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 90;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 94;
            stan::math::assign(mu_A, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 95;
            stan::math::assign(mu_alpha, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 2));
            current_statement_begin__ = 96;
            stan::math::assign(mu_cons, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));
            current_statement_begin__ = 97;
            stan::math::assign(mu_lambda, (Phi_approx(get_base1(mu_p,4,"mu_p",1)) * 10));

            current_statement_begin__ = 100;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 102;
                validate_non_negative_index("ev", "4", 4);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 103;
                double curUtil(0.0);
                (void) curUtil;  // dummy to suppress unused var warning

                stan::math::initialize(curUtil, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(curUtil,DUMMY_VAR__);
                current_statement_begin__ = 104;
                double theta(0.0);
                (void) theta;  // dummy to suppress unused var warning

                stan::math::initialize(theta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(theta,DUMMY_VAR__);


                current_statement_begin__ = 107;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 108;
                stan::math::assign(theta, (pow(3,get_base1(cons,i,"cons",1)) - 1));
                current_statement_begin__ = 109;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 111;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 113;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),multiply(theta,ev))));
                    current_statement_begin__ = 116;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(multiply(theta,ev)), base_rng__));
                    current_statement_begin__ = 118;
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        current_statement_begin__ = 119;
                        stan::math::assign(curUtil, pow(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),get_base1(alpha,i,"alpha",1)));
                    } else {

                        current_statement_begin__ = 121;
                        stan::math::assign(curUtil, ((-(1) * get_base1(lambda,i,"lambda",1)) * pow((-(1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)),get_base1(alpha,i,"alpha",1))));
                    }
                    current_statement_begin__ = 125;
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(A,i,"A",1) * (curUtil - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)))));
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 76;
            check_greater_or_equal(function__,"mu_A",mu_A,0);
            check_less_or_equal(function__,"mu_A",mu_A,1);
            current_statement_begin__ = 77;
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_less_or_equal(function__,"mu_alpha",mu_alpha,2);
            current_statement_begin__ = 78;
            check_greater_or_equal(function__,"mu_cons",mu_cons,0);
            check_less_or_equal(function__,"mu_cons",mu_cons,5);
            current_statement_begin__ = 79;
            check_greater_or_equal(function__,"mu_lambda",mu_lambda,0);
            check_less_or_equal(function__,"mu_lambda",mu_lambda,10);
            current_statement_begin__ = 82;
            current_statement_begin__ = 85;

            // write generated quantities
        vars__.push_back(mu_A);
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_cons);
        vars__.push_back(mu_lambda);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_igt_pvl_delta";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_cons";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_cons";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_igt_vpp_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_igt_vpp");
    reader.add_event(190, 190, "end", "model_igt_vpp");
    return reader;
}

class model_igt_vpp : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > outcome;
    vector<vector<int> > choice;
    vector_d initV;
public:
    model_igt_vpp(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_igt_vpp(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_igt_vpp_namespace::model_igt_vpp";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            current_statement_begin__ = 6;
            // initialize data variables
            current_statement_begin__ = 10;
            validate_non_negative_index("initV", "4", 4);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(4));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 11;
            stan::math::assign(initV, rep_vector(0.0,4));

            // validate transformed data
            current_statement_begin__ = 10;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 17;
            validate_non_negative_index("mu_p", "8", 8);
            num_params_r__ += 8;
            current_statement_begin__ = 18;
            validate_non_negative_index("sigma", "8", 8);
            num_params_r__ += 8;
            current_statement_begin__ = 21;
            validate_non_negative_index("A_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 22;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 23;
            validate_non_negative_index("cons_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 24;
            validate_non_negative_index("lambda_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 25;
            validate_non_negative_index("epP_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 26;
            validate_non_negative_index("epN_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 27;
            validate_non_negative_index("K_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 28;
            validate_non_negative_index("w_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_igt_vpp() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "8", 8);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(8));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(8));
        for (int j1__ = 0U; j1__ < 8; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "8", 8);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(8));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(8));
        for (int j1__ = 0U; j1__ < 8; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("A_pr")))
            throw std::runtime_error("variable A_pr missing");
        vals_r__ = context__.vals_r("A_pr");
        pos__ = 0U;
        validate_non_negative_index("A_pr", "N", N);
        context__.validate_dims("initialization", "A_pr", "vector_d", context__.to_vec(N));
        vector_d A_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            A_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(A_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable A_pr: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("cons_pr")))
            throw std::runtime_error("variable cons_pr missing");
        vals_r__ = context__.vals_r("cons_pr");
        pos__ = 0U;
        validate_non_negative_index("cons_pr", "N", N);
        context__.validate_dims("initialization", "cons_pr", "vector_d", context__.to_vec(N));
        vector_d cons_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            cons_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(cons_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable cons_pr: ") + e.what());
        }

        if (!(context__.contains_r("lambda_pr")))
            throw std::runtime_error("variable lambda_pr missing");
        vals_r__ = context__.vals_r("lambda_pr");
        pos__ = 0U;
        validate_non_negative_index("lambda_pr", "N", N);
        context__.validate_dims("initialization", "lambda_pr", "vector_d", context__.to_vec(N));
        vector_d lambda_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            lambda_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(lambda_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_pr: ") + e.what());
        }

        if (!(context__.contains_r("epP_pr")))
            throw std::runtime_error("variable epP_pr missing");
        vals_r__ = context__.vals_r("epP_pr");
        pos__ = 0U;
        validate_non_negative_index("epP_pr", "N", N);
        context__.validate_dims("initialization", "epP_pr", "vector_d", context__.to_vec(N));
        vector_d epP_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            epP_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(epP_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable epP_pr: ") + e.what());
        }

        if (!(context__.contains_r("epN_pr")))
            throw std::runtime_error("variable epN_pr missing");
        vals_r__ = context__.vals_r("epN_pr");
        pos__ = 0U;
        validate_non_negative_index("epN_pr", "N", N);
        context__.validate_dims("initialization", "epN_pr", "vector_d", context__.to_vec(N));
        vector_d epN_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            epN_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(epN_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable epN_pr: ") + e.what());
        }

        if (!(context__.contains_r("K_pr")))
            throw std::runtime_error("variable K_pr missing");
        vals_r__ = context__.vals_r("K_pr");
        pos__ = 0U;
        validate_non_negative_index("K_pr", "N", N);
        context__.validate_dims("initialization", "K_pr", "vector_d", context__.to_vec(N));
        vector_d K_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            K_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(K_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable K_pr: ") + e.what());
        }

        if (!(context__.contains_r("w_pr")))
            throw std::runtime_error("variable w_pr missing");
        vals_r__ = context__.vals_r("w_pr");
        pos__ = 0U;
        validate_non_negative_index("w_pr", "N", N);
        context__.validate_dims("initialization", "w_pr", "vector_d", context__.to_vec(N));
        vector_d w_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            w_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(w_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable w_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(8,lp__);
            else
                mu_p = in__.vector_constrain(8);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,8,lp__);
            else
                sigma = in__.vector_lb_constrain(0,8);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  A_pr;
            (void) A_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                A_pr = in__.vector_constrain(N,lp__);
            else
                A_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  cons_pr;
            (void) cons_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                cons_pr = in__.vector_constrain(N,lp__);
            else
                cons_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda_pr;
            (void) lambda_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_pr = in__.vector_constrain(N,lp__);
            else
                lambda_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  epP_pr;
            (void) epP_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                epP_pr = in__.vector_constrain(N,lp__);
            else
                epP_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  epN_pr;
            (void) epN_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                epN_pr = in__.vector_constrain(N,lp__);
            else
                epN_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  K_pr;
            (void) K_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                K_pr = in__.vector_constrain(N,lp__);
            else
                K_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  w_pr;
            (void) w_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                w_pr = in__.vector_constrain(N,lp__);
            else
                w_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 33;
            validate_non_negative_index("A", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, DUMMY_VAR__);
            stan::math::fill(A,DUMMY_VAR__);
            current_statement_begin__ = 34;
            validate_non_negative_index("alpha", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            current_statement_begin__ = 35;
            validate_non_negative_index("cons", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  cons(static_cast<Eigen::VectorXd::Index>(N));
            (void) cons;  // dummy to suppress unused var warning

            stan::math::initialize(cons, DUMMY_VAR__);
            stan::math::fill(cons,DUMMY_VAR__);
            current_statement_begin__ = 36;
            validate_non_negative_index("lambda", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, DUMMY_VAR__);
            stan::math::fill(lambda,DUMMY_VAR__);
            current_statement_begin__ = 37;
            validate_non_negative_index("epP", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  epP(static_cast<Eigen::VectorXd::Index>(N));
            (void) epP;  // dummy to suppress unused var warning

            stan::math::initialize(epP, DUMMY_VAR__);
            stan::math::fill(epP,DUMMY_VAR__);
            current_statement_begin__ = 38;
            validate_non_negative_index("epN", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  epN(static_cast<Eigen::VectorXd::Index>(N));
            (void) epN;  // dummy to suppress unused var warning

            stan::math::initialize(epN, DUMMY_VAR__);
            stan::math::fill(epN,DUMMY_VAR__);
            current_statement_begin__ = 39;
            validate_non_negative_index("K", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  K(static_cast<Eigen::VectorXd::Index>(N));
            (void) K;  // dummy to suppress unused var warning

            stan::math::initialize(K, DUMMY_VAR__);
            stan::math::fill(K,DUMMY_VAR__);
            current_statement_begin__ = 40;
            validate_non_negative_index("w", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  w(static_cast<Eigen::VectorXd::Index>(N));
            (void) w;  // dummy to suppress unused var warning

            stan::math::initialize(w, DUMMY_VAR__);
            stan::math::fill(w,DUMMY_VAR__);


            current_statement_begin__ = 42;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 43;
                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                current_statement_begin__ = 44;
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 2));
                current_statement_begin__ = 45;
                stan::math::assign(get_base1_lhs(cons,i,"cons",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(cons_pr,i,"cons_pr",1)))) * 5));
                current_statement_begin__ = 46;
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))) * 10));
                current_statement_begin__ = 47;
                stan::math::assign(get_base1_lhs(K,i,"K",1), Phi_approx((get_base1(mu_p,7,"mu_p",1) + (get_base1(sigma,7,"sigma",1) * get_base1(K_pr,i,"K_pr",1)))));
                current_statement_begin__ = 48;
                stan::math::assign(get_base1_lhs(w,i,"w",1), Phi_approx((get_base1(mu_p,8,"mu_p",1) + (get_base1(sigma,8,"sigma",1) * get_base1(w_pr,i,"w_pr",1)))));
            }
            current_statement_begin__ = 50;
            stan::math::assign(epP, add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),epP_pr)));
            current_statement_begin__ = 51;
            stan::math::assign(epN, add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),epN_pr)));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(A(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: A" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(cons(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: cons" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(lambda(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: lambda" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(epP(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: epP" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(epN(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: epN" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(K(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: K" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(w(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: w" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 33;
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            current_statement_begin__ = 34;
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            current_statement_begin__ = 35;
            check_greater_or_equal(function__,"cons",cons,0);
            check_less_or_equal(function__,"cons",cons,5);
            current_statement_begin__ = 36;
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,10);
            current_statement_begin__ = 37;
            current_statement_begin__ = 38;
            current_statement_begin__ = 39;
            check_greater_or_equal(function__,"K",K,0);
            check_less_or_equal(function__,"K",K,1);
            current_statement_begin__ = 40;
            check_greater_or_equal(function__,"w",w,0);
            check_less_or_equal(function__,"w",w,1);

            // model body

            current_statement_begin__ = 56;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,1,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 57;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,2,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 58;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,3,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 59;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,4,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 60;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,5,"mu_p",1), 0, 10.0));
            current_statement_begin__ = 61;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,6,"mu_p",1), 0, 10.0));
            current_statement_begin__ = 62;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,7,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 63;
            lp_accum__.add(normal_log<propto__>(get_base1(mu_p,8,"mu_p",1), 0, 1.0));
            current_statement_begin__ = 64;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 67;
            lp_accum__.add(normal_log<propto__>(A_pr, 0, 1.0));
            current_statement_begin__ = 68;
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1.0));
            current_statement_begin__ = 69;
            lp_accum__.add(normal_log<propto__>(cons_pr, 0, 1.0));
            current_statement_begin__ = 70;
            lp_accum__.add(normal_log<propto__>(lambda_pr, 0, 1.0));
            current_statement_begin__ = 71;
            lp_accum__.add(normal_log<propto__>(epP_pr, 0, 1.0));
            current_statement_begin__ = 72;
            lp_accum__.add(normal_log<propto__>(epN_pr, 0, 1.0));
            current_statement_begin__ = 73;
            lp_accum__.add(normal_log<propto__>(K_pr, 0, 1.0));
            current_statement_begin__ = 74;
            lp_accum__.add(normal_log<propto__>(w_pr, 0, 1.0));
            current_statement_begin__ = 76;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 78;
                validate_non_negative_index("ev", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 79;
                validate_non_negative_index("p_next", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  p_next(static_cast<Eigen::VectorXd::Index>(4));
                (void) p_next;  // dummy to suppress unused var warning

                stan::math::initialize(p_next, DUMMY_VAR__);
                stan::math::fill(p_next,DUMMY_VAR__);
                current_statement_begin__ = 80;
                validate_non_negative_index("str", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  str(static_cast<Eigen::VectorXd::Index>(4));
                (void) str;  // dummy to suppress unused var warning

                stan::math::initialize(str, DUMMY_VAR__);
                stan::math::fill(str,DUMMY_VAR__);
                current_statement_begin__ = 81;
                validate_non_negative_index("pers", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  pers(static_cast<Eigen::VectorXd::Index>(4));
                (void) pers;  // dummy to suppress unused var warning

                stan::math::initialize(pers, DUMMY_VAR__);
                stan::math::fill(pers,DUMMY_VAR__);
                current_statement_begin__ = 82;
                validate_non_negative_index("V", "4", 4);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  V(static_cast<Eigen::VectorXd::Index>(4));
                (void) V;  // dummy to suppress unused var warning

                stan::math::initialize(V, DUMMY_VAR__);
                stan::math::fill(V,DUMMY_VAR__);
                current_statement_begin__ = 84;
                T__ curUtil;
                (void) curUtil;  // dummy to suppress unused var warning

                stan::math::initialize(curUtil, DUMMY_VAR__);
                stan::math::fill(curUtil,DUMMY_VAR__);
                current_statement_begin__ = 85;
                T__ theta;
                (void) theta;  // dummy to suppress unused var warning

                stan::math::initialize(theta, DUMMY_VAR__);
                stan::math::fill(theta,DUMMY_VAR__);


                current_statement_begin__ = 88;
                stan::math::assign(theta, (pow(3,get_base1(cons,i,"cons",1)) - 1));
                current_statement_begin__ = 89;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 90;
                stan::math::assign(pers, initV);
                current_statement_begin__ = 91;
                stan::math::assign(V, initV);
                current_statement_begin__ = 93;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 95;
                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), multiply(theta,V)));
                    current_statement_begin__ = 98;
                    stan::math::assign(pers, multiply(pers,get_base1(K,i,"K",1)));
                    current_statement_begin__ = 100;
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        current_statement_begin__ = 101;
                        stan::math::assign(curUtil, pow(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),get_base1(alpha,i,"alpha",1)));
                        current_statement_begin__ = 102;
                        stan::math::assign(get_base1_lhs(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1), (get_base1(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1) + get_base1(epP,i,"epP",1)));
                    } else {

                        current_statement_begin__ = 104;
                        stan::math::assign(curUtil, ((-(1) * get_base1(lambda,i,"lambda",1)) * pow((-(1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)),get_base1(alpha,i,"alpha",1))));
                        current_statement_begin__ = 105;
                        stan::math::assign(get_base1_lhs(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1), (get_base1(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1) + get_base1(epN,i,"epN",1)));
                    }
                    current_statement_begin__ = 108;
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(A,i,"A",1) * (curUtil - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)))));
                    current_statement_begin__ = 110;
                    stan::math::assign(V, add(multiply(get_base1(w,i,"w",1),ev),multiply((1 - get_base1(w,i,"w",1)),pers)));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("A_pr");
        names__.push_back("alpha_pr");
        names__.push_back("cons_pr");
        names__.push_back("lambda_pr");
        names__.push_back("epP_pr");
        names__.push_back("epN_pr");
        names__.push_back("K_pr");
        names__.push_back("w_pr");
        names__.push_back("A");
        names__.push_back("alpha");
        names__.push_back("cons");
        names__.push_back("lambda");
        names__.push_back("epP");
        names__.push_back("epN");
        names__.push_back("K");
        names__.push_back("w");
        names__.push_back("mu_A");
        names__.push_back("mu_alpha");
        names__.push_back("mu_cons");
        names__.push_back("mu_lambda");
        names__.push_back("mu_epP");
        names__.push_back("mu_epN");
        names__.push_back("mu_K");
        names__.push_back("mu_w");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(8);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(8);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_igt_vpp_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(8);
        vector_d sigma = in__.vector_lb_constrain(0,8);
        vector_d A_pr = in__.vector_constrain(N);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d cons_pr = in__.vector_constrain(N);
        vector_d lambda_pr = in__.vector_constrain(N);
        vector_d epP_pr = in__.vector_constrain(N);
        vector_d epN_pr = in__.vector_constrain(N);
        vector_d K_pr = in__.vector_constrain(N);
        vector_d w_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 8; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 8; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(cons_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(epP_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(epN_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(K_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 33;
            validate_non_negative_index("A", "N", N);
            vector_d A(static_cast<Eigen::VectorXd::Index>(N));
            (void) A;  // dummy to suppress unused var warning

            stan::math::initialize(A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(A,DUMMY_VAR__);
            current_statement_begin__ = 34;
            validate_non_negative_index("alpha", "N", N);
            vector_d alpha(static_cast<Eigen::VectorXd::Index>(N));
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            current_statement_begin__ = 35;
            validate_non_negative_index("cons", "N", N);
            vector_d cons(static_cast<Eigen::VectorXd::Index>(N));
            (void) cons;  // dummy to suppress unused var warning

            stan::math::initialize(cons, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(cons,DUMMY_VAR__);
            current_statement_begin__ = 36;
            validate_non_negative_index("lambda", "N", N);
            vector_d lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(lambda,DUMMY_VAR__);
            current_statement_begin__ = 37;
            validate_non_negative_index("epP", "N", N);
            vector_d epP(static_cast<Eigen::VectorXd::Index>(N));
            (void) epP;  // dummy to suppress unused var warning

            stan::math::initialize(epP, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(epP,DUMMY_VAR__);
            current_statement_begin__ = 38;
            validate_non_negative_index("epN", "N", N);
            vector_d epN(static_cast<Eigen::VectorXd::Index>(N));
            (void) epN;  // dummy to suppress unused var warning

            stan::math::initialize(epN, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(epN,DUMMY_VAR__);
            current_statement_begin__ = 39;
            validate_non_negative_index("K", "N", N);
            vector_d K(static_cast<Eigen::VectorXd::Index>(N));
            (void) K;  // dummy to suppress unused var warning

            stan::math::initialize(K, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(K,DUMMY_VAR__);
            current_statement_begin__ = 40;
            validate_non_negative_index("w", "N", N);
            vector_d w(static_cast<Eigen::VectorXd::Index>(N));
            (void) w;  // dummy to suppress unused var warning

            stan::math::initialize(w, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(w,DUMMY_VAR__);


            current_statement_begin__ = 42;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 43;
                stan::math::assign(get_base1_lhs(A,i,"A",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(A_pr,i,"A_pr",1)))));
                current_statement_begin__ = 44;
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 2));
                current_statement_begin__ = 45;
                stan::math::assign(get_base1_lhs(cons,i,"cons",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(cons_pr,i,"cons_pr",1)))) * 5));
                current_statement_begin__ = 46;
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,4,"mu_p",1) + (get_base1(sigma,4,"sigma",1) * get_base1(lambda_pr,i,"lambda_pr",1)))) * 10));
                current_statement_begin__ = 47;
                stan::math::assign(get_base1_lhs(K,i,"K",1), Phi_approx((get_base1(mu_p,7,"mu_p",1) + (get_base1(sigma,7,"sigma",1) * get_base1(K_pr,i,"K_pr",1)))));
                current_statement_begin__ = 48;
                stan::math::assign(get_base1_lhs(w,i,"w",1), Phi_approx((get_base1(mu_p,8,"mu_p",1) + (get_base1(sigma,8,"sigma",1) * get_base1(w_pr,i,"w_pr",1)))));
            }
            current_statement_begin__ = 50;
            stan::math::assign(epP, add(get_base1(mu_p,5,"mu_p",1),multiply(get_base1(sigma,5,"sigma",1),epP_pr)));
            current_statement_begin__ = 51;
            stan::math::assign(epN, add(get_base1(mu_p,6,"mu_p",1),multiply(get_base1(sigma,6,"sigma",1),epN_pr)));

            // validate transformed parameters
            current_statement_begin__ = 33;
            check_greater_or_equal(function__,"A",A,0);
            check_less_or_equal(function__,"A",A,1);
            current_statement_begin__ = 34;
            check_greater_or_equal(function__,"alpha",alpha,0);
            check_less_or_equal(function__,"alpha",alpha,2);
            current_statement_begin__ = 35;
            check_greater_or_equal(function__,"cons",cons,0);
            check_less_or_equal(function__,"cons",cons,5);
            current_statement_begin__ = 36;
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,10);
            current_statement_begin__ = 37;
            current_statement_begin__ = 38;
            current_statement_begin__ = 39;
            check_greater_or_equal(function__,"K",K,0);
            check_less_or_equal(function__,"K",K,1);
            current_statement_begin__ = 40;
            check_greater_or_equal(function__,"w",w,0);
            check_less_or_equal(function__,"w",w,1);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(A[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(cons[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(epP[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(epN[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(K[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(w[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 116;
            double mu_A(0.0);
            (void) mu_A;  // dummy to suppress unused var warning

            stan::math::initialize(mu_A, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_A,DUMMY_VAR__);
            current_statement_begin__ = 117;
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            current_statement_begin__ = 118;
            double mu_cons(0.0);
            (void) mu_cons;  // dummy to suppress unused var warning

            stan::math::initialize(mu_cons, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_cons,DUMMY_VAR__);
            current_statement_begin__ = 119;
            double mu_lambda(0.0);
            (void) mu_lambda;  // dummy to suppress unused var warning

            stan::math::initialize(mu_lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_lambda,DUMMY_VAR__);
            current_statement_begin__ = 120;
            double mu_epP(0.0);
            (void) mu_epP;  // dummy to suppress unused var warning

            stan::math::initialize(mu_epP, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_epP,DUMMY_VAR__);
            current_statement_begin__ = 121;
            double mu_epN(0.0);
            (void) mu_epN;  // dummy to suppress unused var warning

            stan::math::initialize(mu_epN, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_epN,DUMMY_VAR__);
            current_statement_begin__ = 122;
            double mu_K(0.0);
            (void) mu_K;  // dummy to suppress unused var warning

            stan::math::initialize(mu_K, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_K,DUMMY_VAR__);
            current_statement_begin__ = 123;
            double mu_w(0.0);
            (void) mu_w;  // dummy to suppress unused var warning

            stan::math::initialize(mu_w, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_w,DUMMY_VAR__);
            current_statement_begin__ = 126;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 129;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 132;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 133;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 134;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 138;
            stan::math::assign(mu_A, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 139;
            stan::math::assign(mu_alpha, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 2));
            current_statement_begin__ = 140;
            stan::math::assign(mu_cons, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));
            current_statement_begin__ = 141;
            stan::math::assign(mu_lambda, (Phi_approx(get_base1(mu_p,4,"mu_p",1)) * 10));
            current_statement_begin__ = 142;
            stan::math::assign(mu_epP, get_base1(mu_p,5,"mu_p",1));
            current_statement_begin__ = 143;
            stan::math::assign(mu_epN, get_base1(mu_p,6,"mu_p",1));
            current_statement_begin__ = 144;
            stan::math::assign(mu_K, Phi_approx(get_base1(mu_p,7,"mu_p",1)));
            current_statement_begin__ = 145;
            stan::math::assign(mu_w, Phi_approx(get_base1(mu_p,8,"mu_p",1)));

            current_statement_begin__ = 148;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 150;
                validate_non_negative_index("ev", "4", 4);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(4));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 151;
                validate_non_negative_index("p_next", "4", 4);
                vector_d p_next(static_cast<Eigen::VectorXd::Index>(4));
                (void) p_next;  // dummy to suppress unused var warning

                stan::math::initialize(p_next, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(p_next,DUMMY_VAR__);
                current_statement_begin__ = 152;
                validate_non_negative_index("str", "4", 4);
                vector_d str(static_cast<Eigen::VectorXd::Index>(4));
                (void) str;  // dummy to suppress unused var warning

                stan::math::initialize(str, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(str,DUMMY_VAR__);
                current_statement_begin__ = 153;
                validate_non_negative_index("pers", "4", 4);
                vector_d pers(static_cast<Eigen::VectorXd::Index>(4));
                (void) pers;  // dummy to suppress unused var warning

                stan::math::initialize(pers, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pers,DUMMY_VAR__);
                current_statement_begin__ = 154;
                validate_non_negative_index("V", "4", 4);
                vector_d V(static_cast<Eigen::VectorXd::Index>(4));
                (void) V;  // dummy to suppress unused var warning

                stan::math::initialize(V, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(V,DUMMY_VAR__);
                current_statement_begin__ = 156;
                double curUtil(0.0);
                (void) curUtil;  // dummy to suppress unused var warning

                stan::math::initialize(curUtil, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(curUtil,DUMMY_VAR__);
                current_statement_begin__ = 157;
                double theta(0.0);
                (void) theta;  // dummy to suppress unused var warning

                stan::math::initialize(theta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(theta,DUMMY_VAR__);


                current_statement_begin__ = 160;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 161;
                stan::math::assign(theta, (pow(3,get_base1(cons,i,"cons",1)) - 1));
                current_statement_begin__ = 162;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 163;
                stan::math::assign(pers, initV);
                current_statement_begin__ = 164;
                stan::math::assign(V, initV);
                current_statement_begin__ = 166;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 168;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),multiply(theta,V))));
                    current_statement_begin__ = 171;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(multiply(theta,V)), base_rng__));
                    current_statement_begin__ = 174;
                    stan::math::assign(pers, multiply(pers,get_base1(K,i,"K",1)));
                    current_statement_begin__ = 176;
                    if (as_bool(logical_gte(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {

                        current_statement_begin__ = 177;
                        stan::math::assign(curUtil, pow(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),get_base1(alpha,i,"alpha",1)));
                        current_statement_begin__ = 178;
                        stan::math::assign(get_base1_lhs(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1), (get_base1(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1) + get_base1(epP,i,"epP",1)));
                    } else {

                        current_statement_begin__ = 180;
                        stan::math::assign(curUtil, ((-(1) * get_base1(lambda,i,"lambda",1)) * pow((-(1) * get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)),get_base1(alpha,i,"alpha",1))));
                        current_statement_begin__ = 181;
                        stan::math::assign(get_base1_lhs(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1), (get_base1(pers,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"pers",1) + get_base1(epN,i,"epN",1)));
                    }
                    current_statement_begin__ = 184;
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(A,i,"A",1) * (curUtil - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)))));
                    current_statement_begin__ = 186;
                    stan::math::assign(V, add(multiply(get_base1(w,i,"w",1),ev),multiply((1 - get_base1(w,i,"w",1)),pers)));
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 116;
            check_greater_or_equal(function__,"mu_A",mu_A,0);
            check_less_or_equal(function__,"mu_A",mu_A,1);
            current_statement_begin__ = 117;
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_less_or_equal(function__,"mu_alpha",mu_alpha,2);
            current_statement_begin__ = 118;
            check_greater_or_equal(function__,"mu_cons",mu_cons,0);
            check_less_or_equal(function__,"mu_cons",mu_cons,5);
            current_statement_begin__ = 119;
            check_greater_or_equal(function__,"mu_lambda",mu_lambda,0);
            check_less_or_equal(function__,"mu_lambda",mu_lambda,10);
            current_statement_begin__ = 120;
            current_statement_begin__ = 121;
            current_statement_begin__ = 122;
            check_greater_or_equal(function__,"mu_K",mu_K,0);
            check_less_or_equal(function__,"mu_K",mu_K,1);
            current_statement_begin__ = 123;
            check_greater_or_equal(function__,"mu_w",mu_w,0);
            check_less_or_equal(function__,"mu_w",mu_w,1);
            current_statement_begin__ = 126;
            current_statement_begin__ = 129;

            // write generated quantities
        vars__.push_back(mu_A);
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_cons);
        vars__.push_back(mu_lambda);
        vars__.push_back(mu_epP);
        vars__.push_back(mu_epN);
        vars__.push_back(mu_K);
        vars__.push_back(mu_w);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_igt_vpp";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 8; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 8; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epP_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epN_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "K_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epP" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epN" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "K" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_cons";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_epP";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_epN";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_K";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 8; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 8; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epP_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epN_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "K_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "A" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cons" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epP" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "epN" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "K" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "w" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_A";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_cons";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_epP";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_epN";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_K";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_w";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_peer_ocu_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_peer_ocu");
    reader.add_event(111, 111, "end", "model_peer_ocu");
    return reader;
}

class model_peer_ocu : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<int> > condition;
    vector<vector<double> > safe_Hpayoff;
    vector<vector<double> > safe_Lpayoff;
    vector<vector<double> > risky_Hpayoff;
    vector<vector<double> > risky_Lpayoff;
    vector<vector<double> > p_gamble;
public:
    model_peer_ocu(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_peer_ocu(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_peer_ocu_namespace::model_peer_ocu";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("condition", "N", N);
            validate_non_negative_index("condition", "T", T);
            context__.validate_dims("data initialization", "condition", "int", context__.to_vec(N,T));
            validate_non_negative_index("condition", "N", N);
            validate_non_negative_index("condition", "T", T);
            condition = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("condition");
            pos__ = 0;
            size_t condition_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < condition_limit_1__; ++i_1__) {
                size_t condition_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < condition_limit_0__; ++i_0__) {
                    condition[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("safe_Hpayoff", "N", N);
            validate_non_negative_index("safe_Hpayoff", "T", T);
            context__.validate_dims("data initialization", "safe_Hpayoff", "double", context__.to_vec(N,T));
            validate_non_negative_index("safe_Hpayoff", "N", N);
            validate_non_negative_index("safe_Hpayoff", "T", T);
            safe_Hpayoff = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("safe_Hpayoff");
            pos__ = 0;
            size_t safe_Hpayoff_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < safe_Hpayoff_limit_1__; ++i_1__) {
                size_t safe_Hpayoff_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < safe_Hpayoff_limit_0__; ++i_0__) {
                    safe_Hpayoff[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("safe_Lpayoff", "N", N);
            validate_non_negative_index("safe_Lpayoff", "T", T);
            context__.validate_dims("data initialization", "safe_Lpayoff", "double", context__.to_vec(N,T));
            validate_non_negative_index("safe_Lpayoff", "N", N);
            validate_non_negative_index("safe_Lpayoff", "T", T);
            safe_Lpayoff = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("safe_Lpayoff");
            pos__ = 0;
            size_t safe_Lpayoff_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < safe_Lpayoff_limit_1__; ++i_1__) {
                size_t safe_Lpayoff_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < safe_Lpayoff_limit_0__; ++i_0__) {
                    safe_Lpayoff[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 9;
            validate_non_negative_index("risky_Hpayoff", "N", N);
            validate_non_negative_index("risky_Hpayoff", "T", T);
            context__.validate_dims("data initialization", "risky_Hpayoff", "double", context__.to_vec(N,T));
            validate_non_negative_index("risky_Hpayoff", "N", N);
            validate_non_negative_index("risky_Hpayoff", "T", T);
            risky_Hpayoff = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("risky_Hpayoff");
            pos__ = 0;
            size_t risky_Hpayoff_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < risky_Hpayoff_limit_1__; ++i_1__) {
                size_t risky_Hpayoff_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < risky_Hpayoff_limit_0__; ++i_0__) {
                    risky_Hpayoff[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 10;
            validate_non_negative_index("risky_Lpayoff", "N", N);
            validate_non_negative_index("risky_Lpayoff", "T", T);
            context__.validate_dims("data initialization", "risky_Lpayoff", "double", context__.to_vec(N,T));
            validate_non_negative_index("risky_Lpayoff", "N", N);
            validate_non_negative_index("risky_Lpayoff", "T", T);
            risky_Lpayoff = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("risky_Lpayoff");
            pos__ = 0;
            size_t risky_Lpayoff_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < risky_Lpayoff_limit_1__; ++i_1__) {
                size_t risky_Lpayoff_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < risky_Lpayoff_limit_0__; ++i_0__) {
                    risky_Lpayoff[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 11;
            validate_non_negative_index("p_gamble", "N", N);
            validate_non_negative_index("p_gamble", "T", T);
            context__.validate_dims("data initialization", "p_gamble", "double", context__.to_vec(N,T));
            validate_non_negative_index("p_gamble", "N", N);
            validate_non_negative_index("p_gamble", "T", T);
            p_gamble = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("p_gamble");
            pos__ = 0;
            size_t p_gamble_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < p_gamble_limit_1__; ++i_1__) {
                size_t p_gamble_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < p_gamble_limit_0__; ++i_0__) {
                    p_gamble[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],1);
                }
            }
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"condition[k0__][k1__]",condition[k0__][k1__],0);
                    check_less_or_equal(function__,"condition[k0__][k1__]",condition[k0__][k1__],3);
                }
            }
            current_statement_begin__ = 7;
            current_statement_begin__ = 8;
            current_statement_begin__ = 9;
            current_statement_begin__ = 10;
            current_statement_begin__ = 11;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"p_gamble[k0__][k1__]",p_gamble[k0__][k1__],0);
                    check_less_or_equal(function__,"p_gamble[k0__][k1__]",p_gamble[k0__][k1__],1);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 18;
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 19;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 20;
            validate_non_negative_index("rho_p", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 21;
            validate_non_negative_index("tau_p", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 22;
            validate_non_negative_index("ocu_p", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_peer_ocu() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("rho_p")))
            throw std::runtime_error("variable rho_p missing");
        vals_r__ = context__.vals_r("rho_p");
        pos__ = 0U;
        validate_non_negative_index("rho_p", "N", N);
        context__.validate_dims("initialization", "rho_p", "vector_d", context__.to_vec(N));
        vector_d rho_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_p: ") + e.what());
        }

        if (!(context__.contains_r("tau_p")))
            throw std::runtime_error("variable tau_p missing");
        vals_r__ = context__.vals_r("tau_p");
        pos__ = 0U;
        validate_non_negative_index("tau_p", "N", N);
        context__.validate_dims("initialization", "tau_p", "vector_d", context__.to_vec(N));
        vector_d tau_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_p: ") + e.what());
        }

        if (!(context__.contains_r("ocu_p")))
            throw std::runtime_error("variable ocu_p missing");
        vals_r__ = context__.vals_r("ocu_p");
        pos__ = 0U;
        validate_non_negative_index("ocu_p", "N", N);
        context__.validate_dims("initialization", "ocu_p", "vector_d", context__.to_vec(N));
        vector_d ocu_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ocu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ocu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ocu_p: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_p;
            (void) rho_p;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_p = in__.vector_constrain(N,lp__);
            else
                rho_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_p;
            (void) tau_p;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_p = in__.vector_constrain(N,lp__);
            else
                tau_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ocu_p;
            (void) ocu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                ocu_p = in__.vector_constrain(N,lp__);
            else
                ocu_p = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 26;
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("ocu", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  ocu(static_cast<Eigen::VectorXd::Index>(N));
            (void) ocu;  // dummy to suppress unused var warning

            stan::math::initialize(ocu, DUMMY_VAR__);
            stan::math::fill(ocu,DUMMY_VAR__);


            current_statement_begin__ = 30;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 31;
                stan::math::assign(get_base1_lhs(rho,i,"rho",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(rho_p,i,"rho_p",1)))) * 2));
            }
            current_statement_begin__ = 33;
            stan::math::assign(tau, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),tau_p))));
            current_statement_begin__ = 34;
            stan::math::assign(ocu, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),ocu_p)));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ocu(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ocu" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 26;
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,2);
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"tau",tau,0);
            current_statement_begin__ = 28;

            // model body

            current_statement_begin__ = 40;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            current_statement_begin__ = 41;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5.0));
            current_statement_begin__ = 44;
            lp_accum__.add(normal_log<propto__>(rho_p, 0, 1.0));
            current_statement_begin__ = 45;
            lp_accum__.add(normal_log<propto__>(tau_p, 0, 1.0));
            current_statement_begin__ = 46;
            lp_accum__.add(normal_log<propto__>(ocu_p, 0, 1.0));
            current_statement_begin__ = 48;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 49;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    current_statement_begin__ = 50;
                    T__ U_safe;
                    (void) U_safe;  // dummy to suppress unused var warning

                    stan::math::initialize(U_safe, DUMMY_VAR__);
                    stan::math::fill(U_safe,DUMMY_VAR__);
                    current_statement_begin__ = 51;
                    T__ U_risky;
                    (void) U_risky;  // dummy to suppress unused var warning

                    stan::math::initialize(U_risky, DUMMY_VAR__);
                    stan::math::fill(U_risky,DUMMY_VAR__);


                    current_statement_begin__ = 53;
                    stan::math::assign(U_safe, ((get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2) * pow(get_base1(get_base1(safe_Hpayoff,i,"safe_Hpayoff",1),t,"safe_Hpayoff",2),get_base1(rho,i,"rho",1))) + ((1 - get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2)) * pow(get_base1(get_base1(safe_Lpayoff,i,"safe_Lpayoff",1),t,"safe_Lpayoff",2),get_base1(rho,i,"rho",1)))));
                    current_statement_begin__ = 54;
                    stan::math::assign(U_risky, ((get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2) * pow(get_base1(get_base1(risky_Hpayoff,i,"risky_Hpayoff",1),t,"risky_Hpayoff",2),get_base1(rho,i,"rho",1))) + ((1 - get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2)) * pow(get_base1(get_base1(risky_Lpayoff,i,"risky_Lpayoff",1),t,"risky_Lpayoff",2),get_base1(rho,i,"rho",1)))));
                    current_statement_begin__ = 55;
                    if (as_bool(logical_eq(get_base1(get_base1(condition,i,"condition",1),t,"condition",2),1))) {

                        current_statement_begin__ = 56;
                        stan::math::assign(U_safe, (U_safe + get_base1(ocu,i,"ocu",1)));
                    }
                    current_statement_begin__ = 58;
                    if (as_bool(logical_eq(get_base1(get_base1(condition,i,"condition",1),t,"condition",2),3))) {

                        current_statement_begin__ = 59;
                        stan::math::assign(U_risky, (U_risky + get_base1(ocu,i,"ocu",1)));
                    }
                    current_statement_begin__ = 61;
                    lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), (get_base1(tau,i,"tau",1) * (U_risky - U_safe))));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("rho_p");
        names__.push_back("tau_p");
        names__.push_back("ocu_p");
        names__.push_back("rho");
        names__.push_back("tau");
        names__.push_back("ocu");
        names__.push_back("mu_rho");
        names__.push_back("mu_tau");
        names__.push_back("mu_ocu");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_peer_ocu_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d rho_p = in__.vector_constrain(N);
        vector_d tau_p = in__.vector_constrain(N);
        vector_d ocu_p = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ocu_p[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 26;
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("ocu", "N", N);
            vector_d ocu(static_cast<Eigen::VectorXd::Index>(N));
            (void) ocu;  // dummy to suppress unused var warning

            stan::math::initialize(ocu, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ocu,DUMMY_VAR__);


            current_statement_begin__ = 30;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 31;
                stan::math::assign(get_base1_lhs(rho,i,"rho",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(rho_p,i,"rho_p",1)))) * 2));
            }
            current_statement_begin__ = 33;
            stan::math::assign(tau, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),tau_p))));
            current_statement_begin__ = 34;
            stan::math::assign(ocu, add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),ocu_p)));

            // validate transformed parameters
            current_statement_begin__ = 26;
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,2);
            current_statement_begin__ = 27;
            check_greater_or_equal(function__,"tau",tau,0);
            current_statement_begin__ = 28;

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ocu[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 66;
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            current_statement_begin__ = 67;
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            current_statement_begin__ = 68;
            double mu_ocu(0.0);
            (void) mu_ocu;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ocu, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ocu,DUMMY_VAR__);
            current_statement_begin__ = 71;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 74;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 77;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 78;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 79;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 83;
            stan::math::assign(mu_rho, (Phi_approx(get_base1(mu_p,1,"mu_p",1)) * 2));
            current_statement_begin__ = 84;
            stan::math::assign(mu_tau, exp(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 85;
            stan::math::assign(mu_ocu, get_base1(mu_p,3,"mu_p",1));

            current_statement_begin__ = 88;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 91;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0.0);
                current_statement_begin__ = 93;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    current_statement_begin__ = 94;
                    double U_safe(0.0);
                    (void) U_safe;  // dummy to suppress unused var warning

                    stan::math::initialize(U_safe, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(U_safe,DUMMY_VAR__);
                    current_statement_begin__ = 95;
                    double U_risky(0.0);
                    (void) U_risky;  // dummy to suppress unused var warning

                    stan::math::initialize(U_risky, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(U_risky,DUMMY_VAR__);


                    current_statement_begin__ = 97;
                    stan::math::assign(U_safe, ((get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2) * pow(get_base1(get_base1(safe_Hpayoff,i,"safe_Hpayoff",1),t,"safe_Hpayoff",2),get_base1(rho,i,"rho",1))) + ((1 - get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2)) * pow(get_base1(get_base1(safe_Lpayoff,i,"safe_Lpayoff",1),t,"safe_Lpayoff",2),get_base1(rho,i,"rho",1)))));
                    current_statement_begin__ = 98;
                    stan::math::assign(U_risky, ((get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2) * pow(get_base1(get_base1(risky_Hpayoff,i,"risky_Hpayoff",1),t,"risky_Hpayoff",2),get_base1(rho,i,"rho",1))) + ((1 - get_base1(get_base1(p_gamble,i,"p_gamble",1),t,"p_gamble",2)) * pow(get_base1(get_base1(risky_Lpayoff,i,"risky_Lpayoff",1),t,"risky_Lpayoff",2),get_base1(rho,i,"rho",1)))));
                    current_statement_begin__ = 99;
                    if (as_bool(logical_eq(get_base1(get_base1(condition,i,"condition",1),t,"condition",2),1))) {

                        current_statement_begin__ = 100;
                        stan::math::assign(U_safe, (U_safe + get_base1(ocu,i,"ocu",1)));
                    }
                    current_statement_begin__ = 102;
                    if (as_bool(logical_eq(get_base1(get_base1(condition,i,"condition",1),t,"condition",2),3))) {

                        current_statement_begin__ = 103;
                        stan::math::assign(U_risky, (U_risky + get_base1(ocu,i,"ocu",1)));
                    }
                    current_statement_begin__ = 105;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),(get_base1(tau,i,"tau",1) * (U_risky - U_safe)))));
                    current_statement_begin__ = 107;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(inv_logit((get_base1(tau,i,"tau",1) * (U_risky - U_safe))), base_rng__));
                    }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 66;
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            check_less_or_equal(function__,"mu_rho",mu_rho,2);
            current_statement_begin__ = 67;
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);
            current_statement_begin__ = 68;
            current_statement_begin__ = 71;
            current_statement_begin__ = 74;

            // write generated quantities
        vars__.push_back(mu_rho);
        vars__.push_back(mu_tau);
        vars__.push_back(mu_ocu);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_peer_ocu";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ocu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ocu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ocu";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ocu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ocu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ocu";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_ewa_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_ewa");
    reader.add_event(162, 162, "end", "model_prl_ewa");
    return reader;
}

class model_prl_ewa : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > outcome;
    vector_d initV;
public:
    model_prl_ewa(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_ewa(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_ewa_namespace::model_prl_ewa";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 8;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 9;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 10;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 12;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 13;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 8;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 9;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 10;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 12;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],2);
                }
            }
            current_statement_begin__ = 13;
            // initialize data variables
            current_statement_begin__ = 18;
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 19;
            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data
            current_statement_begin__ = 18;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 25;
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 26;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 29;
            validate_non_negative_index("phi_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 30;
            validate_non_negative_index("rho_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 31;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_ewa() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("phi_pr")))
            throw std::runtime_error("variable phi_pr missing");
        vals_r__ = context__.vals_r("phi_pr");
        pos__ = 0U;
        validate_non_negative_index("phi_pr", "N", N);
        context__.validate_dims("initialization", "phi_pr", "vector_d", context__.to_vec(N));
        vector_d phi_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            phi_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(phi_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable phi_pr: ") + e.what());
        }

        if (!(context__.contains_r("rho_pr")))
            throw std::runtime_error("variable rho_pr missing");
        vals_r__ = context__.vals_r("rho_pr");
        pos__ = 0U;
        validate_non_negative_index("rho_pr", "N", N);
        context__.validate_dims("initialization", "rho_pr", "vector_d", context__.to_vec(N));
        vector_d rho_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  phi_pr;
            (void) phi_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                phi_pr = in__.vector_constrain(N,lp__);
            else
                phi_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_pr;
            (void) rho_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_pr = in__.vector_constrain(N,lp__);
            else
                rho_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 36;
            validate_non_negative_index("phi", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  phi(static_cast<Eigen::VectorXd::Index>(N));
            (void) phi;  // dummy to suppress unused var warning

            stan::math::initialize(phi, DUMMY_VAR__);
            stan::math::fill(phi,DUMMY_VAR__);
            current_statement_begin__ = 37;
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);
            current_statement_begin__ = 38;
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 40;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 41;
                stan::math::assign(get_base1_lhs(phi,i,"phi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(phi_pr,i,"phi_pr",1)))));
                current_statement_begin__ = 42;
                stan::math::assign(get_base1_lhs(rho,i,"rho",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(rho_pr,i,"rho_pr",1)))));
                current_statement_begin__ = 43;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(phi(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: phi" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 36;
            check_greater_or_equal(function__,"phi",phi,0);
            check_less_or_equal(function__,"phi",phi,1);
            current_statement_begin__ = 37;
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,1);
            current_statement_begin__ = 38;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // model body

            current_statement_begin__ = 49;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 50;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 53;
            lp_accum__.add(normal_log<propto__>(phi_pr, 0, 1));
            current_statement_begin__ = 54;
            lp_accum__.add(normal_log<propto__>(rho_pr, 0, 1));
            current_statement_begin__ = 55;
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            current_statement_begin__ = 57;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 59;
                validate_non_negative_index("ev", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 60;
                validate_non_negative_index("ew", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ew(static_cast<Eigen::VectorXd::Index>(2));
                (void) ew;  // dummy to suppress unused var warning

                stan::math::initialize(ew, DUMMY_VAR__);
                stan::math::fill(ew,DUMMY_VAR__);
                current_statement_begin__ = 62;
                T__ ewt1;
                (void) ewt1;  // dummy to suppress unused var warning

                stan::math::initialize(ewt1, DUMMY_VAR__);
                stan::math::fill(ewt1,DUMMY_VAR__);


                current_statement_begin__ = 65;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 66;
                stan::math::assign(ew, initV);
                current_statement_begin__ = 68;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 70;
                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), multiply(ev,get_base1(beta,i,"beta",1))));
                    current_statement_begin__ = 73;
                    stan::math::assign(ewt1, get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1));
                    current_statement_begin__ = 76;
                    stan::math::assign(get_base1_lhs(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1), ((get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1) * get_base1(rho,i,"rho",1)) + 1));
                    current_statement_begin__ = 79;
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), ((((get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) * get_base1(phi,i,"phi",1)) * ewt1) + get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) / get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1)));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("phi_pr");
        names__.push_back("rho_pr");
        names__.push_back("beta_pr");
        names__.push_back("phi");
        names__.push_back("rho");
        names__.push_back("beta");
        names__.push_back("mu_phi");
        names__.push_back("mu_rho");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_ew_c");
        names__.push_back("mr_ew_nc");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_ewa_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d phi_pr = in__.vector_constrain(N);
        vector_d rho_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(phi_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 36;
            validate_non_negative_index("phi", "N", N);
            vector_d phi(static_cast<Eigen::VectorXd::Index>(N));
            (void) phi;  // dummy to suppress unused var warning

            stan::math::initialize(phi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(phi,DUMMY_VAR__);
            current_statement_begin__ = 37;
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);
            current_statement_begin__ = 38;
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 40;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 41;
                stan::math::assign(get_base1_lhs(phi,i,"phi",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(phi_pr,i,"phi_pr",1)))));
                current_statement_begin__ = 42;
                stan::math::assign(get_base1_lhs(rho,i,"rho",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(rho_pr,i,"rho_pr",1)))));
                current_statement_begin__ = 43;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            current_statement_begin__ = 36;
            check_greater_or_equal(function__,"phi",phi,0);
            check_less_or_equal(function__,"phi",phi,1);
            current_statement_begin__ = 37;
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,1);
            current_statement_begin__ = 38;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(phi[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 86;
            double mu_phi(0.0);
            (void) mu_phi;  // dummy to suppress unused var warning

            stan::math::initialize(mu_phi, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_phi,DUMMY_VAR__);
            current_statement_begin__ = 87;
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            current_statement_begin__ = 88;
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            current_statement_begin__ = 91;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 95;
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<double> > mr_ev_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            current_statement_begin__ = 96;
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<double> > mr_ev_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            current_statement_begin__ = 99;
            validate_non_negative_index("mr_ew_c", "N", N);
            validate_non_negative_index("mr_ew_c", "T", T);
            vector<vector<double> > mr_ew_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ew_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ew_c,DUMMY_VAR__);
            current_statement_begin__ = 100;
            validate_non_negative_index("mr_ew_nc", "N", N);
            validate_non_negative_index("mr_ew_nc", "T", T);
            vector<vector<double> > mr_ew_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ew_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ew_nc,DUMMY_VAR__);
            current_statement_begin__ = 103;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 106;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 107;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 108;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), 0);
                    current_statement_begin__ = 109;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), 0);
                    current_statement_begin__ = 110;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ew_c,i,"mr_ew_c",1),t,"mr_ew_c",2), 0);
                    current_statement_begin__ = 111;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ew_nc,i,"mr_ew_nc",1),t,"mr_ew_nc",2), 0);
                    current_statement_begin__ = 113;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 117;
            stan::math::assign(mu_phi, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 118;
            stan::math::assign(mu_rho, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 119;
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 10));

            current_statement_begin__ = 122;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 124;
                validate_non_negative_index("ev", "2", 2);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 125;
                validate_non_negative_index("ew", "2", 2);
                vector_d ew(static_cast<Eigen::VectorXd::Index>(2));
                (void) ew;  // dummy to suppress unused var warning

                stan::math::initialize(ew, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ew,DUMMY_VAR__);
                current_statement_begin__ = 127;
                double ewt1(0.0);
                (void) ewt1;  // dummy to suppress unused var warning

                stan::math::initialize(ewt1, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ewt1,DUMMY_VAR__);


                current_statement_begin__ = 130;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 131;
                stan::math::assign(ew, initV);
                current_statement_begin__ = 133;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 135;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 137;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),multiply(ev,get_base1(beta,i,"beta",1)))));
                    current_statement_begin__ = 140;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(multiply(ev,get_base1(beta,i,"beta",1))), base_rng__));
                    current_statement_begin__ = 144;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1));
                    current_statement_begin__ = 145;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1));
                    current_statement_begin__ = 148;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ew_c,i,"mr_ew_c",1),t,"mr_ew_c",2), get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1));
                    current_statement_begin__ = 149;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ew_nc,i,"mr_ew_nc",1),t,"mr_ew_nc",2), get_base1(ew,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ew",1));
                    current_statement_begin__ = 152;
                    stan::math::assign(ewt1, get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1));
                    current_statement_begin__ = 155;
                    stan::math::assign(get_base1_lhs(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1), ((get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1) * get_base1(rho,i,"rho",1)) + 1));
                    current_statement_begin__ = 158;
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), ((((get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) * get_base1(phi,i,"phi",1)) * ewt1) + get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) / get_base1(ew,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ew",1)));
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 86;
            check_greater_or_equal(function__,"mu_phi",mu_phi,0);
            check_less_or_equal(function__,"mu_phi",mu_phi,1);
            current_statement_begin__ = 87;
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            check_less_or_equal(function__,"mu_rho",mu_rho,1);
            current_statement_begin__ = 88;
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,10);
            current_statement_begin__ = 91;
            current_statement_begin__ = 95;
            current_statement_begin__ = 96;
            current_statement_begin__ = 99;
            current_statement_begin__ = 100;
            current_statement_begin__ = 103;

            // write generated quantities
        vars__.push_back(mu_phi);
        vars__.push_back(mu_rho);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ew_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ew_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_ewa";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_phi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ew_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ew_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_phi";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ew_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ew_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_fictitious_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_fictitious");
    reader.add_event(159, 159, "end", "model_prl_fictitious");
    return reader;
}

class model_prl_fictitious : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > outcome;
    vector_d initV;
public:
    model_prl_fictitious(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_fictitious(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_fictitious_namespace::model_prl_fictitious";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 8;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 9;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 10;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 12;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 13;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 8;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 9;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 10;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 12;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],2);
                }
            }
            current_statement_begin__ = 13;
            // initialize data variables
            current_statement_begin__ = 18;
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 19;
            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data
            current_statement_begin__ = 18;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 25;
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 26;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 29;
            validate_non_negative_index("eta_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 30;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_fictitious() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("eta_pr")))
            throw std::runtime_error("variable eta_pr missing");
        vals_r__ = context__.vals_r("eta_pr");
        pos__ = 0U;
        validate_non_negative_index("eta_pr", "N", N);
        context__.validate_dims("initialization", "eta_pr", "vector_d", context__.to_vec(N));
        vector_d eta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            eta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(eta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eta_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_pr;
            (void) eta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                eta_pr = in__.vector_constrain(N,lp__);
            else
                eta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 35;
            validate_non_negative_index("eta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, DUMMY_VAR__);
            stan::math::fill(eta,DUMMY_VAR__);
            current_statement_begin__ = 36;
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 38;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 39;
                stan::math::assign(get_base1_lhs(eta,i,"eta",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pr,i,"eta_pr",1)))));
                current_statement_begin__ = 40;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(eta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: eta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 35;
            check_greater_or_equal(function__,"eta",eta,0);
            check_less_or_equal(function__,"eta",eta,1);
            current_statement_begin__ = 36;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // model body

            current_statement_begin__ = 46;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 47;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 50;
            lp_accum__.add(normal_log<propto__>(eta_pr, 0, 1));
            current_statement_begin__ = 51;
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            current_statement_begin__ = 53;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 55;
                validate_non_negative_index("ev", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 56;
                validate_non_negative_index("prob", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  prob(static_cast<Eigen::VectorXd::Index>(2));
                (void) prob;  // dummy to suppress unused var warning

                stan::math::initialize(prob, DUMMY_VAR__);
                stan::math::fill(prob,DUMMY_VAR__);
                current_statement_begin__ = 58;
                T__ PE;
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, DUMMY_VAR__);
                stan::math::fill(PE,DUMMY_VAR__);
                current_statement_begin__ = 59;
                T__ PEnc;
                (void) PEnc;  // dummy to suppress unused var warning

                stan::math::initialize(PEnc, DUMMY_VAR__);
                stan::math::fill(PEnc,DUMMY_VAR__);


                current_statement_begin__ = 62;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 64;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 66;
                    stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(ev,2,"ev",1) - get_base1(ev,1,"ev",1)))))));
                    current_statement_begin__ = 67;
                    stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                    current_statement_begin__ = 68;
                    lp_accum__.add(categorical_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), prob));
                    current_statement_begin__ = 71;
                    stan::math::assign(PE, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    current_statement_begin__ = 72;
                    stan::math::assign(PEnc, (-(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1)));
                    current_statement_begin__ = 75;
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta,i,"eta",1) * PE)));
                    current_statement_begin__ = 76;
                    stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta,i,"eta",1) * PEnc)));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("eta_pr");
        names__.push_back("beta_pr");
        names__.push_back("eta");
        names__.push_back("beta");
        names__.push_back("mu_eta");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_pe_c");
        names__.push_back("mr_pe_nc");
        names__.push_back("mr_dv");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_fictitious_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d eta_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 35;
            validate_non_negative_index("eta", "N", N);
            vector_d eta(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eta,DUMMY_VAR__);
            current_statement_begin__ = 36;
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 38;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 39;
                stan::math::assign(get_base1_lhs(eta,i,"eta",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pr,i,"eta_pr",1)))));
                current_statement_begin__ = 40;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            current_statement_begin__ = 35;
            check_greater_or_equal(function__,"eta",eta,0);
            check_less_or_equal(function__,"eta",eta,1);
            current_statement_begin__ = 36;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 83;
            double mu_eta(0.0);
            (void) mu_eta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_eta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_eta,DUMMY_VAR__);
            current_statement_begin__ = 84;
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            current_statement_begin__ = 87;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 90;
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<double> > mr_ev_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            current_statement_begin__ = 91;
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<double> > mr_ev_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            current_statement_begin__ = 93;
            validate_non_negative_index("mr_pe_c", "N", N);
            validate_non_negative_index("mr_pe_c", "T", T);
            vector<vector<double> > mr_pe_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_c,DUMMY_VAR__);
            current_statement_begin__ = 94;
            validate_non_negative_index("mr_pe_nc", "N", N);
            validate_non_negative_index("mr_pe_nc", "T", T);
            vector<vector<double> > mr_pe_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_nc,DUMMY_VAR__);
            current_statement_begin__ = 95;
            validate_non_negative_index("mr_dv", "N", N);
            validate_non_negative_index("mr_dv", "T", T);
            vector<vector<double> > mr_dv(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_dv, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_dv,DUMMY_VAR__);
            current_statement_begin__ = 98;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 101;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 102;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 103;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), 0);
                    current_statement_begin__ = 104;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), 0);
                    current_statement_begin__ = 106;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),t,"mr_pe_c",2), 0);
                    current_statement_begin__ = 107;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),t,"mr_pe_nc",2), 0);
                    current_statement_begin__ = 108;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),t,"mr_dv",2), 0);
                    current_statement_begin__ = 110;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 114;
            stan::math::assign(mu_eta, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 115;
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 5));

            current_statement_begin__ = 118;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 120;
                validate_non_negative_index("ev", "2", 2);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 121;
                validate_non_negative_index("prob", "2", 2);
                vector_d prob(static_cast<Eigen::VectorXd::Index>(2));
                (void) prob;  // dummy to suppress unused var warning

                stan::math::initialize(prob, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(prob,DUMMY_VAR__);
                current_statement_begin__ = 123;
                double PE(0.0);
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PE,DUMMY_VAR__);
                current_statement_begin__ = 124;
                double PEnc(0.0);
                (void) PEnc;  // dummy to suppress unused var warning

                stan::math::initialize(PEnc, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PEnc,DUMMY_VAR__);


                current_statement_begin__ = 127;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 129;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 131;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 133;
                    stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(ev,2,"ev",1) - get_base1(ev,1,"ev",1)))))));
                    current_statement_begin__ = 134;
                    stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                    current_statement_begin__ = 136;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),prob)));
                    current_statement_begin__ = 139;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(prob, base_rng__));
                    current_statement_begin__ = 142;
                    stan::math::assign(PE, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    current_statement_begin__ = 143;
                    stan::math::assign(PEnc, (-(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1)));
                    current_statement_begin__ = 146;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1));
                    current_statement_begin__ = 147;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1));
                    current_statement_begin__ = 149;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),t,"mr_pe_c",2), PE);
                    current_statement_begin__ = 150;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),t,"mr_pe_nc",2), PEnc);
                    current_statement_begin__ = 151;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),t,"mr_dv",2), (PE - PEnc));
                    current_statement_begin__ = 154;
                    stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta,i,"eta",1) * PE)));
                    current_statement_begin__ = 155;
                    stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta,i,"eta",1) * PEnc)));
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 83;
            check_greater_or_equal(function__,"mu_eta",mu_eta,0);
            check_less_or_equal(function__,"mu_eta",mu_eta,1);
            current_statement_begin__ = 84;
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,5);
            current_statement_begin__ = 87;
            current_statement_begin__ = 90;
            current_statement_begin__ = 91;
            current_statement_begin__ = 93;
            current_statement_begin__ = 94;
            current_statement_begin__ = 95;
            current_statement_begin__ = 98;

            // write generated quantities
        vars__.push_back(mu_eta);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_dv[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_fictitious";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_fictitious_multipleB_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_fictitious_multipleB");
    reader.add_event(168, 168, "end", "model_prl_fictitious_multipleB");
    return reader;
}

class model_prl_fictitious_multipleB : public prob_grad {
private:
    int N;
    int T;
    int maxB;
    vector<int> B;
    vector<vector<int> > Tsubj;
    vector<vector<vector<int> > > choice;
    vector<vector<vector<double> > > outcome;
    vector_d initV;
public:
    model_prl_fictitious_multipleB(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_fictitious_multipleB(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_fictitious_multipleB_namespace::model_prl_fictitious_multipleB";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 8;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 9;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 10;
            context__.validate_dims("data initialization", "maxB", "int", context__.to_vec());
            maxB = int(0);
            vals_i__ = context__.vals_i("maxB");
            pos__ = 0;
            maxB = vals_i__[pos__++];
            current_statement_begin__ = 11;
            validate_non_negative_index("B", "N", N);
            context__.validate_dims("data initialization", "B", "int", context__.to_vec(N));
            validate_non_negative_index("B", "N", N);
            B = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("B");
            pos__ = 0;
            size_t B_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < B_limit_0__; ++i_0__) {
                B[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 12;
            validate_non_negative_index("Tsubj", "N", N);
            validate_non_negative_index("Tsubj", "maxB", maxB);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N,maxB));
            validate_non_negative_index("Tsubj", "N", N);
            validate_non_negative_index("Tsubj", "maxB", maxB);
            Tsubj = std::vector<std::vector<int> >(N,std::vector<int>(maxB,int(0)));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_1__ = maxB;
            for (size_t i_1__ = 0; i_1__ < Tsubj_limit_1__; ++i_1__) {
                size_t Tsubj_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                    Tsubj[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 14;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "maxB", maxB);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,maxB,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "maxB", maxB);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<std::vector<int> > >(N,std::vector<std::vector<int> >(maxB,std::vector<int>(T,int(0))));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_2__ = T;
            for (size_t i_2__ = 0; i_2__ < choice_limit_2__; ++i_2__) {
                size_t choice_limit_1__ = maxB;
                for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                    size_t choice_limit_0__ = N;
                    for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                        choice[i_0__][i_1__][i_2__] = vals_i__[pos__++];
                    }
                }
            }
            current_statement_begin__ = 15;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "maxB", maxB);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,maxB,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "maxB", maxB);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<std::vector<double> > >(N,std::vector<std::vector<double> >(maxB,std::vector<double>(T,double(0))));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_2__ = T;
            for (size_t i_2__ = 0; i_2__ < outcome_limit_2__; ++i_2__) {
                size_t outcome_limit_1__ = maxB;
                for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                    size_t outcome_limit_0__ = N;
                    for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                        outcome[i_0__][i_1__][i_2__] = vals_r__[pos__++];
                    }
                }
            }

            // validate, data variables
            current_statement_begin__ = 8;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 9;
            check_greater_or_equal(function__,"T",T,0);
            current_statement_begin__ = 10;
            check_greater_or_equal(function__,"maxB",maxB,1);
            current_statement_begin__ = 11;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"B[k0__]",B[k0__],1);
            }
            current_statement_begin__ = 12;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < maxB; ++k1__) {
                    check_greater_or_equal(function__,"Tsubj[k0__][k1__]",Tsubj[k0__][k1__],0);
                    check_less_or_equal(function__,"Tsubj[k0__][k1__]",Tsubj[k0__][k1__],T);
                }
            }
            current_statement_begin__ = 14;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < maxB; ++k1__) {
                    for (int k2__ = 0; k2__ < T; ++k2__) {
                        check_greater_or_equal(function__,"choice[k0__][k1__][k2__]",choice[k0__][k1__][k2__],-(1));
                        check_less_or_equal(function__,"choice[k0__][k1__][k2__]",choice[k0__][k1__][k2__],2);
                    }
                }
            }
            current_statement_begin__ = 15;
            // initialize data variables
            current_statement_begin__ = 20;
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 21;
            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data
            current_statement_begin__ = 20;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 27;
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 28;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 31;
            validate_non_negative_index("eta_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 32;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_fictitious_multipleB() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("eta_pr")))
            throw std::runtime_error("variable eta_pr missing");
        vals_r__ = context__.vals_r("eta_pr");
        pos__ = 0U;
        validate_non_negative_index("eta_pr", "N", N);
        context__.validate_dims("initialization", "eta_pr", "vector_d", context__.to_vec(N));
        vector_d eta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            eta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(eta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eta_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_pr;
            (void) eta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                eta_pr = in__.vector_constrain(N,lp__);
            else
                eta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 37;
            validate_non_negative_index("eta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, DUMMY_VAR__);
            stan::math::fill(eta,DUMMY_VAR__);
            current_statement_begin__ = 38;
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 40;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 41;
                stan::math::assign(get_base1_lhs(eta,i,"eta",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pr,i,"eta_pr",1)))));
                current_statement_begin__ = 42;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(eta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: eta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 37;
            check_greater_or_equal(function__,"eta",eta,0);
            check_less_or_equal(function__,"eta",eta,1);
            current_statement_begin__ = 38;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // model body

            current_statement_begin__ = 47;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 48;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 51;
            lp_accum__.add(normal_log<propto__>(eta_pr, 0, 1));
            current_statement_begin__ = 52;
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            current_statement_begin__ = 54;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 55;
                for (int bIdx = 1; bIdx <= get_base1(B,i,"B",1); ++bIdx) {
                    {
                    current_statement_begin__ = 57;
                    validate_non_negative_index("ev", "2", 2);
                    Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                    (void) ev;  // dummy to suppress unused var warning

                    stan::math::initialize(ev, DUMMY_VAR__);
                    stan::math::fill(ev,DUMMY_VAR__);
                    current_statement_begin__ = 58;
                    validate_non_negative_index("prob", "2", 2);
                    Eigen::Matrix<T__,Eigen::Dynamic,1>  prob(static_cast<Eigen::VectorXd::Index>(2));
                    (void) prob;  // dummy to suppress unused var warning

                    stan::math::initialize(prob, DUMMY_VAR__);
                    stan::math::fill(prob,DUMMY_VAR__);
                    current_statement_begin__ = 60;
                    T__ PE;
                    (void) PE;  // dummy to suppress unused var warning

                    stan::math::initialize(PE, DUMMY_VAR__);
                    stan::math::fill(PE,DUMMY_VAR__);
                    current_statement_begin__ = 61;
                    T__ PEnc;
                    (void) PEnc;  // dummy to suppress unused var warning

                    stan::math::initialize(PEnc, DUMMY_VAR__);
                    stan::math::fill(PEnc,DUMMY_VAR__);


                    current_statement_begin__ = 64;
                    stan::math::assign(ev, initV);
                    current_statement_begin__ = 66;
                    for (int t = 1; t <= get_base1(get_base1(Tsubj,i,"Tsubj",1),bIdx,"Tsubj",2); ++t) {

                        current_statement_begin__ = 68;
                        stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(ev,2,"ev",1) - get_base1(ev,1,"ev",1)))))));
                        current_statement_begin__ = 69;
                        stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                        current_statement_begin__ = 70;
                        lp_accum__.add(categorical_log<propto__>(get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3), prob));
                        current_statement_begin__ = 74;
                        stan::math::assign(PE, (get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3) - get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1)));
                        current_statement_begin__ = 75;
                        stan::math::assign(PEnc, (-(get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3)) - get_base1(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1)));
                        current_statement_begin__ = 78;
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1), (get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1) + (get_base1(eta,i,"eta",1) * PE)));
                        current_statement_begin__ = 79;
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1) + (get_base1(eta,i,"eta",1) * PEnc)));
                    }
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("eta_pr");
        names__.push_back("beta_pr");
        names__.push_back("eta");
        names__.push_back("beta");
        names__.push_back("mu_eta");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_pe_c");
        names__.push_back("mr_pe_nc");
        names__.push_back("mr_dv");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_fictitious_multipleB_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d eta_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 37;
            validate_non_negative_index("eta", "N", N);
            vector_d eta(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eta,DUMMY_VAR__);
            current_statement_begin__ = 38;
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 40;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 41;
                stan::math::assign(get_base1_lhs(eta,i,"eta",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pr,i,"eta_pr",1)))));
                current_statement_begin__ = 42;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            current_statement_begin__ = 37;
            check_greater_or_equal(function__,"eta",eta,0);
            check_less_or_equal(function__,"eta",eta,1);
            current_statement_begin__ = 38;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 87;
            double mu_eta(0.0);
            (void) mu_eta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_eta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_eta,DUMMY_VAR__);
            current_statement_begin__ = 88;
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            current_statement_begin__ = 91;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 94;
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "maxB", maxB);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<vector<double> > > mr_ev_c(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            current_statement_begin__ = 95;
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "maxB", maxB);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<vector<double> > > mr_ev_nc(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            current_statement_begin__ = 97;
            validate_non_negative_index("mr_pe_c", "N", N);
            validate_non_negative_index("mr_pe_c", "maxB", maxB);
            validate_non_negative_index("mr_pe_c", "T", T);
            vector<vector<vector<double> > > mr_pe_c(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_pe_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_c,DUMMY_VAR__);
            current_statement_begin__ = 98;
            validate_non_negative_index("mr_pe_nc", "N", N);
            validate_non_negative_index("mr_pe_nc", "maxB", maxB);
            validate_non_negative_index("mr_pe_nc", "T", T);
            vector<vector<vector<double> > > mr_pe_nc(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_pe_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_nc,DUMMY_VAR__);
            current_statement_begin__ = 99;
            validate_non_negative_index("mr_dv", "N", N);
            validate_non_negative_index("mr_dv", "maxB", maxB);
            validate_non_negative_index("mr_dv", "T", T);
            vector<vector<vector<double> > > mr_dv(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_dv, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_dv,DUMMY_VAR__);
            current_statement_begin__ = 102;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "maxB", maxB);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<vector<double> > > y_pred(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 105;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 106;
                for (int b = 1; b <= maxB; ++b) {

                    current_statement_begin__ = 107;
                    for (int t = 1; t <= T; ++t) {

                        current_statement_begin__ = 108;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),b,"mr_ev_c",2),t,"mr_ev_c",3), 0);
                        current_statement_begin__ = 109;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),b,"mr_ev_nc",2),t,"mr_ev_nc",3), 0);
                        current_statement_begin__ = 111;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),b,"mr_pe_c",2),t,"mr_pe_c",3), 0);
                        current_statement_begin__ = 112;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),b,"mr_pe_nc",2),t,"mr_pe_nc",3), 0);
                        current_statement_begin__ = 113;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),b,"mr_dv",2),t,"mr_dv",3), 0);
                        current_statement_begin__ = 115;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),b,"y_pred",2),t,"y_pred",3), -(1));
                    }
                }
            }
            current_statement_begin__ = 120;
            stan::math::assign(mu_eta, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 121;
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 10));

            current_statement_begin__ = 124;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 126;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 128;
                for (int bIdx = 1; bIdx <= get_base1(B,i,"B",1); ++bIdx) {
                    {
                    current_statement_begin__ = 130;
                    validate_non_negative_index("ev", "2", 2);
                    vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                    (void) ev;  // dummy to suppress unused var warning

                    stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(ev,DUMMY_VAR__);
                    current_statement_begin__ = 131;
                    validate_non_negative_index("prob", "2", 2);
                    vector_d prob(static_cast<Eigen::VectorXd::Index>(2));
                    (void) prob;  // dummy to suppress unused var warning

                    stan::math::initialize(prob, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(prob,DUMMY_VAR__);
                    current_statement_begin__ = 133;
                    double PE(0.0);
                    (void) PE;  // dummy to suppress unused var warning

                    stan::math::initialize(PE, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(PE,DUMMY_VAR__);
                    current_statement_begin__ = 134;
                    double PEnc(0.0);
                    (void) PEnc;  // dummy to suppress unused var warning

                    stan::math::initialize(PEnc, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(PEnc,DUMMY_VAR__);


                    current_statement_begin__ = 137;
                    stan::math::assign(ev, initV);
                    current_statement_begin__ = 139;
                    for (int t = 1; t <= get_base1(get_base1(Tsubj,i,"Tsubj",1),bIdx,"Tsubj",2); ++t) {

                        current_statement_begin__ = 141;
                        stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(ev,2,"ev",1) - get_base1(ev,1,"ev",1)))))));
                        current_statement_begin__ = 142;
                        stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                        current_statement_begin__ = 144;
                        stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_log(get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),prob)));
                        current_statement_begin__ = 147;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),bIdx,"y_pred",2),t,"y_pred",3), categorical_rng(prob, base_rng__));
                        current_statement_begin__ = 150;
                        stan::math::assign(PE, (get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3) - get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1)));
                        current_statement_begin__ = 151;
                        stan::math::assign(PEnc, (-(get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3)) - get_base1(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1)));
                        current_statement_begin__ = 154;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),bIdx,"mr_ev_c",2),t,"mr_ev_c",3), get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1));
                        current_statement_begin__ = 155;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),bIdx,"mr_ev_nc",2),t,"mr_ev_nc",3), get_base1(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1));
                        current_statement_begin__ = 157;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),bIdx,"mr_pe_c",2),t,"mr_pe_c",3), PE);
                        current_statement_begin__ = 158;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),bIdx,"mr_pe_nc",2),t,"mr_pe_nc",3), PEnc);
                        current_statement_begin__ = 159;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),bIdx,"mr_dv",2),t,"mr_dv",3), (PE - PEnc));
                        current_statement_begin__ = 162;
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1), (get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1) + (get_base1(eta,i,"eta",1) * PE)));
                        current_statement_begin__ = 163;
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1) + (get_base1(eta,i,"eta",1) * PEnc)));
                    }
                    }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 87;
            check_greater_or_equal(function__,"mu_eta",mu_eta,0);
            check_less_or_equal(function__,"mu_eta",mu_eta,1);
            current_statement_begin__ = 88;
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,10);
            current_statement_begin__ = 91;
            current_statement_begin__ = 94;
            current_statement_begin__ = 95;
            current_statement_begin__ = 97;
            current_statement_begin__ = 98;
            current_statement_begin__ = 99;
            current_statement_begin__ = 102;

            // write generated quantities
        vars__.push_back(mu_eta);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_ev_c[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_ev_nc[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_pe_c[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_pe_nc[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_dv[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(y_pred[k_0__][k_1__][k_2__]);
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_fictitious_multipleB";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_fictitious_rp_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_fictitious_rp");
    reader.add_event(174, 174, "end", "model_prl_fictitious_rp");
    return reader;
}

class model_prl_fictitious_rp : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > outcome;
    vector_d initV;
public:
    model_prl_fictitious_rp(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_fictitious_rp(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_fictitious_rp_namespace::model_prl_fictitious_rp";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 8;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 9;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 10;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 12;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 13;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 8;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 9;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 10;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 12;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],2);
                }
            }
            current_statement_begin__ = 13;
            // initialize data variables
            current_statement_begin__ = 18;
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 19;
            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data
            current_statement_begin__ = 18;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 25;
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 26;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 29;
            validate_non_negative_index("eta_pos_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 30;
            validate_non_negative_index("eta_neg_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 31;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_fictitious_rp() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("eta_pos_pr")))
            throw std::runtime_error("variable eta_pos_pr missing");
        vals_r__ = context__.vals_r("eta_pos_pr");
        pos__ = 0U;
        validate_non_negative_index("eta_pos_pr", "N", N);
        context__.validate_dims("initialization", "eta_pos_pr", "vector_d", context__.to_vec(N));
        vector_d eta_pos_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            eta_pos_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(eta_pos_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eta_pos_pr: ") + e.what());
        }

        if (!(context__.contains_r("eta_neg_pr")))
            throw std::runtime_error("variable eta_neg_pr missing");
        vals_r__ = context__.vals_r("eta_neg_pr");
        pos__ = 0U;
        validate_non_negative_index("eta_neg_pr", "N", N);
        context__.validate_dims("initialization", "eta_neg_pr", "vector_d", context__.to_vec(N));
        vector_d eta_neg_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            eta_neg_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(eta_neg_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eta_neg_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_pos_pr;
            (void) eta_pos_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                eta_pos_pr = in__.vector_constrain(N,lp__);
            else
                eta_pos_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_neg_pr;
            (void) eta_neg_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                eta_neg_pr = in__.vector_constrain(N,lp__);
            else
                eta_neg_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 36;
            validate_non_negative_index("eta_pos", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_pos(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta_pos;  // dummy to suppress unused var warning

            stan::math::initialize(eta_pos, DUMMY_VAR__);
            stan::math::fill(eta_pos,DUMMY_VAR__);
            current_statement_begin__ = 37;
            validate_non_negative_index("eta_neg", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta_neg(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta_neg;  // dummy to suppress unused var warning

            stan::math::initialize(eta_neg, DUMMY_VAR__);
            stan::math::fill(eta_neg,DUMMY_VAR__);
            current_statement_begin__ = 38;
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 40;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 41;
                stan::math::assign(get_base1_lhs(eta_pos,i,"eta_pos",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pos_pr,i,"eta_pos_pr",1)))));
                current_statement_begin__ = 42;
                stan::math::assign(get_base1_lhs(eta_neg,i,"eta_neg",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(eta_neg_pr,i,"eta_neg_pr",1)))));
                current_statement_begin__ = 43;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(eta_pos(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: eta_pos" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(eta_neg(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: eta_neg" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 36;
            check_greater_or_equal(function__,"eta_pos",eta_pos,0);
            check_less_or_equal(function__,"eta_pos",eta_pos,1);
            current_statement_begin__ = 37;
            check_greater_or_equal(function__,"eta_neg",eta_neg,0);
            check_less_or_equal(function__,"eta_neg",eta_neg,1);
            current_statement_begin__ = 38;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // model body

            current_statement_begin__ = 49;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 50;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 53;
            lp_accum__.add(normal_log<propto__>(eta_pos_pr, 0, 1));
            current_statement_begin__ = 54;
            lp_accum__.add(normal_log<propto__>(eta_neg_pr, 0, 1));
            current_statement_begin__ = 55;
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            current_statement_begin__ = 57;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 59;
                validate_non_negative_index("ev", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 60;
                validate_non_negative_index("prob", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  prob(static_cast<Eigen::VectorXd::Index>(2));
                (void) prob;  // dummy to suppress unused var warning

                stan::math::initialize(prob, DUMMY_VAR__);
                stan::math::fill(prob,DUMMY_VAR__);
                current_statement_begin__ = 62;
                T__ pe_c;
                (void) pe_c;  // dummy to suppress unused var warning

                stan::math::initialize(pe_c, DUMMY_VAR__);
                stan::math::fill(pe_c,DUMMY_VAR__);
                current_statement_begin__ = 63;
                T__ pe_nc;
                (void) pe_nc;  // dummy to suppress unused var warning

                stan::math::initialize(pe_nc, DUMMY_VAR__);
                stan::math::fill(pe_nc,DUMMY_VAR__);


                current_statement_begin__ = 66;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 68;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 70;
                    stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(ev,2,"ev",1) - get_base1(ev,1,"ev",1)))))));
                    current_statement_begin__ = 71;
                    stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                    current_statement_begin__ = 72;
                    lp_accum__.add(categorical_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), prob));
                    current_statement_begin__ = 75;
                    stan::math::assign(pe_c, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    current_statement_begin__ = 76;
                    stan::math::assign(pe_nc, (-(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1)));
                    current_statement_begin__ = 79;
                    if (as_bool(logical_gte(pe_c,0))) {

                        current_statement_begin__ = 80;
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta_pos,i,"eta_pos",1) * pe_c)));
                        current_statement_begin__ = 81;
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta_pos,i,"eta_pos",1) * pe_nc)));
                    } else {

                        current_statement_begin__ = 83;
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta_neg,i,"eta_neg",1) * pe_c)));
                        current_statement_begin__ = 84;
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta_neg,i,"eta_neg",1) * pe_nc)));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("eta_pos_pr");
        names__.push_back("eta_neg_pr");
        names__.push_back("beta_pr");
        names__.push_back("eta_pos");
        names__.push_back("eta_neg");
        names__.push_back("beta");
        names__.push_back("mu_eta_pos");
        names__.push_back("mu_eta_neg");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_pe_c");
        names__.push_back("mr_pe_nc");
        names__.push_back("mr_dv");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_fictitious_rp_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d eta_pos_pr = in__.vector_constrain(N);
        vector_d eta_neg_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_pos_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_neg_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 36;
            validate_non_negative_index("eta_pos", "N", N);
            vector_d eta_pos(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta_pos;  // dummy to suppress unused var warning

            stan::math::initialize(eta_pos, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eta_pos,DUMMY_VAR__);
            current_statement_begin__ = 37;
            validate_non_negative_index("eta_neg", "N", N);
            vector_d eta_neg(static_cast<Eigen::VectorXd::Index>(N));
            (void) eta_neg;  // dummy to suppress unused var warning

            stan::math::initialize(eta_neg, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eta_neg,DUMMY_VAR__);
            current_statement_begin__ = 38;
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 40;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 41;
                stan::math::assign(get_base1_lhs(eta_pos,i,"eta_pos",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(eta_pos_pr,i,"eta_pos_pr",1)))));
                current_statement_begin__ = 42;
                stan::math::assign(get_base1_lhs(eta_neg,i,"eta_neg",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(eta_neg_pr,i,"eta_neg_pr",1)))));
                current_statement_begin__ = 43;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 5));
            }

            // validate transformed parameters
            current_statement_begin__ = 36;
            check_greater_or_equal(function__,"eta_pos",eta_pos,0);
            check_less_or_equal(function__,"eta_pos",eta_pos,1);
            current_statement_begin__ = 37;
            check_greater_or_equal(function__,"eta_neg",eta_neg,0);
            check_less_or_equal(function__,"eta_neg",eta_neg,1);
            current_statement_begin__ = 38;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,5);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_pos[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(eta_neg[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 92;
            double mu_eta_pos(0.0);
            (void) mu_eta_pos;  // dummy to suppress unused var warning

            stan::math::initialize(mu_eta_pos, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_eta_pos,DUMMY_VAR__);
            current_statement_begin__ = 93;
            double mu_eta_neg(0.0);
            (void) mu_eta_neg;  // dummy to suppress unused var warning

            stan::math::initialize(mu_eta_neg, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_eta_neg,DUMMY_VAR__);
            current_statement_begin__ = 94;
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            current_statement_begin__ = 97;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 100;
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<double> > mr_ev_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            current_statement_begin__ = 101;
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<double> > mr_ev_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            current_statement_begin__ = 103;
            validate_non_negative_index("mr_pe_c", "N", N);
            validate_non_negative_index("mr_pe_c", "T", T);
            vector<vector<double> > mr_pe_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_c,DUMMY_VAR__);
            current_statement_begin__ = 104;
            validate_non_negative_index("mr_pe_nc", "N", N);
            validate_non_negative_index("mr_pe_nc", "T", T);
            vector<vector<double> > mr_pe_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe_nc,DUMMY_VAR__);
            current_statement_begin__ = 106;
            validate_non_negative_index("mr_dv", "N", N);
            validate_non_negative_index("mr_dv", "T", T);
            vector<vector<double> > mr_dv(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_dv, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_dv,DUMMY_VAR__);
            current_statement_begin__ = 109;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 112;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 113;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 114;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), 0);
                    current_statement_begin__ = 115;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), 0);
                    current_statement_begin__ = 116;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),t,"mr_pe_c",2), 0);
                    current_statement_begin__ = 117;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),t,"mr_pe_nc",2), 0);
                    current_statement_begin__ = 118;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),t,"mr_dv",2), 0);
                    current_statement_begin__ = 120;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 124;
            stan::math::assign(mu_eta_pos, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 125;
            stan::math::assign(mu_eta_neg, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 126;
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 5));

            current_statement_begin__ = 129;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 131;
                validate_non_negative_index("ev", "2", 2);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 132;
                validate_non_negative_index("prob", "2", 2);
                vector_d prob(static_cast<Eigen::VectorXd::Index>(2));
                (void) prob;  // dummy to suppress unused var warning

                stan::math::initialize(prob, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(prob,DUMMY_VAR__);
                current_statement_begin__ = 134;
                double pe_c(0.0);
                (void) pe_c;  // dummy to suppress unused var warning

                stan::math::initialize(pe_c, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pe_c,DUMMY_VAR__);
                current_statement_begin__ = 135;
                double pe_nc(0.0);
                (void) pe_nc;  // dummy to suppress unused var warning

                stan::math::initialize(pe_nc, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pe_nc,DUMMY_VAR__);


                current_statement_begin__ = 138;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 140;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 142;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 144;
                    stan::math::assign(get_base1_lhs(prob,1,"prob",1), (1 / (1 + exp((get_base1(beta,i,"beta",1) * (get_base1(ev,2,"ev",1) - get_base1(ev,1,"ev",1)))))));
                    current_statement_begin__ = 145;
                    stan::math::assign(get_base1_lhs(prob,2,"prob",1), (1 - get_base1(prob,1,"prob",1)));
                    current_statement_begin__ = 147;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),prob)));
                    current_statement_begin__ = 150;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(prob, base_rng__));
                    current_statement_begin__ = 153;
                    stan::math::assign(pe_c, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    current_statement_begin__ = 154;
                    stan::math::assign(pe_nc, (-(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2)) - get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1)));
                    current_statement_begin__ = 157;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1));
                    current_statement_begin__ = 158;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1));
                    current_statement_begin__ = 159;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_c,i,"mr_pe_c",1),t,"mr_pe_c",2), pe_c);
                    current_statement_begin__ = 160;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe_nc,i,"mr_pe_nc",1),t,"mr_pe_nc",2), pe_nc);
                    current_statement_begin__ = 161;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_dv,i,"mr_dv",1),t,"mr_dv",2), (pe_c - pe_nc));
                    current_statement_begin__ = 164;
                    if (as_bool(logical_gte(pe_c,0))) {

                        current_statement_begin__ = 165;
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta_pos,i,"eta_pos",1) * pe_c)));
                        current_statement_begin__ = 166;
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta_pos,i,"eta_pos",1) * pe_nc)));
                    } else {

                        current_statement_begin__ = 168;
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(eta_neg,i,"eta_neg",1) * pe_c)));
                        current_statement_begin__ = 169;
                        stan::math::assign(get_base1_lhs(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1), (get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1) + (get_base1(eta_neg,i,"eta_neg",1) * pe_nc)));
                    }
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 92;
            check_greater_or_equal(function__,"mu_eta_pos",mu_eta_pos,0);
            check_less_or_equal(function__,"mu_eta_pos",mu_eta_pos,1);
            current_statement_begin__ = 93;
            check_greater_or_equal(function__,"mu_eta_neg",mu_eta_neg,0);
            check_less_or_equal(function__,"mu_eta_neg",mu_eta_neg,1);
            current_statement_begin__ = 94;
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,5);
            current_statement_begin__ = 97;
            current_statement_begin__ = 100;
            current_statement_begin__ = 101;
            current_statement_begin__ = 103;
            current_statement_begin__ = 104;
            current_statement_begin__ = 106;
            current_statement_begin__ = 109;

            // write generated quantities
        vars__.push_back(mu_eta_pos);
        vars__.push_back(mu_eta_neg);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_dv[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_fictitious_rp";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pos_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_neg_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pos" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_neg" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta_pos";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta_neg";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pos_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_neg_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_pos" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "eta_neg" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta_pos";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_eta_neg";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_dv" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_rp_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_rp");
    reader.add_event(146, 146, "end", "model_prl_rp");
    return reader;
}

class model_prl_rp : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > choice;
    vector<vector<double> > outcome;
    vector_d initV;
public:
    model_prl_rp(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_rp(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_rp_namespace::model_prl_rp";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 8;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 9;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 10;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 12;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                size_t choice_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                    choice[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 13;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                size_t outcome_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                    outcome[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 8;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 9;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 10;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 12;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],-(1));
                    check_less_or_equal(function__,"choice[k0__][k1__]",choice[k0__][k1__],2);
                }
            }
            current_statement_begin__ = 13;
            // initialize data variables
            current_statement_begin__ = 18;
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 19;
            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data
            current_statement_begin__ = 18;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 25;
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 26;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 29;
            validate_non_negative_index("Apun_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 30;
            validate_non_negative_index("Arew_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 31;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_rp() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("Apun_pr")))
            throw std::runtime_error("variable Apun_pr missing");
        vals_r__ = context__.vals_r("Apun_pr");
        pos__ = 0U;
        validate_non_negative_index("Apun_pr", "N", N);
        context__.validate_dims("initialization", "Apun_pr", "vector_d", context__.to_vec(N));
        vector_d Apun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Apun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Apun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Apun_pr: ") + e.what());
        }

        if (!(context__.contains_r("Arew_pr")))
            throw std::runtime_error("variable Arew_pr missing");
        vals_r__ = context__.vals_r("Arew_pr");
        pos__ = 0U;
        validate_non_negative_index("Arew_pr", "N", N);
        context__.validate_dims("initialization", "Arew_pr", "vector_d", context__.to_vec(N));
        vector_d Arew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Arew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Arew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Arew_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun_pr;
            (void) Apun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Apun_pr = in__.vector_constrain(N,lp__);
            else
                Apun_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew_pr;
            (void) Arew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Arew_pr = in__.vector_constrain(N,lp__);
            else
                Arew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 36;
            validate_non_negative_index("Apun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, DUMMY_VAR__);
            stan::math::fill(Apun,DUMMY_VAR__);
            current_statement_begin__ = 37;
            validate_non_negative_index("Arew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, DUMMY_VAR__);
            stan::math::fill(Arew,DUMMY_VAR__);
            current_statement_begin__ = 38;
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 40;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 41;
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                current_statement_begin__ = 42;
                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                current_statement_begin__ = 43;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Apun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Apun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Arew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Arew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 36;
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            current_statement_begin__ = 37;
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            current_statement_begin__ = 38;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // model body

            current_statement_begin__ = 49;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 50;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 53;
            lp_accum__.add(normal_log<propto__>(Apun_pr, 0, 1));
            current_statement_begin__ = 54;
            lp_accum__.add(normal_log<propto__>(Arew_pr, 0, 1));
            current_statement_begin__ = 55;
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            current_statement_begin__ = 57;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 59;
                validate_non_negative_index("ev", "2", 2);
                Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, DUMMY_VAR__);
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 60;
                T__ pe;
                (void) pe;  // dummy to suppress unused var warning

                stan::math::initialize(pe, DUMMY_VAR__);
                stan::math::fill(pe,DUMMY_VAR__);


                current_statement_begin__ = 63;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 65;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 67;
                    lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(choice,i,"choice",1),t,"choice",2), multiply(ev,get_base1(beta,i,"beta",1))));
                    current_statement_begin__ = 70;
                    stan::math::assign(pe, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    current_statement_begin__ = 73;
                    if (as_bool(logical_gt(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {
                        current_statement_begin__ = 74;
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(Arew,i,"Arew",1) * pe)));
                    } else {
                        current_statement_begin__ = 76;
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(Apun,i,"Apun",1) * pe)));
                    }
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("Apun_pr");
        names__.push_back("Arew_pr");
        names__.push_back("beta_pr");
        names__.push_back("Apun");
        names__.push_back("Arew");
        names__.push_back("beta");
        names__.push_back("mu_Apun");
        names__.push_back("mu_Arew");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_pe");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_rp_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d Apun_pr = in__.vector_constrain(N);
        vector_d Arew_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 36;
            validate_non_negative_index("Apun", "N", N);
            vector_d Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Apun,DUMMY_VAR__);
            current_statement_begin__ = 37;
            validate_non_negative_index("Arew", "N", N);
            vector_d Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Arew,DUMMY_VAR__);
            current_statement_begin__ = 38;
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 40;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 41;
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                current_statement_begin__ = 42;
                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                current_statement_begin__ = 43;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            current_statement_begin__ = 36;
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            current_statement_begin__ = 37;
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            current_statement_begin__ = 38;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 83;
            double mu_Apun(0.0);
            (void) mu_Apun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Apun,DUMMY_VAR__);
            current_statement_begin__ = 84;
            double mu_Arew(0.0);
            (void) mu_Arew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Arew,DUMMY_VAR__);
            current_statement_begin__ = 85;
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            current_statement_begin__ = 88;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 91;
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<double> > mr_ev_c(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            current_statement_begin__ = 92;
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<double> > mr_ev_nc(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            current_statement_begin__ = 93;
            validate_non_negative_index("mr_pe", "N", N);
            validate_non_negative_index("mr_pe", "T", T);
            vector<vector<double> > mr_pe(N, (vector<double>(T, 0.0)));
            stan::math::initialize(mr_pe, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe,DUMMY_VAR__);
            current_statement_begin__ = 96;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 99;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 100;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 101;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), 0);
                    current_statement_begin__ = 102;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), 0);
                    current_statement_begin__ = 103;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe,i,"mr_pe",1),t,"mr_pe",2), 0);
                    current_statement_begin__ = 105;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 109;
            stan::math::assign(mu_Apun, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 110;
            stan::math::assign(mu_Arew, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 111;
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 10));

            current_statement_begin__ = 114;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 116;
                validate_non_negative_index("ev", "2", 2);
                vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                (void) ev;  // dummy to suppress unused var warning

                stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(ev,DUMMY_VAR__);
                current_statement_begin__ = 117;
                double pe(0.0);
                (void) pe;  // dummy to suppress unused var warning

                stan::math::initialize(pe, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(pe,DUMMY_VAR__);


                current_statement_begin__ = 120;
                stan::math::assign(ev, initV);
                current_statement_begin__ = 121;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 123;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 125;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(choice,i,"choice",1),t,"choice",2),multiply(ev,get_base1(beta,i,"beta",1)))));
                    current_statement_begin__ = 128;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), categorical_rng(softmax(multiply(ev,get_base1(beta,i,"beta",1))), base_rng__));
                    current_statement_begin__ = 131;
                    stan::math::assign(pe, (get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2) - get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1)));
                    current_statement_begin__ = 134;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),t,"mr_ev_c",2), get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1));
                    current_statement_begin__ = 135;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),t,"mr_ev_nc",2), get_base1(ev,(3 - get_base1(get_base1(choice,i,"choice",1),t,"choice",2)),"ev",1));
                    current_statement_begin__ = 136;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mr_pe,i,"mr_pe",1),t,"mr_pe",2), pe);
                    current_statement_begin__ = 139;
                    if (as_bool(logical_gt(get_base1(get_base1(outcome,i,"outcome",1),t,"outcome",2),0))) {
                        current_statement_begin__ = 140;
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(Arew,i,"Arew",1) * pe)));
                    } else {
                        current_statement_begin__ = 142;
                        stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1), (get_base1(ev,get_base1(get_base1(choice,i,"choice",1),t,"choice",2),"ev",1) + (get_base1(Apun,i,"Apun",1) * pe)));
                    }
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 83;
            check_greater_or_equal(function__,"mu_Apun",mu_Apun,0);
            check_less_or_equal(function__,"mu_Apun",mu_Apun,1);
            current_statement_begin__ = 84;
            check_greater_or_equal(function__,"mu_Arew",mu_Arew,0);
            check_less_or_equal(function__,"mu_Arew",mu_Arew,1);
            current_statement_begin__ = 85;
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,10);
            current_statement_begin__ = 88;
            current_statement_begin__ = 91;
            current_statement_begin__ = 92;
            current_statement_begin__ = 93;
            current_statement_begin__ = 96;

            // write generated quantities
        vars__.push_back(mu_Apun);
        vars__.push_back(mu_Arew);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_c[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_ev_nc[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(mr_pe[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_rp";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mr_pe" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_prl_rp_multipleB_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_prl_rp_multipleB");
    reader.add_event(157, 157, "end", "model_prl_rp_multipleB");
    return reader;
}

class model_prl_rp_multipleB : public prob_grad {
private:
    int N;
    int T;
    int maxB;
    vector<int> B;
    vector<vector<int> > Tsubj;
    vector<vector<vector<int> > > choice;
    vector<vector<vector<double> > > outcome;
    vector_d initV;
public:
    model_prl_rp_multipleB(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_prl_rp_multipleB(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_prl_rp_multipleB_namespace::model_prl_rp_multipleB";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 8;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 9;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 11;
            context__.validate_dims("data initialization", "maxB", "int", context__.to_vec());
            maxB = int(0);
            vals_i__ = context__.vals_i("maxB");
            pos__ = 0;
            maxB = vals_i__[pos__++];
            current_statement_begin__ = 12;
            validate_non_negative_index("B", "N", N);
            context__.validate_dims("data initialization", "B", "int", context__.to_vec(N));
            validate_non_negative_index("B", "N", N);
            B = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("B");
            pos__ = 0;
            size_t B_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < B_limit_0__; ++i_0__) {
                B[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 14;
            validate_non_negative_index("Tsubj", "N", N);
            validate_non_negative_index("Tsubj", "maxB", maxB);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N,maxB));
            validate_non_negative_index("Tsubj", "N", N);
            validate_non_negative_index("Tsubj", "maxB", maxB);
            Tsubj = std::vector<std::vector<int> >(N,std::vector<int>(maxB,int(0)));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_1__ = maxB;
            for (size_t i_1__ = 0; i_1__ < Tsubj_limit_1__; ++i_1__) {
                size_t Tsubj_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                    Tsubj[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 15;
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "maxB", maxB);
            validate_non_negative_index("choice", "T", T);
            context__.validate_dims("data initialization", "choice", "int", context__.to_vec(N,maxB,T));
            validate_non_negative_index("choice", "N", N);
            validate_non_negative_index("choice", "maxB", maxB);
            validate_non_negative_index("choice", "T", T);
            choice = std::vector<std::vector<std::vector<int> > >(N,std::vector<std::vector<int> >(maxB,std::vector<int>(T,int(0))));
            vals_i__ = context__.vals_i("choice");
            pos__ = 0;
            size_t choice_limit_2__ = T;
            for (size_t i_2__ = 0; i_2__ < choice_limit_2__; ++i_2__) {
                size_t choice_limit_1__ = maxB;
                for (size_t i_1__ = 0; i_1__ < choice_limit_1__; ++i_1__) {
                    size_t choice_limit_0__ = N;
                    for (size_t i_0__ = 0; i_0__ < choice_limit_0__; ++i_0__) {
                        choice[i_0__][i_1__][i_2__] = vals_i__[pos__++];
                    }
                }
            }
            current_statement_begin__ = 16;
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "maxB", maxB);
            validate_non_negative_index("outcome", "T", T);
            context__.validate_dims("data initialization", "outcome", "double", context__.to_vec(N,maxB,T));
            validate_non_negative_index("outcome", "N", N);
            validate_non_negative_index("outcome", "maxB", maxB);
            validate_non_negative_index("outcome", "T", T);
            outcome = std::vector<std::vector<std::vector<double> > >(N,std::vector<std::vector<double> >(maxB,std::vector<double>(T,double(0))));
            vals_r__ = context__.vals_r("outcome");
            pos__ = 0;
            size_t outcome_limit_2__ = T;
            for (size_t i_2__ = 0; i_2__ < outcome_limit_2__; ++i_2__) {
                size_t outcome_limit_1__ = maxB;
                for (size_t i_1__ = 0; i_1__ < outcome_limit_1__; ++i_1__) {
                    size_t outcome_limit_0__ = N;
                    for (size_t i_0__ = 0; i_0__ < outcome_limit_0__; ++i_0__) {
                        outcome[i_0__][i_1__][i_2__] = vals_r__[pos__++];
                    }
                }
            }

            // validate, data variables
            current_statement_begin__ = 8;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 9;
            check_greater_or_equal(function__,"T",T,0);
            current_statement_begin__ = 11;
            check_greater_or_equal(function__,"maxB",maxB,1);
            current_statement_begin__ = 12;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"B[k0__]",B[k0__],1);
            }
            current_statement_begin__ = 14;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < maxB; ++k1__) {
                    check_greater_or_equal(function__,"Tsubj[k0__][k1__]",Tsubj[k0__][k1__],0);
                    check_less_or_equal(function__,"Tsubj[k0__][k1__]",Tsubj[k0__][k1__],T);
                }
            }
            current_statement_begin__ = 15;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < maxB; ++k1__) {
                    for (int k2__ = 0; k2__ < T; ++k2__) {
                        check_greater_or_equal(function__,"choice[k0__][k1__][k2__]",choice[k0__][k1__][k2__],-(1));
                        check_less_or_equal(function__,"choice[k0__][k1__][k2__]",choice[k0__][k1__][k2__],2);
                    }
                }
            }
            current_statement_begin__ = 16;
            // initialize data variables
            current_statement_begin__ = 21;
            validate_non_negative_index("initV", "2", 2);
            initV = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            stan::math::fill(initV,DUMMY_VAR__);

            current_statement_begin__ = 22;
            stan::math::assign(initV, rep_vector(0.0,2));

            // validate transformed data
            current_statement_begin__ = 21;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 28;
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 29;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 32;
            validate_non_negative_index("Apun_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 33;
            validate_non_negative_index("Arew_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 34;
            validate_non_negative_index("beta_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_prl_rp_multipleB() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("Apun_pr")))
            throw std::runtime_error("variable Apun_pr missing");
        vals_r__ = context__.vals_r("Apun_pr");
        pos__ = 0U;
        validate_non_negative_index("Apun_pr", "N", N);
        context__.validate_dims("initialization", "Apun_pr", "vector_d", context__.to_vec(N));
        vector_d Apun_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Apun_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Apun_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Apun_pr: ") + e.what());
        }

        if (!(context__.contains_r("Arew_pr")))
            throw std::runtime_error("variable Arew_pr missing");
        vals_r__ = context__.vals_r("Arew_pr");
        pos__ = 0U;
        validate_non_negative_index("Arew_pr", "N", N);
        context__.validate_dims("initialization", "Arew_pr", "vector_d", context__.to_vec(N));
        vector_d Arew_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Arew_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Arew_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Arew_pr: ") + e.what());
        }

        if (!(context__.contains_r("beta_pr")))
            throw std::runtime_error("variable beta_pr missing");
        vals_r__ = context__.vals_r("beta_pr");
        pos__ = 0U;
        validate_non_negative_index("beta_pr", "N", N);
        context__.validate_dims("initialization", "beta_pr", "vector_d", context__.to_vec(N));
        vector_d beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun_pr;
            (void) Apun_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Apun_pr = in__.vector_constrain(N,lp__);
            else
                Apun_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew_pr;
            (void) Arew_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Arew_pr = in__.vector_constrain(N,lp__);
            else
                Arew_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta_pr;
            (void) beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_pr = in__.vector_constrain(N,lp__);
            else
                beta_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 39;
            validate_non_negative_index("Apun", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, DUMMY_VAR__);
            stan::math::fill(Apun,DUMMY_VAR__);
            current_statement_begin__ = 40;
            validate_non_negative_index("Arew", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, DUMMY_VAR__);
            stan::math::fill(Arew,DUMMY_VAR__);
            current_statement_begin__ = 41;
            validate_non_negative_index("beta", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 43;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 44;
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                current_statement_begin__ = 45;
                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                current_statement_begin__ = 46;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Apun(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Apun" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Arew(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Arew" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 39;
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            current_statement_begin__ = 40;
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            current_statement_begin__ = 41;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // model body

            current_statement_begin__ = 52;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 53;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 56;
            lp_accum__.add(normal_log<propto__>(Apun_pr, 0, 1));
            current_statement_begin__ = 57;
            lp_accum__.add(normal_log<propto__>(Arew_pr, 0, 1));
            current_statement_begin__ = 58;
            lp_accum__.add(normal_log<propto__>(beta_pr, 0, 1));
            current_statement_begin__ = 60;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 61;
                for (int bIdx = 1; bIdx <= get_base1(B,i,"B",1); ++bIdx) {
                    {
                    current_statement_begin__ = 63;
                    validate_non_negative_index("ev", "2", 2);
                    Eigen::Matrix<T__,Eigen::Dynamic,1>  ev(static_cast<Eigen::VectorXd::Index>(2));
                    (void) ev;  // dummy to suppress unused var warning

                    stan::math::initialize(ev, DUMMY_VAR__);
                    stan::math::fill(ev,DUMMY_VAR__);
                    current_statement_begin__ = 64;
                    T__ pe;
                    (void) pe;  // dummy to suppress unused var warning

                    stan::math::initialize(pe, DUMMY_VAR__);
                    stan::math::fill(pe,DUMMY_VAR__);


                    current_statement_begin__ = 67;
                    stan::math::assign(ev, initV);
                    current_statement_begin__ = 69;
                    for (int t = 1; t <= get_base1(get_base1(Tsubj,i,"Tsubj",1),bIdx,"Tsubj",2); ++t) {

                        current_statement_begin__ = 71;
                        lp_accum__.add(categorical_logit_log<propto__>(get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3), multiply(ev,get_base1(beta,i,"beta",1))));
                        current_statement_begin__ = 74;
                        stan::math::assign(pe, (get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3) - get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1)));
                        current_statement_begin__ = 77;
                        if (as_bool(logical_gt(get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3),0))) {
                            current_statement_begin__ = 78;
                            stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1), (get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1) + (get_base1(Arew,i,"Arew",1) * pe)));
                        } else {
                            current_statement_begin__ = 80;
                            stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1), (get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1) + (get_base1(Apun,i,"Apun",1) * pe)));
                        }
                    }
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("Apun_pr");
        names__.push_back("Arew_pr");
        names__.push_back("beta_pr");
        names__.push_back("Apun");
        names__.push_back("Arew");
        names__.push_back("beta");
        names__.push_back("mu_Apun");
        names__.push_back("mu_Arew");
        names__.push_back("mu_beta");
        names__.push_back("log_lik");
        names__.push_back("mr_ev_c");
        names__.push_back("mr_ev_nc");
        names__.push_back("mr_pe");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(maxB);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_prl_rp_multipleB_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d Apun_pr = in__.vector_constrain(N);
        vector_d Arew_pr = in__.vector_constrain(N);
        vector_d beta_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 39;
            validate_non_negative_index("Apun", "N", N);
            vector_d Apun(static_cast<Eigen::VectorXd::Index>(N));
            (void) Apun;  // dummy to suppress unused var warning

            stan::math::initialize(Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Apun,DUMMY_VAR__);
            current_statement_begin__ = 40;
            validate_non_negative_index("Arew", "N", N);
            vector_d Arew(static_cast<Eigen::VectorXd::Index>(N));
            (void) Arew;  // dummy to suppress unused var warning

            stan::math::initialize(Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Arew,DUMMY_VAR__);
            current_statement_begin__ = 41;
            validate_non_negative_index("beta", "N", N);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(N));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);


            current_statement_begin__ = 43;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 44;
                stan::math::assign(get_base1_lhs(Apun,i,"Apun",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(Apun_pr,i,"Apun_pr",1)))));
                current_statement_begin__ = 45;
                stan::math::assign(get_base1_lhs(Arew,i,"Arew",1), Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Arew_pr,i,"Arew_pr",1)))));
                current_statement_begin__ = 46;
                stan::math::assign(get_base1_lhs(beta,i,"beta",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(beta_pr,i,"beta_pr",1)))) * 10));
            }

            // validate transformed parameters
            current_statement_begin__ = 39;
            check_greater_or_equal(function__,"Apun",Apun,0);
            check_less_or_equal(function__,"Apun",Apun,1);
            current_statement_begin__ = 40;
            check_greater_or_equal(function__,"Arew",Arew,0);
            check_less_or_equal(function__,"Arew",Arew,1);
            current_statement_begin__ = 41;
            check_greater_or_equal(function__,"beta",beta,0);
            check_less_or_equal(function__,"beta",beta,10);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Apun[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Arew[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 88;
            double mu_Apun(0.0);
            (void) mu_Apun;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Apun, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Apun,DUMMY_VAR__);
            current_statement_begin__ = 89;
            double mu_Arew(0.0);
            (void) mu_Arew;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Arew, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Arew,DUMMY_VAR__);
            current_statement_begin__ = 90;
            double mu_beta(0.0);
            (void) mu_beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_beta,DUMMY_VAR__);
            current_statement_begin__ = 93;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 96;
            validate_non_negative_index("mr_ev_c", "N", N);
            validate_non_negative_index("mr_ev_c", "maxB", maxB);
            validate_non_negative_index("mr_ev_c", "T", T);
            vector<vector<vector<double> > > mr_ev_c(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_ev_c, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_c,DUMMY_VAR__);
            current_statement_begin__ = 97;
            validate_non_negative_index("mr_ev_nc", "N", N);
            validate_non_negative_index("mr_ev_nc", "maxB", maxB);
            validate_non_negative_index("mr_ev_nc", "T", T);
            vector<vector<vector<double> > > mr_ev_nc(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_ev_nc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_ev_nc,DUMMY_VAR__);
            current_statement_begin__ = 98;
            validate_non_negative_index("mr_pe", "N", N);
            validate_non_negative_index("mr_pe", "maxB", maxB);
            validate_non_negative_index("mr_pe", "T", T);
            vector<vector<vector<double> > > mr_pe(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(mr_pe, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mr_pe,DUMMY_VAR__);
            current_statement_begin__ = 101;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "maxB", maxB);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<vector<double> > > y_pred(N, (vector<vector<double> >(maxB, (vector<double>(T, 0.0)))));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 104;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 105;
                for (int b = 1; b <= maxB; ++b) {

                    current_statement_begin__ = 106;
                    for (int t = 1; t <= T; ++t) {

                        current_statement_begin__ = 107;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),b,"mr_ev_c",2),t,"mr_ev_c",3), 0);
                        current_statement_begin__ = 108;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),b,"mr_ev_nc",2),t,"mr_ev_nc",3), 0);
                        current_statement_begin__ = 109;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_pe,i,"mr_pe",1),b,"mr_pe",2),t,"mr_pe",3), 0);
                        current_statement_begin__ = 111;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),b,"y_pred",2),t,"y_pred",3), -(1));
                    }
                }
            }
            current_statement_begin__ = 116;
            stan::math::assign(mu_Apun, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 117;
            stan::math::assign(mu_Arew, Phi_approx(get_base1(mu_p,2,"mu_p",1)));
            current_statement_begin__ = 118;
            stan::math::assign(mu_beta, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 10));

            current_statement_begin__ = 121;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 123;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 125;
                for (int bIdx = 1; bIdx <= get_base1(B,i,"B",1); ++bIdx) {
                    {
                    current_statement_begin__ = 127;
                    validate_non_negative_index("ev", "2", 2);
                    vector_d ev(static_cast<Eigen::VectorXd::Index>(2));
                    (void) ev;  // dummy to suppress unused var warning

                    stan::math::initialize(ev, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(ev,DUMMY_VAR__);
                    current_statement_begin__ = 128;
                    double pe(0.0);
                    (void) pe;  // dummy to suppress unused var warning

                    stan::math::initialize(pe, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(pe,DUMMY_VAR__);


                    current_statement_begin__ = 131;
                    stan::math::assign(ev, initV);
                    current_statement_begin__ = 133;
                    for (int t = 1; t <= get_base1(get_base1(Tsubj,i,"Tsubj",1),bIdx,"Tsubj",2); ++t) {

                        current_statement_begin__ = 135;
                        stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + categorical_logit_log(get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),multiply(ev,get_base1(beta,i,"beta",1)))));
                        current_statement_begin__ = 138;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),bIdx,"y_pred",2),t,"y_pred",3), categorical_rng(softmax(multiply(ev,get_base1(beta,i,"beta",1))), base_rng__));
                        current_statement_begin__ = 141;
                        stan::math::assign(pe, (get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3) - get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1)));
                        current_statement_begin__ = 144;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_c,i,"mr_ev_c",1),bIdx,"mr_ev_c",2),t,"mr_ev_c",3), get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1));
                        current_statement_begin__ = 145;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_ev_nc,i,"mr_ev_nc",1),bIdx,"mr_ev_nc",2),t,"mr_ev_nc",3), get_base1(ev,(3 - get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3)),"ev",1));
                        current_statement_begin__ = 146;
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mr_pe,i,"mr_pe",1),bIdx,"mr_pe",2),t,"mr_pe",3), pe);
                        current_statement_begin__ = 149;
                        if (as_bool(logical_gt(get_base1(get_base1(get_base1(outcome,i,"outcome",1),bIdx,"outcome",2),t,"outcome",3),0))) {
                            current_statement_begin__ = 150;
                            stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1), (get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1) + (get_base1(Arew,i,"Arew",1) * pe)));
                        } else {
                            current_statement_begin__ = 152;
                            stan::math::assign(get_base1_lhs(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1), (get_base1(ev,get_base1(get_base1(get_base1(choice,i,"choice",1),bIdx,"choice",2),t,"choice",3),"ev",1) + (get_base1(Apun,i,"Apun",1) * pe)));
                        }
                    }
                    }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 88;
            check_greater_or_equal(function__,"mu_Apun",mu_Apun,0);
            check_less_or_equal(function__,"mu_Apun",mu_Apun,1);
            current_statement_begin__ = 89;
            check_greater_or_equal(function__,"mu_Arew",mu_Arew,0);
            check_less_or_equal(function__,"mu_Arew",mu_Arew,1);
            current_statement_begin__ = 90;
            check_greater_or_equal(function__,"mu_beta",mu_beta,0);
            check_less_or_equal(function__,"mu_beta",mu_beta,10);
            current_statement_begin__ = 93;
            current_statement_begin__ = 96;
            current_statement_begin__ = 97;
            current_statement_begin__ = 98;
            current_statement_begin__ = 101;

            // write generated quantities
        vars__.push_back(mu_Apun);
        vars__.push_back(mu_Arew);
        vars__.push_back(mu_beta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_ev_c[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_ev_nc[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(mr_pe[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < T; ++k_2__) {
                for (int k_1__ = 0; k_1__ < maxB; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                    vars__.push_back(y_pred[k_0__][k_1__][k_2__]);
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_prl_rp_multipleB";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_pe" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Apun" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Arew" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Apun";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Arew";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_beta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_c" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_ev_nc" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mr_pe" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= T; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= maxB; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ra_noLA_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ra_noLA");
    reader.add_event(92, 92, "end", "model_ra_noLA");
    return reader;
}

class model_ra_noLA : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > gamble;
    vector<vector<double> > gain;
    vector<vector<double> > cert;
    vector<vector<double> > loss;
public:
    model_ra_noLA(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ra_noLA(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ra_noLA_namespace::model_ra_noLA";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            context__.validate_dims("data initialization", "gamble", "int", context__.to_vec(N,T));
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            gamble = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("gamble");
            pos__ = 0;
            size_t gamble_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gamble_limit_1__; ++i_1__) {
                size_t gamble_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gamble_limit_0__; ++i_0__) {
                    gamble[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            context__.validate_dims("data initialization", "gain", "double", context__.to_vec(N,T));
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            gain = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("gain");
            pos__ = 0;
            size_t gain_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gain_limit_1__; ++i_1__) {
                size_t gain_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gain_limit_0__; ++i_0__) {
                    gain[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            context__.validate_dims("data initialization", "cert", "double", context__.to_vec(N,T));
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            cert = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("cert");
            pos__ = 0;
            size_t cert_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cert_limit_1__; ++i_1__) {
                size_t cert_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cert_limit_0__; ++i_0__) {
                    cert[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            context__.validate_dims("data initialization", "loss", "double", context__.to_vec(N,T));
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            loss = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("loss");
            pos__ = 0;
            size_t loss_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < loss_limit_1__; ++i_1__) {
                size_t loss_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < loss_limit_0__; ++i_0__) {
                    loss[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],-(1));
                    check_less_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],1);
                }
            }
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gain[k0__][k1__]",gain[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 7;
            current_statement_begin__ = 8;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"loss[k0__][k1__]",loss[k0__][k1__],0);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 15;
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 16;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 17;
            validate_non_negative_index("rho_p", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 18;
            validate_non_negative_index("tau_p", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ra_noLA() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("rho_p")))
            throw std::runtime_error("variable rho_p missing");
        vals_r__ = context__.vals_r("rho_p");
        pos__ = 0U;
        validate_non_negative_index("rho_p", "N", N);
        context__.validate_dims("initialization", "rho_p", "vector_d", context__.to_vec(N));
        vector_d rho_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_p: ") + e.what());
        }

        if (!(context__.contains_r("tau_p")))
            throw std::runtime_error("variable tau_p missing");
        vals_r__ = context__.vals_r("tau_p");
        pos__ = 0U;
        validate_non_negative_index("tau_p", "N", N);
        context__.validate_dims("initialization", "tau_p", "vector_d", context__.to_vec(N));
        vector_d tau_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_p: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_p;
            (void) rho_p;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_p = in__.vector_constrain(N,lp__);
            else
                rho_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_p;
            (void) tau_p;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_p = in__.vector_constrain(N,lp__);
            else
                tau_p = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 22;
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);
            current_statement_begin__ = 23;
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 25;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 26;
                stan::math::assign(get_base1_lhs(rho,i,"rho",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(rho_p,i,"rho_p",1)))) * 2));
            }
            current_statement_begin__ = 28;
            stan::math::assign(tau, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),tau_p))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 22;
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,2);
            current_statement_begin__ = 23;
            check_greater_or_equal(function__,"tau",tau,0);

            // model body

            current_statement_begin__ = 34;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            current_statement_begin__ = 35;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5.0));
            current_statement_begin__ = 38;
            lp_accum__.add(normal_log<propto__>(rho_p, 0, 1.0));
            current_statement_begin__ = 39;
            lp_accum__.add(normal_log<propto__>(tau_p, 0, 1.0));
            current_statement_begin__ = 41;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 42;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    current_statement_begin__ = 43;
                    T__ evSafe;
                    (void) evSafe;  // dummy to suppress unused var warning

                    stan::math::initialize(evSafe, DUMMY_VAR__);
                    stan::math::fill(evSafe,DUMMY_VAR__);
                    current_statement_begin__ = 44;
                    T__ evGamble;
                    (void) evGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(evGamble, DUMMY_VAR__);
                    stan::math::fill(evGamble,DUMMY_VAR__);
                    current_statement_begin__ = 45;
                    T__ pGamble;
                    (void) pGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(pGamble, DUMMY_VAR__);
                    stan::math::fill(pGamble,DUMMY_VAR__);


                    current_statement_begin__ = 47;
                    stan::math::assign(evSafe, pow(get_base1(get_base1(cert,i,"cert",1),t,"cert",2),get_base1(rho,i,"rho",1)));
                    current_statement_begin__ = 48;
                    stan::math::assign(evGamble, (0.5 * (pow(get_base1(get_base1(gain,i,"gain",1),t,"gain",2),get_base1(rho,i,"rho",1)) - pow(get_base1(get_base1(loss,i,"loss",1),t,"loss",2),get_base1(rho,i,"rho",1)))));
                    current_statement_begin__ = 49;
                    stan::math::assign(pGamble, inv_logit((get_base1(tau,i,"tau",1) * (evGamble - evSafe))));
                    current_statement_begin__ = 50;
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2), pGamble));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("rho_p");
        names__.push_back("tau_p");
        names__.push_back("rho");
        names__.push_back("tau");
        names__.push_back("mu_rho");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ra_noLA_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d rho_p = in__.vector_constrain(N);
        vector_d tau_p = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_p[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 22;
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);
            current_statement_begin__ = 23;
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 25;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 26;
                stan::math::assign(get_base1_lhs(rho,i,"rho",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(rho_p,i,"rho_p",1)))) * 2));
            }
            current_statement_begin__ = 28;
            stan::math::assign(tau, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),tau_p))));

            // validate transformed parameters
            current_statement_begin__ = 22;
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,2);
            current_statement_begin__ = 23;
            check_greater_or_equal(function__,"tau",tau,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 55;
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            current_statement_begin__ = 56;
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            current_statement_begin__ = 58;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 61;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 64;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 65;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 66;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 70;
            stan::math::assign(mu_rho, (Phi_approx(get_base1(mu_p,1,"mu_p",1)) * 2));
            current_statement_begin__ = 71;
            stan::math::assign(mu_tau, exp(get_base1(mu_p,2,"mu_p",1)));

            current_statement_begin__ = 74;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 75;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 76;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    current_statement_begin__ = 77;
                    double evSafe(0.0);
                    (void) evSafe;  // dummy to suppress unused var warning

                    stan::math::initialize(evSafe, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(evSafe,DUMMY_VAR__);
                    current_statement_begin__ = 78;
                    double evGamble(0.0);
                    (void) evGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(evGamble, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(evGamble,DUMMY_VAR__);
                    current_statement_begin__ = 79;
                    double pGamble(0.0);
                    (void) pGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(pGamble, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(pGamble,DUMMY_VAR__);


                    current_statement_begin__ = 82;
                    stan::math::assign(evSafe, pow(get_base1(get_base1(cert,i,"cert",1),t,"cert",2),get_base1(rho,i,"rho",1)));
                    current_statement_begin__ = 83;
                    stan::math::assign(evGamble, (0.5 * (pow(get_base1(get_base1(gain,i,"gain",1),t,"gain",2),get_base1(rho,i,"rho",1)) - pow(get_base1(get_base1(loss,i,"loss",1),t,"loss",2),get_base1(rho,i,"rho",1)))));
                    current_statement_begin__ = 84;
                    stan::math::assign(pGamble, inv_logit((get_base1(tau,i,"tau",1) * (evGamble - evSafe))));
                    current_statement_begin__ = 85;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2),pGamble)));
                    current_statement_begin__ = 88;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(pGamble, base_rng__));
                    }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 55;
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            check_less_or_equal(function__,"mu_rho",mu_rho,2);
            current_statement_begin__ = 56;
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);
            current_statement_begin__ = 58;
            current_statement_begin__ = 61;

            // write generated quantities
        vars__.push_back(mu_rho);
        vars__.push_back(mu_tau);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ra_noLA";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ra_noRA_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ra_noRA");
    reader.add_event(92, 92, "end", "model_ra_noRA");
    return reader;
}

class model_ra_noRA : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > gamble;
    vector<vector<double> > gain;
    vector<vector<double> > cert;
    vector<vector<double> > loss;
public:
    model_ra_noRA(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ra_noRA(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ra_noRA_namespace::model_ra_noRA";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            context__.validate_dims("data initialization", "gamble", "int", context__.to_vec(N,T));
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            gamble = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("gamble");
            pos__ = 0;
            size_t gamble_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gamble_limit_1__; ++i_1__) {
                size_t gamble_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gamble_limit_0__; ++i_0__) {
                    gamble[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            context__.validate_dims("data initialization", "gain", "double", context__.to_vec(N,T));
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            gain = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("gain");
            pos__ = 0;
            size_t gain_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gain_limit_1__; ++i_1__) {
                size_t gain_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gain_limit_0__; ++i_0__) {
                    gain[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            context__.validate_dims("data initialization", "cert", "double", context__.to_vec(N,T));
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            cert = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("cert");
            pos__ = 0;
            size_t cert_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cert_limit_1__; ++i_1__) {
                size_t cert_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cert_limit_0__; ++i_0__) {
                    cert[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            context__.validate_dims("data initialization", "loss", "double", context__.to_vec(N,T));
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            loss = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("loss");
            pos__ = 0;
            size_t loss_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < loss_limit_1__; ++i_1__) {
                size_t loss_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < loss_limit_0__; ++i_0__) {
                    loss[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],-(1));
                    check_less_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],1);
                }
            }
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gain[k0__][k1__]",gain[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 7;
            current_statement_begin__ = 8;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"loss[k0__][k1__]",loss[k0__][k1__],0);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 15;
            validate_non_negative_index("mu_p", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 16;
            validate_non_negative_index("sigma", "2", 2);
            num_params_r__ += 2;
            current_statement_begin__ = 17;
            validate_non_negative_index("lambda_p", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 18;
            validate_non_negative_index("tau_p", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ra_noRA() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "2", 2);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(2));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "2", 2);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(2));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("lambda_p")))
            throw std::runtime_error("variable lambda_p missing");
        vals_r__ = context__.vals_r("lambda_p");
        pos__ = 0U;
        validate_non_negative_index("lambda_p", "N", N);
        context__.validate_dims("initialization", "lambda_p", "vector_d", context__.to_vec(N));
        vector_d lambda_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            lambda_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(lambda_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_p: ") + e.what());
        }

        if (!(context__.contains_r("tau_p")))
            throw std::runtime_error("variable tau_p missing");
        vals_r__ = context__.vals_r("tau_p");
        pos__ = 0U;
        validate_non_negative_index("tau_p", "N", N);
        context__.validate_dims("initialization", "tau_p", "vector_d", context__.to_vec(N));
        vector_d tau_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_p: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(2,lp__);
            else
                mu_p = in__.vector_constrain(2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,2,lp__);
            else
                sigma = in__.vector_lb_constrain(0,2);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda_p;
            (void) lambda_p;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_p = in__.vector_constrain(N,lp__);
            else
                lambda_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_p;
            (void) tau_p;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_p = in__.vector_constrain(N,lp__);
            else
                tau_p = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 22;
            validate_non_negative_index("lambda", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, DUMMY_VAR__);
            stan::math::fill(lambda,DUMMY_VAR__);
            current_statement_begin__ = 23;
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 25;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 26;
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(lambda_p,i,"lambda_p",1)))) * 5));
            }
            current_statement_begin__ = 28;
            stan::math::assign(tau, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),tau_p))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(lambda(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: lambda" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 22;
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,5);
            current_statement_begin__ = 23;
            check_greater_or_equal(function__,"tau",tau,0);

            // model body

            current_statement_begin__ = 34;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            current_statement_begin__ = 35;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5.0));
            current_statement_begin__ = 38;
            lp_accum__.add(normal_log<propto__>(lambda_p, 0, 1.0));
            current_statement_begin__ = 39;
            lp_accum__.add(normal_log<propto__>(tau_p, 0, 1.0));
            current_statement_begin__ = 41;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 42;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    current_statement_begin__ = 43;
                    T__ evSafe;
                    (void) evSafe;  // dummy to suppress unused var warning

                    stan::math::initialize(evSafe, DUMMY_VAR__);
                    stan::math::fill(evSafe,DUMMY_VAR__);
                    current_statement_begin__ = 44;
                    T__ evGamble;
                    (void) evGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(evGamble, DUMMY_VAR__);
                    stan::math::fill(evGamble,DUMMY_VAR__);
                    current_statement_begin__ = 45;
                    T__ pGamble;
                    (void) pGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(pGamble, DUMMY_VAR__);
                    stan::math::fill(pGamble,DUMMY_VAR__);


                    current_statement_begin__ = 48;
                    stan::math::assign(evSafe, get_base1(get_base1(cert,i,"cert",1),t,"cert",2));
                    current_statement_begin__ = 49;
                    stan::math::assign(evGamble, (0.5 * (get_base1(get_base1(gain,i,"gain",1),t,"gain",2) - (get_base1(lambda,i,"lambda",1) * get_base1(get_base1(loss,i,"loss",1),t,"loss",2)))));
                    current_statement_begin__ = 50;
                    stan::math::assign(pGamble, inv_logit((get_base1(tau,i,"tau",1) * (evGamble - evSafe))));
                    current_statement_begin__ = 51;
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2), pGamble));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("lambda_p");
        names__.push_back("tau_p");
        names__.push_back("lambda");
        names__.push_back("tau");
        names__.push_back("mu_lambda");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ra_noRA_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(2);
        vector_d sigma = in__.vector_lb_constrain(0,2);
        vector_d lambda_p = in__.vector_constrain(N);
        vector_d tau_p = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_p[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 22;
            validate_non_negative_index("lambda", "N", N);
            vector_d lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(lambda,DUMMY_VAR__);
            current_statement_begin__ = 23;
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 25;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 26;
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(lambda_p,i,"lambda_p",1)))) * 5));
            }
            current_statement_begin__ = 28;
            stan::math::assign(tau, exp(add(get_base1(mu_p,2,"mu_p",1),multiply(get_base1(sigma,2,"sigma",1),tau_p))));

            // validate transformed parameters
            current_statement_begin__ = 22;
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,5);
            current_statement_begin__ = 23;
            check_greater_or_equal(function__,"tau",tau,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 56;
            double mu_lambda(0.0);
            (void) mu_lambda;  // dummy to suppress unused var warning

            stan::math::initialize(mu_lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_lambda,DUMMY_VAR__);
            current_statement_begin__ = 57;
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            current_statement_begin__ = 59;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 62;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 65;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 66;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 67;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 71;
            stan::math::assign(mu_lambda, (Phi_approx(get_base1(mu_p,1,"mu_p",1)) * 5));
            current_statement_begin__ = 72;
            stan::math::assign(mu_tau, exp(get_base1(mu_p,2,"mu_p",1)));

            current_statement_begin__ = 75;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 76;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 77;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    current_statement_begin__ = 78;
                    double evSafe(0.0);
                    (void) evSafe;  // dummy to suppress unused var warning

                    stan::math::initialize(evSafe, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(evSafe,DUMMY_VAR__);
                    current_statement_begin__ = 79;
                    double evGamble(0.0);
                    (void) evGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(evGamble, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(evGamble,DUMMY_VAR__);
                    current_statement_begin__ = 80;
                    double pGamble(0.0);
                    (void) pGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(pGamble, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(pGamble,DUMMY_VAR__);


                    current_statement_begin__ = 82;
                    stan::math::assign(evSafe, get_base1(get_base1(cert,i,"cert",1),t,"cert",2));
                    current_statement_begin__ = 83;
                    stan::math::assign(evGamble, (0.5 * (get_base1(get_base1(gain,i,"gain",1),t,"gain",2) - (get_base1(lambda,i,"lambda",1) * get_base1(get_base1(loss,i,"loss",1),t,"loss",2)))));
                    current_statement_begin__ = 84;
                    stan::math::assign(pGamble, inv_logit((get_base1(tau,i,"tau",1) * (evGamble - evSafe))));
                    current_statement_begin__ = 85;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2),pGamble)));
                    current_statement_begin__ = 88;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(pGamble, base_rng__));
                    }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 56;
            check_greater_or_equal(function__,"mu_lambda",mu_lambda,0);
            check_less_or_equal(function__,"mu_lambda",mu_lambda,5);
            current_statement_begin__ = 57;
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);
            current_statement_begin__ = 59;
            current_statement_begin__ = 62;

            // write generated quantities
        vars__.push_back(mu_lambda);
        vars__.push_back(mu_tau);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ra_noRA";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ra_prospect_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ra_prospect");
    reader.add_event(94, 94, "end", "model_ra_prospect");
    return reader;
}

class model_ra_prospect : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<int> > gamble;
    vector<vector<double> > cert;
    vector<vector<double> > gain;
    vector<vector<double> > loss;
public:
    model_ra_prospect(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ra_prospect(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ra_prospect_namespace::model_ra_prospect";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            context__.validate_dims("data initialization", "gamble", "int", context__.to_vec(N,T));
            validate_non_negative_index("gamble", "N", N);
            validate_non_negative_index("gamble", "T", T);
            gamble = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("gamble");
            pos__ = 0;
            size_t gamble_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gamble_limit_1__; ++i_1__) {
                size_t gamble_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gamble_limit_0__; ++i_0__) {
                    gamble[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            context__.validate_dims("data initialization", "cert", "double", context__.to_vec(N,T));
            validate_non_negative_index("cert", "N", N);
            validate_non_negative_index("cert", "T", T);
            cert = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("cert");
            pos__ = 0;
            size_t cert_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < cert_limit_1__; ++i_1__) {
                size_t cert_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < cert_limit_0__; ++i_0__) {
                    cert[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 7;
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            context__.validate_dims("data initialization", "gain", "double", context__.to_vec(N,T));
            validate_non_negative_index("gain", "N", N);
            validate_non_negative_index("gain", "T", T);
            gain = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("gain");
            pos__ = 0;
            size_t gain_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < gain_limit_1__; ++i_1__) {
                size_t gain_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < gain_limit_0__; ++i_0__) {
                    gain[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 8;
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            context__.validate_dims("data initialization", "loss", "double", context__.to_vec(N,T));
            validate_non_negative_index("loss", "N", N);
            validate_non_negative_index("loss", "T", T);
            loss = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("loss");
            pos__ = 0;
            size_t loss_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < loss_limit_1__; ++i_1__) {
                size_t loss_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < loss_limit_0__; ++i_0__) {
                    loss[i_0__][i_1__] = vals_r__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],-(1));
                    check_less_or_equal(function__,"gamble[k0__][k1__]",gamble[k0__][k1__],1);
                }
            }
            current_statement_begin__ = 6;
            current_statement_begin__ = 7;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"gain[k0__][k1__]",gain[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 8;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"loss[k0__][k1__]",loss[k0__][k1__],0);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 13;
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 14;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 15;
            validate_non_negative_index("rho_p", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 16;
            validate_non_negative_index("lambda_p", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 17;
            validate_non_negative_index("tau_p", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ra_prospect() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("rho_p")))
            throw std::runtime_error("variable rho_p missing");
        vals_r__ = context__.vals_r("rho_p");
        pos__ = 0U;
        validate_non_negative_index("rho_p", "N", N);
        context__.validate_dims("initialization", "rho_p", "vector_d", context__.to_vec(N));
        vector_d rho_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            rho_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rho_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rho_p: ") + e.what());
        }

        if (!(context__.contains_r("lambda_p")))
            throw std::runtime_error("variable lambda_p missing");
        vals_r__ = context__.vals_r("lambda_p");
        pos__ = 0U;
        validate_non_negative_index("lambda_p", "N", N);
        context__.validate_dims("initialization", "lambda_p", "vector_d", context__.to_vec(N));
        vector_d lambda_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            lambda_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(lambda_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_p: ") + e.what());
        }

        if (!(context__.contains_r("tau_p")))
            throw std::runtime_error("variable tau_p missing");
        vals_r__ = context__.vals_r("tau_p");
        pos__ = 0U;
        validate_non_negative_index("tau_p", "N", N);
        context__.validate_dims("initialization", "tau_p", "vector_d", context__.to_vec(N));
        vector_d tau_p(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_p: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho_p;
            (void) rho_p;  // dummy to suppress unused var warning
            if (jacobian__)
                rho_p = in__.vector_constrain(N,lp__);
            else
                rho_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda_p;
            (void) lambda_p;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_p = in__.vector_constrain(N,lp__);
            else
                lambda_p = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_p;
            (void) tau_p;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_p = in__.vector_constrain(N,lp__);
            else
                tau_p = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 20;
            validate_non_negative_index("rho", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, DUMMY_VAR__);
            stan::math::fill(rho,DUMMY_VAR__);
            current_statement_begin__ = 21;
            validate_non_negative_index("lambda", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, DUMMY_VAR__);
            stan::math::fill(lambda,DUMMY_VAR__);
            current_statement_begin__ = 22;
            validate_non_negative_index("tau", "N", N);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 24;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 25;
                stan::math::assign(get_base1_lhs(rho,i,"rho",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(rho_p,i,"rho_p",1)))) * 2));
                current_statement_begin__ = 26;
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(lambda_p,i,"lambda_p",1)))) * 5));
            }
            current_statement_begin__ = 28;
            stan::math::assign(tau, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),tau_p))));

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(rho(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rho" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(lambda(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: lambda" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 20;
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,2);
            current_statement_begin__ = 21;
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,5);
            current_statement_begin__ = 22;
            check_greater_or_equal(function__,"tau",tau,0);

            // model body

            current_statement_begin__ = 33;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1.0));
            current_statement_begin__ = 34;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5.0));
            current_statement_begin__ = 37;
            lp_accum__.add(normal_log<propto__>(rho_p, 0, 1.0));
            current_statement_begin__ = 38;
            lp_accum__.add(normal_log<propto__>(lambda_p, 0, 1.0));
            current_statement_begin__ = 39;
            lp_accum__.add(normal_log<propto__>(tau_p, 0, 1.0));
            current_statement_begin__ = 41;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 42;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    current_statement_begin__ = 43;
                    T__ evSafe;
                    (void) evSafe;  // dummy to suppress unused var warning

                    stan::math::initialize(evSafe, DUMMY_VAR__);
                    stan::math::fill(evSafe,DUMMY_VAR__);
                    current_statement_begin__ = 44;
                    T__ evGamble;
                    (void) evGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(evGamble, DUMMY_VAR__);
                    stan::math::fill(evGamble,DUMMY_VAR__);
                    current_statement_begin__ = 45;
                    T__ pGamble;
                    (void) pGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(pGamble, DUMMY_VAR__);
                    stan::math::fill(pGamble,DUMMY_VAR__);


                    current_statement_begin__ = 48;
                    stan::math::assign(evSafe, pow(get_base1(get_base1(cert,i,"cert",1),t,"cert",2),get_base1(rho,i,"rho",1)));
                    current_statement_begin__ = 49;
                    stan::math::assign(evGamble, (0.5 * (pow(get_base1(get_base1(gain,i,"gain",1),t,"gain",2),get_base1(rho,i,"rho",1)) - (get_base1(lambda,i,"lambda",1) * pow(get_base1(get_base1(loss,i,"loss",1),t,"loss",2),get_base1(rho,i,"rho",1))))));
                    current_statement_begin__ = 50;
                    stan::math::assign(pGamble, inv_logit((get_base1(tau,i,"tau",1) * (evGamble - evSafe))));
                    current_statement_begin__ = 51;
                    lp_accum__.add(bernoulli_log<propto__>(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2), pGamble));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("rho_p");
        names__.push_back("lambda_p");
        names__.push_back("tau_p");
        names__.push_back("rho");
        names__.push_back("lambda");
        names__.push_back("tau");
        names__.push_back("mu_rho");
        names__.push_back("mu_lambda");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ra_prospect_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d rho_p = in__.vector_constrain(N);
        vector_d lambda_p = in__.vector_constrain(N);
        vector_d tau_p = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_p[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 20;
            validate_non_negative_index("rho", "N", N);
            vector_d rho(static_cast<Eigen::VectorXd::Index>(N));
            (void) rho;  // dummy to suppress unused var warning

            stan::math::initialize(rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(rho,DUMMY_VAR__);
            current_statement_begin__ = 21;
            validate_non_negative_index("lambda", "N", N);
            vector_d lambda(static_cast<Eigen::VectorXd::Index>(N));
            (void) lambda;  // dummy to suppress unused var warning

            stan::math::initialize(lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(lambda,DUMMY_VAR__);
            current_statement_begin__ = 22;
            validate_non_negative_index("tau", "N", N);
            vector_d tau(static_cast<Eigen::VectorXd::Index>(N));
            (void) tau;  // dummy to suppress unused var warning

            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 24;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 25;
                stan::math::assign(get_base1_lhs(rho,i,"rho",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(rho_p,i,"rho_p",1)))) * 2));
                current_statement_begin__ = 26;
                stan::math::assign(get_base1_lhs(lambda,i,"lambda",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(lambda_p,i,"lambda_p",1)))) * 5));
            }
            current_statement_begin__ = 28;
            stan::math::assign(tau, exp(add(get_base1(mu_p,3,"mu_p",1),multiply(get_base1(sigma,3,"sigma",1),tau_p))));

            // validate transformed parameters
            current_statement_begin__ = 20;
            check_greater_or_equal(function__,"rho",rho,0);
            check_less_or_equal(function__,"rho",rho,2);
            current_statement_begin__ = 21;
            check_greater_or_equal(function__,"lambda",lambda,0);
            check_less_or_equal(function__,"lambda",lambda,5);
            current_statement_begin__ = 22;
            check_greater_or_equal(function__,"tau",tau,0);

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(rho[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(lambda[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 56;
            double mu_rho(0.0);
            (void) mu_rho;  // dummy to suppress unused var warning

            stan::math::initialize(mu_rho, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_rho,DUMMY_VAR__);
            current_statement_begin__ = 57;
            double mu_lambda(0.0);
            (void) mu_lambda;  // dummy to suppress unused var warning

            stan::math::initialize(mu_lambda, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_lambda,DUMMY_VAR__);
            current_statement_begin__ = 58;
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            current_statement_begin__ = 60;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 63;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 66;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 67;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 68;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 72;
            stan::math::assign(mu_rho, (Phi_approx(get_base1(mu_p,1,"mu_p",1)) * 2));
            current_statement_begin__ = 73;
            stan::math::assign(mu_lambda, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 5));
            current_statement_begin__ = 74;
            stan::math::assign(mu_tau, exp(get_base1(mu_p,3,"mu_p",1)));

            current_statement_begin__ = 77;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 78;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 79;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {
                    {
                    current_statement_begin__ = 80;
                    double evSafe(0.0);
                    (void) evSafe;  // dummy to suppress unused var warning

                    stan::math::initialize(evSafe, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(evSafe,DUMMY_VAR__);
                    current_statement_begin__ = 81;
                    double evGamble(0.0);
                    (void) evGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(evGamble, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(evGamble,DUMMY_VAR__);
                    current_statement_begin__ = 82;
                    double pGamble(0.0);
                    (void) pGamble;  // dummy to suppress unused var warning

                    stan::math::initialize(pGamble, std::numeric_limits<double>::quiet_NaN());
                    stan::math::fill(pGamble,DUMMY_VAR__);


                    current_statement_begin__ = 84;
                    stan::math::assign(evSafe, pow(get_base1(get_base1(cert,i,"cert",1),t,"cert",2),get_base1(rho,i,"rho",1)));
                    current_statement_begin__ = 85;
                    stan::math::assign(evGamble, (0.5 * (pow(get_base1(get_base1(gain,i,"gain",1),t,"gain",2),get_base1(rho,i,"rho",1)) - (get_base1(lambda,i,"lambda",1) * pow(fabs(get_base1(get_base1(loss,i,"loss",1),t,"loss",2)),get_base1(rho,i,"rho",1))))));
                    current_statement_begin__ = 86;
                    stan::math::assign(pGamble, inv_logit((get_base1(tau,i,"tau",1) * (evGamble - evSafe))));
                    current_statement_begin__ = 87;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_log(get_base1(get_base1(gamble,i,"gamble",1),t,"gamble",2),pGamble)));
                    current_statement_begin__ = 90;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(pGamble, base_rng__));
                    }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 56;
            check_greater_or_equal(function__,"mu_rho",mu_rho,0);
            check_less_or_equal(function__,"mu_rho",mu_rho,2);
            current_statement_begin__ = 57;
            check_greater_or_equal(function__,"mu_lambda",mu_lambda,0);
            check_less_or_equal(function__,"mu_lambda",mu_lambda,5);
            current_statement_begin__ = 58;
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);
            current_statement_begin__ = 60;
            current_statement_begin__ = 63;

            // write generated quantities
        vars__.push_back(mu_rho);
        vars__.push_back(mu_lambda);
        vars__.push_back(mu_tau);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ra_prospect";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rho" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lambda" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_rho";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_lambda";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ug_bayes_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ug_bayes");
    reader.add_event(164, 164, "end", "model_ug_bayes");
    return reader;
}

class model_ug_bayes : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > offer;
    vector<vector<int> > accept;
    double initV;
    double mu0;
    double k0;
    double sig20;
    double nu0;
public:
    model_ug_bayes(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ug_bayes(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ug_bayes_namespace::model_ug_bayes";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("offer", "N", N);
            validate_non_negative_index("offer", "T", T);
            context__.validate_dims("data initialization", "offer", "double", context__.to_vec(N,T));
            validate_non_negative_index("offer", "N", N);
            validate_non_negative_index("offer", "T", T);
            offer = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("offer");
            pos__ = 0;
            size_t offer_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < offer_limit_1__; ++i_1__) {
                size_t offer_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < offer_limit_0__; ++i_0__) {
                    offer[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("accept", "N", N);
            validate_non_negative_index("accept", "T", T);
            context__.validate_dims("data initialization", "accept", "int", context__.to_vec(N,T));
            validate_non_negative_index("accept", "N", N);
            validate_non_negative_index("accept", "T", T);
            accept = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("accept");
            pos__ = 0;
            size_t accept_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < accept_limit_1__; ++i_1__) {
                size_t accept_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < accept_limit_0__; ++i_0__) {
                    accept[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"accept[k0__][k1__]",accept[k0__][k1__],-(1));
                    check_less_or_equal(function__,"accept[k0__][k1__]",accept[k0__][k1__],1);
                }
            }
            // initialize data variables
            current_statement_begin__ = 10;
            initV = double(0);
            stan::math::fill(initV,DUMMY_VAR__);
            current_statement_begin__ = 11;
            mu0 = double(0);
            stan::math::fill(mu0,DUMMY_VAR__);
            current_statement_begin__ = 12;
            k0 = double(0);
            stan::math::fill(k0,DUMMY_VAR__);
            current_statement_begin__ = 13;
            sig20 = double(0);
            stan::math::fill(sig20,DUMMY_VAR__);
            current_statement_begin__ = 14;
            nu0 = double(0);
            stan::math::fill(nu0,DUMMY_VAR__);

            current_statement_begin__ = 16;
            stan::math::assign(initV, 0.0);
            current_statement_begin__ = 17;
            stan::math::assign(mu0, 10.0);
            current_statement_begin__ = 18;
            stan::math::assign(k0, 4.0);
            current_statement_begin__ = 19;
            stan::math::assign(sig20, 4.0);
            current_statement_begin__ = 20;
            stan::math::assign(nu0, 10.0);

            // validate transformed data
            current_statement_begin__ = 10;
            current_statement_begin__ = 11;
            current_statement_begin__ = 12;
            current_statement_begin__ = 13;
            current_statement_begin__ = 14;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 26;
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 27;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 30;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 31;
            validate_non_negative_index("Beta_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 32;
            validate_non_negative_index("tau_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ug_bayes() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("Beta_pr")))
            throw std::runtime_error("variable Beta_pr missing");
        vals_r__ = context__.vals_r("Beta_pr");
        pos__ = 0U;
        validate_non_negative_index("Beta_pr", "N", N);
        context__.validate_dims("initialization", "Beta_pr", "vector_d", context__.to_vec(N));
        vector_d Beta_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            Beta_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(Beta_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable Beta_pr: ") + e.what());
        }

        if (!(context__.contains_r("tau_pr")))
            throw std::runtime_error("variable tau_pr missing");
        vals_r__ = context__.vals_r("tau_pr");
        pos__ = 0U;
        validate_non_negative_index("tau_pr", "N", N);
        context__.validate_dims("initialization", "tau_pr", "vector_d", context__.to_vec(N));
        vector_d tau_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  Beta_pr;
            (void) Beta_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                Beta_pr = in__.vector_constrain(N,lp__);
            else
                Beta_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_pr;
            (void) tau_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_pr = in__.vector_constrain(N,lp__);
            else
                tau_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 37;
            validate_non_negative_index("alpha", "N", N);
            vector<T__> alpha(N);
            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            current_statement_begin__ = 38;
            validate_non_negative_index("Beta", "N", N);
            vector<T__> Beta(N);
            stan::math::initialize(Beta, DUMMY_VAR__);
            stan::math::fill(Beta,DUMMY_VAR__);
            current_statement_begin__ = 39;
            validate_non_negative_index("tau", "N", N);
            vector<T__> tau(N);
            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 41;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 42;
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 20));
                current_statement_begin__ = 43;
                stan::math::assign(get_base1_lhs(Beta,i,"Beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Beta_pr,i,"Beta_pr",1)))) * 10));
                current_statement_begin__ = 44;
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * 10));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(Beta[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 37;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"alpha[k0__]",alpha[k0__],0);
                check_less_or_equal(function__,"alpha[k0__]",alpha[k0__],20);
            }
            current_statement_begin__ = 38;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Beta[k0__]",Beta[k0__],0);
                check_less_or_equal(function__,"Beta[k0__]",Beta[k0__],10);
            }
            current_statement_begin__ = 39;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"tau[k0__]",tau[k0__],0);
                check_less_or_equal(function__,"tau[k0__]",tau[k0__],10);
            }

            // model body

            current_statement_begin__ = 50;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 51;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 54;
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1.0));
            current_statement_begin__ = 55;
            lp_accum__.add(normal_log<propto__>(Beta_pr, 0, 1.0));
            current_statement_begin__ = 56;
            lp_accum__.add(normal_log<propto__>(tau_pr, 0, 1.0));
            current_statement_begin__ = 58;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 60;
                T__ util;
                (void) util;  // dummy to suppress unused var warning

                stan::math::initialize(util, DUMMY_VAR__);
                stan::math::fill(util,DUMMY_VAR__);
                current_statement_begin__ = 61;
                T__ mu_old;
                (void) mu_old;  // dummy to suppress unused var warning

                stan::math::initialize(mu_old, DUMMY_VAR__);
                stan::math::fill(mu_old,DUMMY_VAR__);
                current_statement_begin__ = 62;
                T__ mu_new;
                (void) mu_new;  // dummy to suppress unused var warning

                stan::math::initialize(mu_new, DUMMY_VAR__);
                stan::math::fill(mu_new,DUMMY_VAR__);
                current_statement_begin__ = 63;
                T__ k_old;
                (void) k_old;  // dummy to suppress unused var warning

                stan::math::initialize(k_old, DUMMY_VAR__);
                stan::math::fill(k_old,DUMMY_VAR__);
                current_statement_begin__ = 64;
                T__ k_new;
                (void) k_new;  // dummy to suppress unused var warning

                stan::math::initialize(k_new, DUMMY_VAR__);
                stan::math::fill(k_new,DUMMY_VAR__);
                current_statement_begin__ = 65;
                T__ sig2_old;
                (void) sig2_old;  // dummy to suppress unused var warning

                stan::math::initialize(sig2_old, DUMMY_VAR__);
                stan::math::fill(sig2_old,DUMMY_VAR__);
                current_statement_begin__ = 66;
                T__ sig2_new;
                (void) sig2_new;  // dummy to suppress unused var warning

                stan::math::initialize(sig2_new, DUMMY_VAR__);
                stan::math::fill(sig2_new,DUMMY_VAR__);
                current_statement_begin__ = 67;
                T__ nu_old;
                (void) nu_old;  // dummy to suppress unused var warning

                stan::math::initialize(nu_old, DUMMY_VAR__);
                stan::math::fill(nu_old,DUMMY_VAR__);
                current_statement_begin__ = 68;
                T__ nu_new;
                (void) nu_new;  // dummy to suppress unused var warning

                stan::math::initialize(nu_new, DUMMY_VAR__);
                stan::math::fill(nu_new,DUMMY_VAR__);
                current_statement_begin__ = 69;
                T__ PE;
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, DUMMY_VAR__);
                stan::math::fill(PE,DUMMY_VAR__);


                current_statement_begin__ = 72;
                stan::math::assign(mu_old, mu0);
                current_statement_begin__ = 73;
                stan::math::assign(k_old, k0);
                current_statement_begin__ = 74;
                stan::math::assign(sig2_old, sig20);
                current_statement_begin__ = 75;
                stan::math::assign(nu_old, nu0);
                current_statement_begin__ = 77;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 78;
                    stan::math::assign(k_new, (k_old + 1));
                    current_statement_begin__ = 79;
                    stan::math::assign(nu_new, (nu_old + 1));
                    current_statement_begin__ = 80;
                    stan::math::assign(mu_new, (((k_old / k_new) * mu_old) + ((1 / k_new) * get_base1(get_base1(offer,i,"offer",1),t,"offer",2))));
                    current_statement_begin__ = 81;
                    stan::math::assign(sig2_new, (((nu_old / nu_new) * sig2_old) + (((1 / nu_new) * (k_old / k_new)) * pow((get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - mu_old),2))));
                    current_statement_begin__ = 83;
                    stan::math::assign(PE, (get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - mu_old));
                    current_statement_begin__ = 84;
                    stan::math::assign(util, ((get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - (get_base1(alpha,i,"alpha",1) * stan::math::fmax((mu_new - get_base1(get_base1(offer,i,"offer",1),t,"offer",2)),0.0))) - (get_base1(Beta,i,"Beta",1) * stan::math::fmax((get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - mu_new),0.0))));
                    current_statement_begin__ = 86;
                    lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(accept,i,"accept",1),t,"accept",2), (util * get_base1(tau,i,"tau",1))));
                    current_statement_begin__ = 89;
                    stan::math::assign(mu_old, mu_new);
                    current_statement_begin__ = 90;
                    stan::math::assign(sig2_old, sig2_new);
                    current_statement_begin__ = 91;
                    stan::math::assign(k_old, k_new);
                    current_statement_begin__ = 92;
                    stan::math::assign(nu_old, nu_new);
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("alpha_pr");
        names__.push_back("Beta_pr");
        names__.push_back("tau_pr");
        names__.push_back("alpha");
        names__.push_back("Beta");
        names__.push_back("tau");
        names__.push_back("mu_alpha");
        names__.push_back("mu_Beta");
        names__.push_back("mu_tau");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ug_bayes_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d Beta_pr = in__.vector_constrain(N);
        vector_d tau_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Beta_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 37;
            validate_non_negative_index("alpha", "N", N);
            vector<double> alpha(N, 0.0);
            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            current_statement_begin__ = 38;
            validate_non_negative_index("Beta", "N", N);
            vector<double> Beta(N, 0.0);
            stan::math::initialize(Beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Beta,DUMMY_VAR__);
            current_statement_begin__ = 39;
            validate_non_negative_index("tau", "N", N);
            vector<double> tau(N, 0.0);
            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 41;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 42;
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 20));
                current_statement_begin__ = 43;
                stan::math::assign(get_base1_lhs(Beta,i,"Beta",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(Beta_pr,i,"Beta_pr",1)))) * 10));
                current_statement_begin__ = 44;
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * 10));
            }

            // validate transformed parameters
            current_statement_begin__ = 37;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"alpha[k0__]",alpha[k0__],0);
                check_less_or_equal(function__,"alpha[k0__]",alpha[k0__],20);
            }
            current_statement_begin__ = 38;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Beta[k0__]",Beta[k0__],0);
                check_less_or_equal(function__,"Beta[k0__]",Beta[k0__],10);
            }
            current_statement_begin__ = 39;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"tau[k0__]",tau[k0__],0);
                check_less_or_equal(function__,"tau[k0__]",tau[k0__],10);
            }

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(Beta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 99;
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            current_statement_begin__ = 100;
            double mu_Beta(0.0);
            (void) mu_Beta;  // dummy to suppress unused var warning

            stan::math::initialize(mu_Beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_Beta,DUMMY_VAR__);
            current_statement_begin__ = 101;
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            current_statement_begin__ = 104;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 107;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 110;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 111;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 112;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 116;
            stan::math::assign(mu_alpha, (Phi_approx(get_base1(mu_p,1,"mu_p",1)) * 20));
            current_statement_begin__ = 117;
            stan::math::assign(mu_Beta, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 10));
            current_statement_begin__ = 118;
            stan::math::assign(mu_tau, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 10));

            current_statement_begin__ = 121;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 123;
                double util(0.0);
                (void) util;  // dummy to suppress unused var warning

                stan::math::initialize(util, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(util,DUMMY_VAR__);
                current_statement_begin__ = 124;
                double mu_old(0.0);
                (void) mu_old;  // dummy to suppress unused var warning

                stan::math::initialize(mu_old, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(mu_old,DUMMY_VAR__);
                current_statement_begin__ = 125;
                double mu_new(0.0);
                (void) mu_new;  // dummy to suppress unused var warning

                stan::math::initialize(mu_new, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(mu_new,DUMMY_VAR__);
                current_statement_begin__ = 126;
                double k_old(0.0);
                (void) k_old;  // dummy to suppress unused var warning

                stan::math::initialize(k_old, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(k_old,DUMMY_VAR__);
                current_statement_begin__ = 127;
                double k_new(0.0);
                (void) k_new;  // dummy to suppress unused var warning

                stan::math::initialize(k_new, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(k_new,DUMMY_VAR__);
                current_statement_begin__ = 128;
                double sig2_old(0.0);
                (void) sig2_old;  // dummy to suppress unused var warning

                stan::math::initialize(sig2_old, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sig2_old,DUMMY_VAR__);
                current_statement_begin__ = 129;
                double sig2_new(0.0);
                (void) sig2_new;  // dummy to suppress unused var warning

                stan::math::initialize(sig2_new, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(sig2_new,DUMMY_VAR__);
                current_statement_begin__ = 130;
                double nu_old(0.0);
                (void) nu_old;  // dummy to suppress unused var warning

                stan::math::initialize(nu_old, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(nu_old,DUMMY_VAR__);
                current_statement_begin__ = 131;
                double nu_new(0.0);
                (void) nu_new;  // dummy to suppress unused var warning

                stan::math::initialize(nu_new, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(nu_new,DUMMY_VAR__);
                current_statement_begin__ = 132;
                double PE(0.0);
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PE,DUMMY_VAR__);


                current_statement_begin__ = 135;
                stan::math::assign(mu_old, mu0);
                current_statement_begin__ = 136;
                stan::math::assign(k_old, k0);
                current_statement_begin__ = 137;
                stan::math::assign(sig2_old, sig20);
                current_statement_begin__ = 138;
                stan::math::assign(nu_old, nu0);
                current_statement_begin__ = 140;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0);
                current_statement_begin__ = 142;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 143;
                    stan::math::assign(k_new, (k_old + 1));
                    current_statement_begin__ = 144;
                    stan::math::assign(nu_new, (nu_old + 1));
                    current_statement_begin__ = 145;
                    stan::math::assign(mu_new, (((k_old / k_new) * mu_old) + ((1 / k_new) * get_base1(get_base1(offer,i,"offer",1),t,"offer",2))));
                    current_statement_begin__ = 146;
                    stan::math::assign(sig2_new, (((nu_old / nu_new) * sig2_old) + (((1 / nu_new) * (k_old / k_new)) * pow((get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - mu_old),2))));
                    current_statement_begin__ = 148;
                    stan::math::assign(PE, (get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - mu_old));
                    current_statement_begin__ = 149;
                    stan::math::assign(util, ((get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - (get_base1(alpha,i,"alpha",1) * stan::math::fmax((mu_new - get_base1(get_base1(offer,i,"offer",1),t,"offer",2)),0.0))) - (get_base1(Beta,i,"Beta",1) * stan::math::fmax((get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - mu_new),0.0))));
                    current_statement_begin__ = 151;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(accept,i,"accept",1),t,"accept",2),(util * get_base1(tau,i,"tau",1)))));
                    current_statement_begin__ = 154;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(inv_logit((util * get_base1(tau,i,"tau",1))), base_rng__));
                    current_statement_begin__ = 157;
                    stan::math::assign(mu_old, mu_new);
                    current_statement_begin__ = 158;
                    stan::math::assign(sig2_old, sig2_new);
                    current_statement_begin__ = 159;
                    stan::math::assign(k_old, k_new);
                    current_statement_begin__ = 160;
                    stan::math::assign(nu_old, nu_new);
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 99;
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_less_or_equal(function__,"mu_alpha",mu_alpha,20);
            current_statement_begin__ = 100;
            check_greater_or_equal(function__,"mu_Beta",mu_Beta,0);
            check_less_or_equal(function__,"mu_Beta",mu_Beta,10);
            current_statement_begin__ = 101;
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);
            check_less_or_equal(function__,"mu_tau",mu_tau,10);
            current_statement_begin__ = 104;
            current_statement_begin__ = 107;

            // write generated quantities
        vars__.push_back(mu_alpha);
        vars__.push_back(mu_Beta);
        vars__.push_back(mu_tau);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ug_bayes";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Beta_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_Beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ug_delta_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ug_delta");
    reader.add_event(126, 126, "end", "model_ug_delta");
    return reader;
}

class model_ug_delta : public prob_grad {
private:
    int N;
    int T;
    vector<int> Tsubj;
    vector<vector<double> > offer;
    vector<vector<int> > accept;
public:
    model_ug_delta(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ug_delta(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ug_delta_namespace::model_ug_delta";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 2;
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            current_statement_begin__ = 4;
            validate_non_negative_index("Tsubj", "N", N);
            context__.validate_dims("data initialization", "Tsubj", "int", context__.to_vec(N));
            validate_non_negative_index("Tsubj", "N", N);
            Tsubj = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("Tsubj");
            pos__ = 0;
            size_t Tsubj_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < Tsubj_limit_0__; ++i_0__) {
                Tsubj[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 5;
            validate_non_negative_index("offer", "N", N);
            validate_non_negative_index("offer", "T", T);
            context__.validate_dims("data initialization", "offer", "double", context__.to_vec(N,T));
            validate_non_negative_index("offer", "N", N);
            validate_non_negative_index("offer", "T", T);
            offer = std::vector<std::vector<double> >(N,std::vector<double>(T,double(0)));
            vals_r__ = context__.vals_r("offer");
            pos__ = 0;
            size_t offer_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < offer_limit_1__; ++i_1__) {
                size_t offer_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < offer_limit_0__; ++i_0__) {
                    offer[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 6;
            validate_non_negative_index("accept", "N", N);
            validate_non_negative_index("accept", "T", T);
            context__.validate_dims("data initialization", "accept", "int", context__.to_vec(N,T));
            validate_non_negative_index("accept", "N", N);
            validate_non_negative_index("accept", "T", T);
            accept = std::vector<std::vector<int> >(N,std::vector<int>(T,int(0)));
            vals_i__ = context__.vals_i("accept");
            pos__ = 0;
            size_t accept_limit_1__ = T;
            for (size_t i_1__ = 0; i_1__ < accept_limit_1__; ++i_1__) {
                size_t accept_limit_0__ = N;
                for (size_t i_0__ = 0; i_0__ < accept_limit_0__; ++i_0__) {
                    accept[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            current_statement_begin__ = 2;
            check_greater_or_equal(function__,"N",N,1);
            current_statement_begin__ = 3;
            check_greater_or_equal(function__,"T",T,1);
            current_statement_begin__ = 4;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],1);
                check_less_or_equal(function__,"Tsubj[k0__]",Tsubj[k0__],T);
            }
            current_statement_begin__ = 5;
            current_statement_begin__ = 6;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                for (int k1__ = 0; k1__ < T; ++k1__) {
                    check_greater_or_equal(function__,"accept[k0__][k1__]",accept[k0__][k1__],-(1));
                    check_less_or_equal(function__,"accept[k0__][k1__]",accept[k0__][k1__],1);
                }
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 15;
            validate_non_negative_index("mu_p", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 16;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
            current_statement_begin__ = 19;
            validate_non_negative_index("ep_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 20;
            validate_non_negative_index("alpha_pr", "N", N);
            num_params_r__ += N;
            current_statement_begin__ = 21;
            validate_non_negative_index("tau_pr", "N", N);
            num_params_r__ += N;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ug_delta() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu_p")))
            throw std::runtime_error("variable mu_p missing");
        vals_r__ = context__.vals_r("mu_p");
        pos__ = 0U;
        validate_non_negative_index("mu_p", "3", 3);
        context__.validate_dims("initialization", "mu_p", "vector_d", context__.to_vec(3));
        vector_d mu_p(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            mu_p(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu_p);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_p: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(3));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("ep_pr")))
            throw std::runtime_error("variable ep_pr missing");
        vals_r__ = context__.vals_r("ep_pr");
        pos__ = 0U;
        validate_non_negative_index("ep_pr", "N", N);
        context__.validate_dims("initialization", "ep_pr", "vector_d", context__.to_vec(N));
        vector_d ep_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            ep_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(ep_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ep_pr: ") + e.what());
        }

        if (!(context__.contains_r("alpha_pr")))
            throw std::runtime_error("variable alpha_pr missing");
        vals_r__ = context__.vals_r("alpha_pr");
        pos__ = 0U;
        validate_non_negative_index("alpha_pr", "N", N);
        context__.validate_dims("initialization", "alpha_pr", "vector_d", context__.to_vec(N));
        vector_d alpha_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            alpha_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(alpha_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_pr: ") + e.what());
        }

        if (!(context__.contains_r("tau_pr")))
            throw std::runtime_error("variable tau_pr missing");
        vals_r__ = context__.vals_r("tau_pr");
        pos__ = 0U;
        validate_non_negative_index("tau_pr", "N", N);
        context__.validate_dims("initialization", "tau_pr", "vector_d", context__.to_vec(N));
        vector_d tau_pr(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            tau_pr(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tau_pr);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau_pr: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_p;
            (void) mu_p;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_p = in__.vector_constrain(3,lp__);
            else
                mu_p = in__.vector_constrain(3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,3,lp__);
            else
                sigma = in__.vector_lb_constrain(0,3);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  ep_pr;
            (void) ep_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                ep_pr = in__.vector_constrain(N,lp__);
            else
                ep_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  alpha_pr;
            (void) alpha_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_pr = in__.vector_constrain(N,lp__);
            else
                alpha_pr = in__.vector_constrain(N);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  tau_pr;
            (void) tau_pr;  // dummy to suppress unused var warning
            if (jacobian__)
                tau_pr = in__.vector_constrain(N,lp__);
            else
                tau_pr = in__.vector_constrain(N);


            // transformed parameters
            current_statement_begin__ = 26;
            validate_non_negative_index("ep", "N", N);
            vector<T__> ep(N);
            stan::math::initialize(ep, DUMMY_VAR__);
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("alpha", "N", N);
            vector<T__> alpha(N);
            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("tau", "N", N);
            vector<T__> tau(N);
            stan::math::initialize(tau, DUMMY_VAR__);
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 30;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 31;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * 10));
                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 20));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(ep[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: ep" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(alpha[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: alpha" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(tau[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: tau" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 26;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"ep[k0__]",ep[k0__],0);
                check_less_or_equal(function__,"ep[k0__]",ep[k0__],1);
            }
            current_statement_begin__ = 27;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"alpha[k0__]",alpha[k0__],0);
                check_less_or_equal(function__,"alpha[k0__]",alpha[k0__],20);
            }
            current_statement_begin__ = 28;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"tau[k0__]",tau[k0__],0);
                check_less_or_equal(function__,"tau[k0__]",tau[k0__],10);
            }

            // model body

            current_statement_begin__ = 39;
            lp_accum__.add(normal_log<propto__>(mu_p, 0, 1));
            current_statement_begin__ = 40;
            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 5));
            current_statement_begin__ = 43;
            lp_accum__.add(normal_log<propto__>(ep_pr, 0, 1.0));
            current_statement_begin__ = 44;
            lp_accum__.add(normal_log<propto__>(alpha_pr, 0, 1.0));
            current_statement_begin__ = 45;
            lp_accum__.add(normal_log<propto__>(tau_pr, 0, 1.0));
            current_statement_begin__ = 47;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 49;
                T__ f;
                (void) f;  // dummy to suppress unused var warning

                stan::math::initialize(f, DUMMY_VAR__);
                stan::math::fill(f,DUMMY_VAR__);
                current_statement_begin__ = 50;
                T__ PE;
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, DUMMY_VAR__);
                stan::math::fill(PE,DUMMY_VAR__);
                current_statement_begin__ = 51;
                T__ util;
                (void) util;  // dummy to suppress unused var warning

                stan::math::initialize(util, DUMMY_VAR__);
                stan::math::fill(util,DUMMY_VAR__);


                current_statement_begin__ = 54;
                stan::math::assign(f, 10.0);
                current_statement_begin__ = 56;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 58;
                    stan::math::assign(PE, (get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - f));
                    current_statement_begin__ = 61;
                    stan::math::assign(util, (get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - (get_base1(alpha,i,"alpha",1) * stan::math::fmax((f - get_base1(get_base1(offer,i,"offer",1),t,"offer",2)),0.0))));
                    current_statement_begin__ = 64;
                    lp_accum__.add(bernoulli_logit_log<propto__>(get_base1(get_base1(accept,i,"accept",1),t,"accept",2), (util * get_base1(tau,i,"tau",1))));
                    current_statement_begin__ = 67;
                    stan::math::assign(f, (f + (get_base1(ep,i,"ep",1) * PE)));
                }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu_p");
        names__.push_back("sigma");
        names__.push_back("ep_pr");
        names__.push_back("alpha_pr");
        names__.push_back("tau_pr");
        names__.push_back("ep");
        names__.push_back("alpha");
        names__.push_back("tau");
        names__.push_back("mu_ep");
        names__.push_back("mu_tau");
        names__.push_back("mu_alpha");
        names__.push_back("log_lik");
        names__.push_back("y_pred");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(T);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ug_delta_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu_p = in__.vector_constrain(3);
        vector_d sigma = in__.vector_lb_constrain(0,3);
        vector_d ep_pr = in__.vector_constrain(N);
        vector_d alpha_pr = in__.vector_constrain(N);
        vector_d tau_pr = in__.vector_constrain(N);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(mu_p[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha_pr[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau_pr[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 26;
            validate_non_negative_index("ep", "N", N);
            vector<double> ep(N, 0.0);
            stan::math::initialize(ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(ep,DUMMY_VAR__);
            current_statement_begin__ = 27;
            validate_non_negative_index("alpha", "N", N);
            vector<double> alpha(N, 0.0);
            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            current_statement_begin__ = 28;
            validate_non_negative_index("tau", "N", N);
            vector<double> tau(N, 0.0);
            stan::math::initialize(tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau,DUMMY_VAR__);


            current_statement_begin__ = 30;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 31;
                stan::math::assign(get_base1_lhs(ep,i,"ep",1), Phi_approx((get_base1(mu_p,1,"mu_p",1) + (get_base1(sigma,1,"sigma",1) * get_base1(ep_pr,i,"ep_pr",1)))));
                current_statement_begin__ = 32;
                stan::math::assign(get_base1_lhs(tau,i,"tau",1), (Phi_approx((get_base1(mu_p,2,"mu_p",1) + (get_base1(sigma,2,"sigma",1) * get_base1(tau_pr,i,"tau_pr",1)))) * 10));
                current_statement_begin__ = 33;
                stan::math::assign(get_base1_lhs(alpha,i,"alpha",1), (Phi_approx((get_base1(mu_p,3,"mu_p",1) + (get_base1(sigma,3,"sigma",1) * get_base1(alpha_pr,i,"alpha_pr",1)))) * 20));
            }

            // validate transformed parameters
            current_statement_begin__ = 26;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"ep[k0__]",ep[k0__],0);
                check_less_or_equal(function__,"ep[k0__]",ep[k0__],1);
            }
            current_statement_begin__ = 27;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"alpha[k0__]",alpha[k0__],0);
                check_less_or_equal(function__,"alpha[k0__]",alpha[k0__],20);
            }
            current_statement_begin__ = 28;
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"tau[k0__]",tau[k0__],0);
                check_less_or_equal(function__,"tau[k0__]",tau[k0__],10);
            }

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(ep[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(alpha[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(tau[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 75;
            double mu_ep(0.0);
            (void) mu_ep;  // dummy to suppress unused var warning

            stan::math::initialize(mu_ep, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ep,DUMMY_VAR__);
            current_statement_begin__ = 76;
            double mu_tau(0.0);
            (void) mu_tau;  // dummy to suppress unused var warning

            stan::math::initialize(mu_tau, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_tau,DUMMY_VAR__);
            current_statement_begin__ = 77;
            double mu_alpha(0.0);
            (void) mu_alpha;  // dummy to suppress unused var warning

            stan::math::initialize(mu_alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_alpha,DUMMY_VAR__);
            current_statement_begin__ = 80;
            validate_non_negative_index("log_lik", "N", N);
            vector<double> log_lik(N, 0.0);
            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);
            current_statement_begin__ = 83;
            validate_non_negative_index("y_pred", "N", N);
            validate_non_negative_index("y_pred", "T", T);
            vector<vector<double> > y_pred(N, (vector<double>(T, 0.0)));
            stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_pred,DUMMY_VAR__);


            current_statement_begin__ = 86;
            for (int i = 1; i <= N; ++i) {

                current_statement_begin__ = 87;
                for (int t = 1; t <= T; ++t) {

                    current_statement_begin__ = 88;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), -(1));
                }
            }
            current_statement_begin__ = 92;
            stan::math::assign(mu_ep, Phi_approx(get_base1(mu_p,1,"mu_p",1)));
            current_statement_begin__ = 93;
            stan::math::assign(mu_tau, (Phi_approx(get_base1(mu_p,2,"mu_p",1)) * 10));
            current_statement_begin__ = 94;
            stan::math::assign(mu_alpha, (Phi_approx(get_base1(mu_p,3,"mu_p",1)) * 20));

            current_statement_begin__ = 97;
            for (int i = 1; i <= N; ++i) {
                {
                current_statement_begin__ = 99;
                double f(0.0);
                (void) f;  // dummy to suppress unused var warning

                stan::math::initialize(f, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(f,DUMMY_VAR__);
                current_statement_begin__ = 100;
                double PE(0.0);
                (void) PE;  // dummy to suppress unused var warning

                stan::math::initialize(PE, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(PE,DUMMY_VAR__);
                current_statement_begin__ = 101;
                double util(0.0);
                (void) util;  // dummy to suppress unused var warning

                stan::math::initialize(util, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(util,DUMMY_VAR__);


                current_statement_begin__ = 104;
                stan::math::assign(f, 10.0);
                current_statement_begin__ = 105;
                stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), 0.0);
                current_statement_begin__ = 107;
                for (int t = 1; t <= get_base1(Tsubj,i,"Tsubj",1); ++t) {

                    current_statement_begin__ = 109;
                    stan::math::assign(PE, (get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - f));
                    current_statement_begin__ = 112;
                    stan::math::assign(util, (get_base1(get_base1(offer,i,"offer",1),t,"offer",2) - (get_base1(alpha,i,"alpha",1) * stan::math::fmax((f - get_base1(get_base1(offer,i,"offer",1),t,"offer",2)),0.0))));
                    current_statement_begin__ = 115;
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), (get_base1(log_lik,i,"log_lik",1) + bernoulli_logit_log(get_base1(get_base1(accept,i,"accept",1),t,"accept",2),(util * get_base1(tau,i,"tau",1)))));
                    current_statement_begin__ = 118;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(y_pred,i,"y_pred",1),t,"y_pred",2), bernoulli_rng(inv_logit((util * get_base1(tau,i,"tau",1))), base_rng__));
                    current_statement_begin__ = 121;
                    stan::math::assign(f, (f + (get_base1(ep,i,"ep",1) * PE)));
                }
                }
            }

            // validate generated quantities
            current_statement_begin__ = 75;
            check_greater_or_equal(function__,"mu_ep",mu_ep,0);
            check_less_or_equal(function__,"mu_ep",mu_ep,1);
            current_statement_begin__ = 76;
            check_greater_or_equal(function__,"mu_tau",mu_tau,0);
            check_less_or_equal(function__,"mu_tau",mu_tau,10);
            current_statement_begin__ = 77;
            check_greater_or_equal(function__,"mu_alpha",mu_alpha,0);
            check_less_or_equal(function__,"mu_alpha",mu_alpha,20);
            current_statement_begin__ = 80;
            current_statement_begin__ = 83;

            // write generated quantities
        vars__.push_back(mu_ep);
        vars__.push_back(mu_tau);
        vars__.push_back(mu_alpha);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(y_pred[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ug_delta";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_p" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau_pr" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ep" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tau" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_ep";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_tau";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "mu_alpha";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_pred" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




#endif
